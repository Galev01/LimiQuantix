#!/bin/sh
# =============================================================================
# Quantix-vDC DCUI (Direct Console User Interface)
# =============================================================================
# Interactive console interface for Quantix-vDC appliance management.
# Similar to VMware ESXi DCUI.
# =============================================================================

# Configuration
DIALOG=${DIALOG:-dialog}
BACKTITLE="Quantix-vDC DCUI"
VERSION=$(cat /etc/quantix-version 2>/dev/null || echo "unknown")
TEMP_FILE="/tmp/dcui.$$"

# Cleanup on exit
cleanup() {
    rm -f "$TEMP_FILE"
    clear
}
trap cleanup EXIT

# =============================================================================
# Helper Functions
# =============================================================================

get_primary_ip() {
    ip -4 addr show scope global 2>/dev/null | grep inet | head -1 | awk '{print $2}' | cut -d/ -f1
}

get_hostname() {
    hostname 2>/dev/null || cat /etc/hostname 2>/dev/null || echo "unknown"
}

get_service_status() {
    local service="$1"
    
    # Handle PostgreSQL naming (Alpine 3.20 uses postgresql16)
    if [ "$service" = "postgresql" ]; then
        if [ -f /etc/init.d/postgresql16 ]; then
            service="postgresql16"
        fi
    fi
    
    # First try OpenRC status
    if rc-service "$service" status 2>/dev/null | grep -q "started"; then
        echo "Running"
        return
    fi
    
    # Fallback: Check if process is actually running (for services with PID file issues)
    case "$service" in
        nginx)
            if pgrep -x nginx >/dev/null 2>&1; then
                echo "Running*"  # Asterisk indicates running but OpenRC out of sync
                return
            fi
            ;;
        quantix-controlplane)
            if pgrep -f qx-controlplane >/dev/null 2>&1; then
                echo "Running*"
                return
            fi
            ;;
        redis)
            if pgrep -x redis-server >/dev/null 2>&1; then
                echo "Running*"
                return
            fi
            ;;
        etcd)
            if pgrep -x etcd >/dev/null 2>&1; then
                echo "Running*"
                return
            fi
            ;;
        postgresql|postgresql16)
            if pgrep -x postgres >/dev/null 2>&1; then
                echo "Running*"
                return
            fi
            ;;
    esac
    
    echo "Stopped"
}

# Get actual PostgreSQL service name
get_pg_service() {
    if [ -f /etc/init.d/postgresql16 ]; then
        echo "postgresql16"
    else
        echo "postgresql"
    fi
}

is_ssh_enabled() {
    if rc-update show default 2>/dev/null | grep -q sshd; then
        echo "Enabled"
    else
        echo "Disabled"
    fi
}

# =============================================================================
# Display System Info
# =============================================================================

show_system_info() {
    local PRIMARY_IP=$(get_primary_ip)
    local HOSTNAME=$(get_hostname)
    
    # Get more detailed service status
    local CP_STATUS=$(get_service_status quantix-controlplane)
    local PG_STATUS=$(get_service_status postgresql)
    local REDIS_STATUS=$(get_service_status redis)
    local ETCD_STATUS=$(get_service_status etcd)
    local NGINX_STATUS=$(get_service_status nginx)
    
    # Check if binaries exist
    local CP_NOTE=""
    local ETCD_NOTE=""
    if [ ! -x /usr/bin/qx-controlplane ]; then
        CP_NOTE=" (not installed)"
    fi
    if [ ! -x /usr/bin/etcd ]; then
        ETCD_NOTE=" (installing on first boot)"
    fi
    
    $DIALOG --backtitle "$BACKTITLE v$VERSION" \
        --title "System Information" \
        --msgbox "\n\
Hostname:     $HOSTNAME\n\
IP Address:   ${PRIMARY_IP:-No network connection}\n\
\n\
Web Console:  https://${PRIMARY_IP:-localhost}/\n\
API Endpoint: https://${PRIMARY_IP:-localhost}/api/v1/\n\
SSH:          $(is_ssh_enabled)\n\
\n\
Services:\n\
  Control Plane: ${CP_STATUS}${CP_NOTE}\n\
  PostgreSQL:    ${PG_STATUS}\n\
  Redis:         ${REDIS_STATUS}\n\
  etcd:          ${ETCD_STATUS}${ETCD_NOTE}\n\
  nginx:         ${NGINX_STATUS}\n\
" 24 65
}

# =============================================================================
# Network Configuration
# =============================================================================

configure_network() {
    # Build list of available interfaces (both ethernet and WiFi)
    local IFACE_LIST=""
    local IFACE_COUNT=0
    local DEFAULT_IFACE=""
    
    # Find all physical network interfaces
    for iface in $(ip link show | grep -E "^[0-9]+: (eth|ens|enp|wlan|wlp)" | awk -F: '{print $2}' | tr -d ' '); do
        local iface_ip=$(ip -4 addr show "$iface" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
        local iface_status="down"
        ip link show "$iface" 2>/dev/null | grep -q "state UP" && iface_status="up"
        
        # Mark interface type
        local iface_type="Ethernet"
        echo "$iface" | grep -qE "^(wlan|wlp)" && iface_type="WiFi"
        
        # Build menu item
        local desc="${iface_type}"
        [ -n "$iface_ip" ] && desc="${desc} - ${iface_ip}"
        [ "$iface_status" = "down" ] && desc="${desc} (down)"
        
        IFACE_LIST="$IFACE_LIST \"$iface\" \"$desc\""
        IFACE_COUNT=$((IFACE_COUNT + 1))
        
        # Default to first interface with an IP, or first interface
        if [ -z "$DEFAULT_IFACE" ]; then
            DEFAULT_IFACE="$iface"
        elif [ -n "$iface_ip" ] && [ -z "$(ip -4 addr show "$DEFAULT_IFACE" 2>/dev/null | grep inet)" ]; then
            DEFAULT_IFACE="$iface"
        fi
    done
    
    # Fallback
    [ -z "$DEFAULT_IFACE" ] && DEFAULT_IFACE="eth0"
    
    local IFACE="$DEFAULT_IFACE"
    
    # If multiple interfaces, let user choose
    if [ "$IFACE_COUNT" -gt 1 ]; then
        eval "$DIALOG --backtitle \"$BACKTITLE\" \
            --title \"Select Interface\" \
            --menu \"\nSelect the network interface to configure:\" 15 60 $IFACE_COUNT \
            $IFACE_LIST" 2>"$TEMP_FILE"
        
        [ $? -ne 0 ] && return
        IFACE=$(cat "$TEMP_FILE")
    fi
    
    # Current config for selected interface
    local CURRENT_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
    local CURRENT_MASK=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f2)
    local CURRENT_GW=$(ip route | grep default | awk '{print $3}' | head -1)
    local CURRENT_DNS=$(grep nameserver /etc/resolv.conf 2>/dev/null | head -1 | awk '{print $2}')
    
    # Detect interface type
    local IFACE_TYPE="Ethernet"
    echo "$IFACE" | grep -qE "^(wlan|wlp)" && IFACE_TYPE="WiFi"
    
    # Ask DHCP or Static
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Network Configuration" \
        --menu "\nInterface: $IFACE ($IFACE_TYPE)\nCurrent IP: ${CURRENT_IP:-None}\n\nSelect IP configuration mode:" 15 60 2 \
        "dhcp" "Automatic (DHCP)" \
        "static" "Manual (Static IP)" \
        2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local MODE=$(cat "$TEMP_FILE")
    
    if [ "$MODE" = "dhcp" ]; then
        configure_network_dhcp "$IFACE"
    else
        configure_network_static "$IFACE" "$CURRENT_IP" "$CURRENT_MASK" "$CURRENT_GW" "$CURRENT_DNS"
    fi
}

configure_network_dhcp() {
    local IFACE="$1"
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Confirm DHCP" \
        --yesno "\nConfigure $IFACE for DHCP?\n\nThis will restart networking." 10 50
    
    [ $? -ne 0 ] && return
    
    # Detect if this is a WiFi interface
    local IS_WIFI=0
    echo "$IFACE" | grep -qE "^(wlan|wlp)" && IS_WIFI=1
    
    # Write interface config
    if [ "$IS_WIFI" -eq 1 ]; then
        # WiFi interface - need to include wpa_supplicant
        cat > /etc/network/interfaces << EOF
auto lo
iface lo inet loopback

auto $IFACE
iface $IFACE inet dhcp
    pre-up wpa_supplicant -B -i $IFACE -c /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null || true
    post-down killall wpa_supplicant 2>/dev/null || true
EOF
    else
        # Ethernet interface
        cat > /etc/network/interfaces << EOF
auto lo
iface lo inet loopback

auto $IFACE
iface $IFACE inet dhcp
EOF
    fi
    
    # Apply configuration
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Applying Configuration" \
        --infobox "\nApplying network configuration...\n" 6 40
    
    if [ "$IS_WIFI" -eq 1 ]; then
        # For WiFi, run udhcpc directly
        pkill -f "udhcpc.*$IFACE" 2>/dev/null || true
        ip addr flush dev "$IFACE" 2>/dev/null
        udhcpc -i "$IFACE" -b -q 2>/dev/null &
    else
        # For ethernet, restart networking service
        rc-service networking restart >/dev/null 2>&1
    fi
    
    sleep 3
    
    local NEW_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Network Configured" \
        --msgbox "\nNetwork configured for DHCP.\n\nInterface: $IFACE\nNew IP: ${NEW_IP:-Waiting for DHCP...}" 10 50
}

configure_network_static() {
    local IFACE="$1"
    local DEF_IP="${2:-192.168.1.100}"
    local DEF_MASK="${3:-24}"
    local DEF_GW="${4:-192.168.1.1}"
    local DEF_DNS="${5:-8.8.8.8}"
    
    # Get IP Address
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Static IP Configuration" \
        --inputbox "Enter IP Address:" 10 50 "$DEF_IP" 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local IP=$(cat "$TEMP_FILE")
    
    # Get Netmask
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Static IP Configuration" \
        --inputbox "Enter Netmask (CIDR, e.g., 24):" 10 50 "$DEF_MASK" 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local MASK=$(cat "$TEMP_FILE")
    
    # Get Gateway
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Static IP Configuration" \
        --inputbox "Enter Gateway:" 10 50 "$DEF_GW" 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local GW=$(cat "$TEMP_FILE")
    
    # Get DNS
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Static IP Configuration" \
        --inputbox "Enter DNS Server:" 10 50 "$DEF_DNS" 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local DNS=$(cat "$TEMP_FILE")
    
    # Confirm
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Confirm Configuration" \
        --yesno "\nApply the following configuration?\n\nInterface: $IFACE\nIP Address: $IP/$MASK\nGateway: $GW\nDNS: $DNS" 14 50
    
    [ $? -ne 0 ] && return
    
    # Detect if this is a WiFi interface
    local IS_WIFI=0
    echo "$IFACE" | grep -qE "^(wlan|wlp)" && IS_WIFI=1
    
    # Write interface config
    if [ "$IS_WIFI" -eq 1 ]; then
        # WiFi interface - need to include wpa_supplicant
        cat > /etc/network/interfaces << EOF
auto lo
iface lo inet loopback

auto $IFACE
iface $IFACE inet static
    address $IP/$MASK
    gateway $GW
    pre-up wpa_supplicant -B -i $IFACE -c /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null || true
    post-down killall wpa_supplicant 2>/dev/null || true
EOF
    else
        # Ethernet interface
        cat > /etc/network/interfaces << EOF
auto lo
iface lo inet loopback

auto $IFACE
iface $IFACE inet static
    address $IP/$MASK
    gateway $GW
EOF
    fi
    
    # Write DNS config
    echo "nameserver $DNS" > /etc/resolv.conf
    
    # Apply configuration
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Applying Configuration" \
        --infobox "\nApplying network configuration...\n" 6 40
    
    # Kill any existing DHCP client on this interface
    pkill -f "udhcpc.*$IFACE" 2>/dev/null || true
    pkill -f "dhclient.*$IFACE" 2>/dev/null || true
    killall udhcpc 2>/dev/null || true
    sleep 1
    
    # Apply configuration directly (works for both WiFi and Ethernet)
    # Flush existing IP
    ip addr flush dev "$IFACE" 2>/dev/null
    
    # Bring interface up
    ip link set "$IFACE" up
    
    # Add IP address
    ip addr add "$IP/$MASK" dev "$IFACE" 2>/dev/null
    
    # Delete old default route and add new one
    ip route del default 2>/dev/null
    ip route add default via "$GW" dev "$IFACE" 2>/dev/null
    
    # Also try restarting networking service (for persistence on next boot)
    rc-service networking restart >/dev/null 2>&1 || true
    
    sleep 2
    
    # Verify the IP was applied
    local NEW_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
    
    if [ "$NEW_IP" = "$IP" ]; then
        $DIALOG --backtitle "$BACKTITLE" \
            --title "Network Configured" \
            --msgbox "\nStatic IP configuration applied successfully!\n\nInterface: $IFACE\nIP: $IP/$MASK\nGateway: $GW\nDNS: $DNS" 14 50
    else
        $DIALOG --backtitle "$BACKTITLE" \
            --title "Warning" \
            --msgbox "\nConfiguration saved but IP may not have applied correctly.\n\nExpected: $IP\nCurrent: ${NEW_IP:-None}\n\nTry restarting the system." 14 50
    fi
}

# =============================================================================
# WiFi Configuration
# =============================================================================

configure_wifi() {
    # Check if wireless interface exists
    local WIFI_IFACE=$(ip link show | grep -E "^[0-9]+: (wlan|wlp)" | head -1 | awk -F: '{print $2}' | tr -d ' ')
    
    if [ -z "$WIFI_IFACE" ]; then
        $DIALOG --backtitle "$BACKTITLE" \
            --title "WiFi Configuration" \
            --msgbox "\nNo wireless interface detected.\n\nMake sure WiFi hardware is present and drivers are loaded." 10 60
        return
    fi
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "WiFi Configuration" \
        --menu "\nWiFi Interface: $WIFI_IFACE\n\nSelect action:" 14 60 4 \
        "scan" "Scan for networks" \
        "connect" "Connect to network" \
        "disconnect" "Disconnect WiFi" \
        "status" "Show WiFi status" \
        2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local ACTION=$(cat "$TEMP_FILE")
    
    case "$ACTION" in
        scan)
            scan_wifi_networks "$WIFI_IFACE"
            ;;
        connect)
            connect_wifi "$WIFI_IFACE"
            ;;
        disconnect)
            disconnect_wifi "$WIFI_IFACE"
            ;;
        status)
            show_wifi_status "$WIFI_IFACE"
            ;;
    esac
}

scan_wifi_networks() {
    local IFACE="$1"
    
    $DIALOG --infobox "\nScanning for WiFi networks..." 5 40
    
    # Bring interface up
    ip link set "$IFACE" up 2>/dev/null
    sleep 1
    
    # Scan networks
    if command -v iwlist >/dev/null 2>&1; then
        local NETWORKS=$(iwlist "$IFACE" scan 2>/dev/null | grep -E "ESSID:|Quality=" | paste - - | \
            sed 's/.*ESSID:"\([^"]*\)".*Quality=\([0-9]*\).*/\2% \1/' | sort -rn | head -15)
    else
        local NETWORKS="Scanning not available\n(iwlist not installed)"
    fi
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Available Networks" \
        --msgbox "\nFound networks:\n\n$NETWORKS" 20 60
}

connect_wifi() {
    local IFACE="$1"
    
    # Get SSID
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Connect to WiFi" \
        --inputbox "Enter WiFi network name (SSID):" 10 50 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local SSID=$(cat "$TEMP_FILE")
    
    if [ -z "$SSID" ]; then
        $DIALOG --msgbox "\nSSID cannot be empty!" 8 40
        return
    fi
    
    # Get password
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Connect to WiFi" \
        --insecure \
        --passwordbox "Enter WiFi password:" 10 50 2>"$TEMP_FILE"
    [ $? -ne 0 ] && return
    local PASSWORD=$(cat "$TEMP_FILE")
    
    $DIALOG --infobox "\nConnecting to $SSID..." 5 40
    
    # Create wpa_supplicant config
    mkdir -p /etc/wpa_supplicant
    cat > /etc/wpa_supplicant/wpa_supplicant.conf << EOF
ctrl_interface=/var/run/wpa_supplicant
update_config=1

network={
    ssid="$SSID"
    psk="$PASSWORD"
    key_mgmt=WPA-PSK
}
EOF
    chmod 600 /etc/wpa_supplicant/wpa_supplicant.conf
    
    # Stop any existing wpa_supplicant
    killall wpa_supplicant 2>/dev/null
    sleep 1
    
    # Start wpa_supplicant
    ip link set "$IFACE" up
    wpa_supplicant -B -i "$IFACE" -c /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null
    sleep 3
    
    # Get IP via DHCP
    udhcpc -i "$IFACE" -b -q 2>/dev/null &
    sleep 3
    
    # Check connection
    local WIFI_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
    
    if [ -n "$WIFI_IP" ]; then
        $DIALOG --msgbox "\nConnected to $SSID\n\nIP Address: $WIFI_IP" 10 50
        
        # Enable wpa_supplicant at boot
        rc-update add wpa_supplicant default 2>/dev/null || true
    else
        $DIALOG --msgbox "\nFailed to connect to $SSID\n\nCheck password and try again." 10 50
    fi
}

disconnect_wifi() {
    local IFACE="$1"
    
    killall wpa_supplicant 2>/dev/null
    ip link set "$IFACE" down 2>/dev/null
    
    $DIALOG --msgbox "\nWiFi disconnected." 8 40
}

show_wifi_status() {
    local IFACE="$1"
    
    local STATUS=""
    
    if command -v iwconfig >/dev/null 2>&1; then
        STATUS=$(iwconfig "$IFACE" 2>/dev/null)
    fi
    
    local WIFI_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "WiFi Status" \
        --msgbox "\nInterface: $IFACE\nIP Address: ${WIFI_IP:-Not connected}\n\n$STATUS" 18 70
}

# =============================================================================
# SSH Configuration
# =============================================================================

configure_ssh() {
    local SSH_STATUS=$(is_ssh_enabled)
    local SSH_RUNNING=$(get_service_status sshd)
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "SSH Configuration" \
        --menu "\nSSH Status: $SSH_STATUS\nSSH Service: $SSH_RUNNING\n\nSelect action:" 15 60 4 \
        "enable" "Enable SSH (start at boot)" \
        "disable" "Disable SSH" \
        "start" "Start SSH now" \
        "stop" "Stop SSH now" \
        2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local ACTION=$(cat "$TEMP_FILE")
    
    case "$ACTION" in
        enable)
            rc-update add sshd default >/dev/null 2>&1
            rc-service sshd start >/dev/null 2>&1
            $DIALOG --msgbox "\nSSH enabled and started." 8 40
            ;;
        disable)
            rc-update del sshd default >/dev/null 2>&1
            rc-service sshd stop >/dev/null 2>&1
            $DIALOG --msgbox "\nSSH disabled and stopped." 8 40
            ;;
        start)
            rc-service sshd start >/dev/null 2>&1
            $DIALOG --msgbox "\nSSH started." 8 40
            ;;
        stop)
            rc-service sshd stop >/dev/null 2>&1
            $DIALOG --msgbox "\nSSH stopped." 8 40
            ;;
    esac
}

# =============================================================================
# Service Management
# =============================================================================

manage_services() {
    while true; do
        $DIALOG --backtitle "$BACKTITLE" \
            --title "Service Management" \
            --menu "\nSelect service to manage:\n" 18 60 8 \
            "controlplane" "Control Plane: $(get_service_status quantix-controlplane)" \
            "postgresql" "PostgreSQL: $(get_service_status postgresql)" \
            "redis" "Redis: $(get_service_status redis)" \
            "etcd" "etcd: $(get_service_status etcd)" \
            "nginx" "nginx: $(get_service_status nginx)" \
            "sshd" "SSH: $(get_service_status sshd)" \
            "restart_all" "Restart All Services" \
            "back" "Back to Main Menu" \
            2>"$TEMP_FILE"
        
        [ $? -ne 0 ] && return
        
        local SERVICE=$(cat "$TEMP_FILE")
        
        [ "$SERVICE" = "back" ] && return
        
        if [ "$SERVICE" = "restart_all" ]; then
            restart_all_services
            continue
        fi
        
        # Map service names
        local REAL_SERVICE="$SERVICE"
        [ "$SERVICE" = "controlplane" ] && REAL_SERVICE="quantix-controlplane"
        [ "$SERVICE" = "postgresql" ] && REAL_SERVICE="$(get_pg_service)"
        
        $DIALOG --backtitle "$BACKTITLE" \
            --title "Manage $SERVICE" \
            --menu "\nCurrent Status: $(get_service_status $REAL_SERVICE)\n\nSelect action:" 14 50 3 \
            "start" "Start Service" \
            "stop" "Stop Service" \
            "restart" "Restart Service" \
            2>"$TEMP_FILE"
        
        [ $? -ne 0 ] && continue
        
        local ACTION=$(cat "$TEMP_FILE")
        
        $DIALOG --infobox "\n${ACTION}ing $SERVICE..." 5 40
        
        # Special handling for nginx - force kill and free ports
        if [ "$SERVICE" = "nginx" ]; then
            nginx_service_action "$ACTION"
        else
            rc-service "$REAL_SERVICE" "$ACTION" >/dev/null 2>&1
        fi
        sleep 2
    done
}

# =============================================================================
# nginx Special Handling
# =============================================================================
# nginx often has issues with stale processes and port conflicts.
# This function ensures a clean start/stop/restart.

nginx_service_action() {
    local ACTION="$1"
    
    case "$ACTION" in
        stop|restart)
            # Force stop nginx - kill all processes and free ports
            
            # 1. Try graceful stop first
            rc-service nginx stop >/dev/null 2>&1
            sleep 1
            
            # 2. Kill any remaining nginx processes
            if pgrep -x nginx >/dev/null 2>&1; then
                pkill -QUIT nginx 2>/dev/null
                sleep 1
            fi
            
            if pgrep -x nginx >/dev/null 2>&1; then
                pkill -TERM nginx 2>/dev/null
                sleep 1
            fi
            
            if pgrep -x nginx >/dev/null 2>&1; then
                pkill -9 nginx 2>/dev/null
                sleep 1
            fi
            
            # 3. Free ports 80 and 443 if still in use
            if command -v fuser >/dev/null 2>&1; then
                fuser -k 80/tcp 2>/dev/null || true
                fuser -k 443/tcp 2>/dev/null || true
            fi
            
            # 4. Clean up PID file
            rm -f /run/nginx.pid
            
            # If this was just a stop, we're done
            [ "$ACTION" = "stop" ] && return 0
            
            # Fall through to start for restart
            sleep 1
            ;;
    esac
    
    # Start nginx
    if [ "$ACTION" = "start" ] || [ "$ACTION" = "restart" ]; then
        # Ensure directories exist
        mkdir -p /var/lib/nginx/logs /var/log/nginx
        mkdir -p /var/lib/nginx/tmp/client_body /var/lib/nginx/tmp/proxy
        chown -R nginx:nginx /var/lib/nginx /var/log/nginx 2>/dev/null || true
        
        # Test config first
        if ! nginx -t >/dev/null 2>&1; then
            return 1
        fi
        
        # Start via OpenRC
        rc-service nginx start >/dev/null 2>&1
        
        # Verify it started
        sleep 1
        if pgrep -x nginx >/dev/null 2>&1; then
            # Update PID file if needed
            NGINX_PID=$(pgrep -o -x nginx)
            echo "$NGINX_PID" > /run/nginx.pid
            return 0
        else
            return 1
        fi
    fi
}

restart_all_services() {
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Restart All Services" \
        --yesno "\nRestart all Quantix-vDC services?\n\nThis will restart:\n- PostgreSQL\n- Redis\n- etcd\n- Control Plane\n- nginx" 14 50
    
    [ $? -ne 0 ] && return
    
    $DIALOG --infobox "\nRestarting services...\n" 5 40
    
    # Get actual PostgreSQL service name
    local PG_SVC=$(get_pg_service)
    
    # Restart backend services first
    for svc in $PG_SVC redis etcd quantix-controlplane; do
        rc-service "$svc" restart >/dev/null 2>&1
    done
    
    # Special handling for nginx (force kill and free ports)
    nginx_service_action "restart"
    
    sleep 2
    
    $DIALOG --msgbox "\nAll services restarted." 8 40
}

# =============================================================================
# Root Password Change
# =============================================================================

change_root_password() {
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Change Root Password" \
        --insecure \
        --passwordbox "Enter new root password:" 10 50 2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local PASS1=$(cat "$TEMP_FILE")
    
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Change Root Password" \
        --insecure \
        --passwordbox "Confirm new password:" 10 50 2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local PASS2=$(cat "$TEMP_FILE")
    
    if [ "$PASS1" != "$PASS2" ]; then
        $DIALOG --msgbox "\nPasswords do not match!" 8 40
        return
    fi
    
    if [ -z "$PASS1" ]; then
        $DIALOG --msgbox "\nPassword cannot be empty!" 8 40
        return
    fi
    
    echo "root:$PASS1" | chpasswd
    
    $DIALOG --msgbox "\nRoot password changed successfully." 8 40
}

# =============================================================================
# Troubleshooting
# =============================================================================

troubleshooting_menu() {
    while true; do
        $DIALOG --backtitle "$BACKTITLE" \
            --title "Troubleshooting" \
            --menu "\nSelect option:" 20 65 11 \
            "diagnose" "Diagnose Service Issues" \
            "start_all" "Force Start All Services" \
            "logs_cp" "View Control Plane Logs" \
            "logs_err" "View Control Plane Errors" \
            "logs_startup" "View Startup Log" \
            "logs_pg" "View PostgreSQL Logs" \
            "network" "Test Network Connectivity" \
            "restart_net" "Restart Networking" \
            "shell" "Drop to Shell" \
            "back" "Back to Main Menu" \
            2>"$TEMP_FILE"
        
        [ $? -ne 0 ] && return
        
        local CHOICE=$(cat "$TEMP_FILE")
        
        case "$CHOICE" in
            diagnose)
                local DIAG_LOG="/tmp/diagnose.log"
                {
                    echo "=== Quantix-vDC Service Diagnostics ==="
                    echo "Date: $(date)"
                    echo ""
                    
                    echo "=== System Info ==="
                    echo "Hostname: $(hostname)"
                    echo "IP: $(get_primary_ip)"
                    echo ""
                    
                    echo "=== PostgreSQL ==="
                    PG_SVC=$(get_pg_service)
                    echo "Service name: $PG_SVC"
                    PG_DATA="/var/lib/postgresql/16/data"
                    if [ -d "$PG_DATA" ]; then
                        echo "Data dir exists: YES"
                        if [ -f "$PG_DATA/PG_VERSION" ]; then
                            echo "Initialized: YES (version: $(cat $PG_DATA/PG_VERSION))"
                        else
                            echo "Initialized: NO - needs initdb!"
                        fi
                        echo "Permissions: $(ls -ld $PG_DATA)"
                        echo "Owner: $(stat -c '%U:%G' $PG_DATA 2>/dev/null || echo 'unknown')"
                    else
                        echo "Data dir exists: NO - needs creation!"
                    fi
                    
                    # Check for initdb
                    echo ""
                    echo "initdb locations:"
                    for path in /usr/bin/initdb /usr/libexec/postgresql16/initdb /usr/lib/postgresql16/bin/initdb; do
                        if [ -x "$path" ]; then
                            echo "  FOUND: $path"
                        fi
                    done
                    
                    echo ""
                    echo "Service status: $(rc-service $PG_SVC status 2>&1)"
                    
                    echo ""
                    echo "=== etcd ==="
                    if [ -x /usr/bin/etcd ]; then
                        echo "Binary: FOUND"
                        echo "Service status: $(rc-service etcd status 2>&1)"
                    else
                        echo "Binary: NOT FOUND!"
                    fi
                    
                    echo ""
                    echo "=== Control Plane ==="
                    if [ -x /usr/bin/qx-controlplane ]; then
                        echo "Binary: FOUND"
                        ls -l /usr/bin/qx-controlplane
                        echo "Service status: $(rc-service quantix-controlplane status 2>&1)"
                        if [ -f /var/log/quantix-controlplane.err.log ]; then
                            echo ""
                            echo "Last 5 error lines:"
                            tail -5 /var/log/quantix-controlplane.err.log
                        fi
                    else
                        echo "Binary: NOT FOUND at /usr/bin/qx-controlplane!"
                        echo ""
                        echo "Contents of /usr/bin/:"
                        ls -la /usr/bin/ | grep -E "qx|quantix" || echo "  (no quantix binaries found)"
                    fi
                    
                    echo ""
                    echo "=== nginx ==="
                    echo "Service status: $(rc-service nginx status 2>&1)"
                    if [ -f /etc/nginx/nginx.conf ]; then
                        echo "Config test:"
                        nginx -t 2>&1
                    fi
                    
                    echo ""
                    echo "=== Redis ==="
                    echo "Service status: $(rc-service redis status 2>&1)"
                    
                    echo ""
                    echo "=== Disk Space ==="
                    df -h / /var 2>/dev/null || df -h
                    
                    echo ""
                    echo "=== Memory ==="
                    free -m 2>/dev/null || cat /proc/meminfo | head -5
                    
                } > "$DIAG_LOG" 2>&1
                
                $DIALOG --backtitle "$BACKTITLE" \
                    --title "Service Diagnostics" \
                    --textbox "$DIAG_LOG" 24 78
                
                rm -f "$DIAG_LOG"
                ;;
            logs_cp)
                if [ -f /var/log/quantix-controlplane.log ]; then
                    tail -50 /var/log/quantix-controlplane.log > /tmp/logs_view.txt
                    $DIALOG --backtitle "$BACKTITLE" \
                        --title "Control Plane Logs (last 50 lines)" \
                        --textbox /tmp/logs_view.txt 22 80
                else
                    $DIALOG --msgbox "\nNo control plane logs found.\n\nThe service may not have started." 10 50
                fi
                ;;
            logs_err)
                if [ -f /var/log/quantix-controlplane.err.log ]; then
                    tail -50 /var/log/quantix-controlplane.err.log > /tmp/logs_view.txt
                    $DIALOG --backtitle "$BACKTITLE" \
                        --title "Control Plane Error Log (last 50 lines)" \
                        --textbox /tmp/logs_view.txt 22 80
                else
                    $DIALOG --msgbox "\nNo error logs found (this is good!)." 8 50
                fi
                ;;
            logs_startup)
                if [ -f /var/log/quantix-startup.log ]; then
                    $DIALOG --backtitle "$BACKTITLE" \
                        --title "Startup Log" \
                        --textbox /var/log/quantix-startup.log 22 80
                else
                    $DIALOG --msgbox "\nNo startup log found.\n\nThe service startup helper may not have run." 10 55
                fi
                ;;
            logs_pg)
                local PG_LOG=$(ls -t /var/lib/postgresql/16/data/log/*.log 2>/dev/null | head -1)
                if [ -n "$PG_LOG" ] && [ -f "$PG_LOG" ]; then
                    tail -50 "$PG_LOG" > /tmp/logs_view.txt
                    $DIALOG --backtitle "$BACKTITLE" \
                        --title "PostgreSQL Logs" \
                        --textbox /tmp/logs_view.txt 22 80
                else
                    $DIALOG --msgbox "\nNo PostgreSQL logs found.\n\nPostgreSQL may not be initialized." 10 50
                fi
                ;;
            start_all)
                $DIALOG --backtitle "$BACKTITLE" \
                    --title "Force Start Services" \
                    --yesno "\nThis will attempt to start all services with verbose output.\n\nContinue?" 10 50
                
                if [ $? -eq 0 ]; then
                    # Run with verbose output to a temp file
                    local START_LOG="/tmp/start_services.log"
                    
                    {
                        echo "=== Force Starting All Services ==="
                        echo ""
                        
                        # Get correct PostgreSQL service name
                        PG_SVC=$(get_pg_service)
                        echo "PostgreSQL service: $PG_SVC"
                        
                        # Initialize PostgreSQL if needed
                        PG_DATA="/var/lib/postgresql/16/data"
                        if [ ! -f "$PG_DATA/PG_VERSION" ]; then
                            echo ""
                            echo ">>> PostgreSQL not initialized, initializing..."
                            mkdir -p "$PG_DATA"
                            chown -R postgres:postgres /var/lib/postgresql
                            chmod 700 "$PG_DATA"
                            
                            # Find initdb
                            INITDB=""
                            for path in /usr/bin/initdb /usr/libexec/postgresql16/initdb /usr/lib/postgresql16/bin/initdb; do
                                if [ -x "$path" ]; then
                                    INITDB="$path"
                                    break
                                fi
                            done
                            
                            if [ -n "$INITDB" ]; then
                                echo "Using initdb: $INITDB"
                                su -s /bin/sh postgres -c "$INITDB -D $PG_DATA --encoding=UTF8 --locale=C" 2>&1
                                
                                # Configure for local trust
                                if [ -f "$PG_DATA/pg_hba.conf" ]; then
                                    cat > "$PG_DATA/pg_hba.conf" << 'PGCONF'
local   all             all                                     trust
host    all             all             127.0.0.1/32            trust
host    all             all             ::1/128                 trust
PGCONF
                                fi
                            else
                                echo "ERROR: initdb not found!"
                            fi
                        else
                            echo "PostgreSQL already initialized"
                        fi
                        
                        echo ""
                        echo ">>> Starting PostgreSQL..."
                        rc-service $PG_SVC start 2>&1
                        sleep 2
                        
                        echo ""
                        echo ">>> Starting Redis..."
                        rc-service redis start 2>&1
                        sleep 1
                        
                        echo ""
                        echo ">>> Starting etcd..."
                        if [ -x /usr/bin/etcd ]; then
                            mkdir -p /var/lib/etcd
                            chmod 700 /var/lib/etcd
                            rc-service etcd start 2>&1
                        else
                            echo "etcd binary not found"
                        fi
                        sleep 1
                        
                        # Wait for PostgreSQL
                        echo ""
                        echo ">>> Waiting for PostgreSQL to be ready..."
                        for i in 1 2 3 4 5 6 7 8 9 10; do
                            if pg_isready -q 2>/dev/null; then
                                echo "PostgreSQL is ready!"
                                break
                            fi
                            echo "  Waiting... ($i/10)"
                            sleep 1
                        done
                        
                        # Create database if needed
                        echo ""
                        echo ">>> Checking/creating quantix_vdc database..."
                        su -s /bin/sh postgres -c "psql -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw quantix_vdc" || {
                            echo "Creating database..."
                            su -s /bin/sh postgres -c "createdb quantix_vdc" 2>&1
                        }
                        
                        echo ""
                        echo ">>> Starting Control Plane..."
                        if [ -x /usr/bin/qx-controlplane ]; then
                            rc-service quantix-controlplane start 2>&1
                        else
                            echo "ERROR: /usr/bin/qx-controlplane not found!"
                        fi
                        sleep 2
                        
                        echo ""
                        echo ">>> Starting nginx..."
                        rc-service nginx start 2>&1
                        sleep 1
                        
                        echo ""
                        echo "=== Final Status ==="
                        echo "PostgreSQL: $(get_service_status postgresql)"
                        echo "Redis: $(get_service_status redis)"
                        echo "etcd: $(get_service_status etcd)"
                        echo "Control Plane: $(get_service_status quantix-controlplane)"
                        echo "nginx: $(get_service_status nginx)"
                        
                    } > "$START_LOG" 2>&1
                    
                    # Show the log
                    $DIALOG --backtitle "$BACKTITLE" \
                        --title "Service Startup Results" \
                        --textbox "$START_LOG" 22 75
                    
                    rm -f "$START_LOG"
                fi
                ;;
            network)
                local OUTPUT=$(ping -c 3 8.8.8.8 2>&1)
                $DIALOG --backtitle "$BACKTITLE" \
                    --title "Network Test" \
                    --msgbox "$OUTPUT" 15 60
                ;;
            restart_net)
                $DIALOG --infobox "\nRestarting network..." 5 40
                rc-service networking restart >/dev/null 2>&1
                sleep 3
                $DIALOG --msgbox "\nNetwork restarted.\nNew IP: $(get_primary_ip)" 10 50
                ;;
            shell)
                clear
                echo ""
                echo "Type 'exit' to return to DCUI"
                echo ""
                /bin/sh
                ;;
            back)
                return
                ;;
        esac
    done
}

# =============================================================================
# Reboot / Shutdown
# =============================================================================

power_menu() {
    $DIALOG --backtitle "$BACKTITLE" \
        --title "Power Options" \
        --menu "\nSelect action:" 12 50 3 \
        "reboot" "Reboot System" \
        "shutdown" "Shutdown System" \
        "back" "Back to Main Menu" \
        2>"$TEMP_FILE"
    
    [ $? -ne 0 ] && return
    
    local CHOICE=$(cat "$TEMP_FILE")
    
    case "$CHOICE" in
        reboot)
            $DIALOG --yesno "\nReboot the system now?" 8 40
            [ $? -eq 0 ] && reboot
            ;;
        shutdown)
            $DIALOG --yesno "\nShutdown the system now?" 8 40
            [ $? -eq 0 ] && poweroff
            ;;
    esac
}

# =============================================================================
# Main Menu
# =============================================================================

main_menu() {
    while true; do
        local PRIMARY_IP=$(get_primary_ip)
        local HOSTNAME=$(get_hostname)
        
        $DIALOG --backtitle "$BACKTITLE v$VERSION" \
            --title "Main Menu" \
            --menu "\n   Hostname: $HOSTNAME\n   IP Address: ${PRIMARY_IP:-No network}\n   Web: https://${PRIMARY_IP:-localhost}/\n" 22 70 10 \
            "1" "System Information" \
            "2" "Configure Network (Ethernet)" \
            "3" "Configure WiFi" \
            "4" "Configure SSH" \
            "5" "Manage Services" \
            "6" "Change Root Password" \
            "7" "Troubleshooting" \
            "8" "Power Options" \
            "9" "Exit to Login Prompt" \
            2>"$TEMP_FILE"
        
        [ $? -ne 0 ] && continue
        
        local CHOICE=$(cat "$TEMP_FILE")
        
        case "$CHOICE" in
            1) show_system_info ;;
            2) configure_network ;;
            3) configure_wifi ;;
            4) configure_ssh ;;
            5) manage_services ;;
            6) change_root_password ;;
            7) troubleshooting_menu ;;
            8) power_menu ;;
            9) 
                clear
                echo ""
                echo "Quantix-vDC Control Plane Appliance"
                echo "Press Enter to return to DCUI..."
                read
                ;;
        esac
    done
}

# =============================================================================
# Entry Point
# =============================================================================

# Check for dialog
if ! command -v dialog >/dev/null 2>&1; then
    echo "ERROR: dialog not installed"
    exec /bin/sh
fi

# Run main menu
main_menu
