#!/sbin/openrc-run
# =============================================================================
# Quantix-vDC First Boot Service
# =============================================================================
# Runs on first boot to perform initial system configuration.
# Initializes PostgreSQL, generates TLS certificates, creates admin user.
# =============================================================================

name="Quantix-vDC First Boot"
description="One-time first boot configuration"

depend() {
    need localmount
    before postgresql redis etcd quantix-controlplane nginx
}

start() {
    # Check if first boot
    if [ -f /var/lib/quantix-vdc/.setup_complete ]; then
        einfo "First boot already completed"
        return 0
    fi

    ebegin "Running first boot configuration"

    # Generate SSH host keys
    if [ ! -f /etc/ssh/ssh_host_rsa_key ]; then
        einfo "Generating SSH host keys..."
        ssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N "" -q 2>/dev/null || true
        ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N "" -q 2>/dev/null || true
        ssh-keygen -t ecdsa -b 521 -f /etc/ssh/ssh_host_ecdsa_key -N "" -q 2>/dev/null || true
    fi

    # Generate TLS certificates
    CERT_DIR="/var/lib/quantix-vdc/certs"
    if [ ! -f "$CERT_DIR/server.key" ]; then
        einfo "Generating TLS certificates..."
        mkdir -p "$CERT_DIR"
        chmod 700 "$CERT_DIR"
        
        HOSTNAME=$(hostname)
        
        # Get primary IP for SAN
        PRIMARY_IP=$(ip -4 addr show scope global | grep inet | head -1 | awk '{print $2}' | cut -d/ -f1)
        PRIMARY_IP=${PRIMARY_IP:-"127.0.0.1"}
        
        openssl genrsa -out "$CERT_DIR/server.key" 4096 2>/dev/null
        openssl req -new -x509 \
            -key "$CERT_DIR/server.key" \
            -out "$CERT_DIR/server.crt" \
            -days 3650 \
            -subj "/CN=${HOSTNAME}/O=Quantix-KVM/OU=Control-Plane" \
            -addext "subjectAltName=DNS:${HOSTNAME},DNS:localhost,IP:127.0.0.1,IP:${PRIMARY_IP}" 2>/dev/null
        
        chmod 600 "$CERT_DIR/server.key"
        chmod 644 "$CERT_DIR/server.crt"
        
        einfo "TLS certificate generated for ${HOSTNAME} (${PRIMARY_IP})"
    fi

    # Initialize PostgreSQL
    PG_DATA="/var/lib/postgresql/16/data"
    PG_LOG_DIR="/var/log/postgresql"
    PG_RUN_DIR="/run/postgresql"
    
    # Create PostgreSQL symlinks if needed (postgresql16 installs to /usr/libexec/postgresql16/)
    PG_BIN_DIR=""
    for dir in /usr/libexec/postgresql16 /usr/lib/postgresql16/bin /usr/lib/postgresql/16/bin; do
        if [ -d "$dir" ]; then
            PG_BIN_DIR="$dir"
            break
        fi
    done
    
    if [ -n "$PG_BIN_DIR" ]; then
        einfo "Creating PostgreSQL symlinks from $PG_BIN_DIR..."
        for bin in pg_ctl pg_isready initdb postgres psql pg_dump pg_restore createdb dropdb; do
            if [ -f "$PG_BIN_DIR/$bin" ] && [ ! -e "/usr/bin/$bin" ]; then
                ln -sf "$PG_BIN_DIR/$bin" "/usr/bin/$bin"
            fi
        done
    fi
    
    # Create required directories
    mkdir -p "$PG_DATA" "$PG_LOG_DIR" "$PG_RUN_DIR"
    chown -R postgres:postgres /var/lib/postgresql "$PG_LOG_DIR" "$PG_RUN_DIR"
    chmod 700 "$PG_DATA"
    chmod 755 "$PG_RUN_DIR"
    
    if [ ! -d "$PG_DATA/base" ]; then
        einfo "Initializing PostgreSQL database..."
        
        # Find initdb binary
        INITDB=""
        for path in /usr/bin/initdb /usr/libexec/postgresql16/initdb /usr/lib/postgresql16/bin/initdb; do
            if [ -x "$path" ]; then
                INITDB="$path"
                break
            fi
        done
        [ -z "$INITDB" ] && INITDB="$(which initdb 2>/dev/null)"
        
        if [ -n "$INITDB" ]; then
            einfo "Using initdb: $INITDB"
            su -s /bin/sh postgres -c "$INITDB -D $PG_DATA --encoding=UTF8 --locale=C" 2>/dev/null || {
                ewarn "Failed to initialize PostgreSQL"
            }
        else
            eerror "initdb not found! PostgreSQL cannot be initialized."
        fi
        
        # Configure PostgreSQL for local connections
        if [ -f "$PG_DATA/pg_hba.conf" ]; then
            cat > "$PG_DATA/pg_hba.conf" << 'EOF'
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust
host    all             all             127.0.0.1/32            trust
host    all             all             ::1/128                 trust
EOF
        fi
        
        # Configure PostgreSQL settings
        if [ -f "$PG_DATA/postgresql.conf" ]; then
            sed -i "s/#listen_addresses = 'localhost'/listen_addresses = '127.0.0.1'/" "$PG_DATA/postgresql.conf"
            sed -i "s/#port = 5432/port = 5432/" "$PG_DATA/postgresql.conf"
        fi
    fi

    # Check if etcd is already bundled (from ISO build)
    if [ -f /usr/bin/etcd ]; then
        einfo "etcd already bundled in image"
        # Ensure init script exists
        if [ ! -f /etc/init.d/etcd ]; then
            cat > /etc/init.d/etcd << 'ETCDINIT'
#!/sbin/openrc-run
name="etcd"
description="etcd distributed key-value store"
command="/usr/bin/etcd"
command_args="--data-dir=/var/lib/etcd --listen-client-urls=http://127.0.0.1:2379 --advertise-client-urls=http://127.0.0.1:2379"
command_background="yes"
pidfile="/run/etcd.pid"
output_log="/var/log/etcd.log"
error_log="/var/log/etcd.err"

depend() {
    need net localmount
    after quantix-firstboot
}

start_pre() {
    mkdir -p /var/lib/etcd
    chmod 700 /var/lib/etcd
}
ETCDINIT
            chmod +x /etc/init.d/etcd
        fi
        rc-update add etcd default 2>/dev/null || true
    else
        # Fallback: Try to download etcd if not bundled (requires network)
        einfo "etcd not bundled, attempting download..."
        ETCD_VERSION="v3.5.17"
        ETCD_ARCH="amd64"
        
        # Wait for network to be available (WiFi might take time)
        for i in 1 2 3 4 5; do
            if ping -c 1 -W 2 github.com >/dev/null 2>&1; then
                einfo "Network available, downloading etcd..."
                break
            fi
            ewarn "Waiting for network... ($i/5)"
            sleep 5
        done
        
        # Download etcd
        cd /tmp
        wget -q "https://github.com/etcd-io/etcd/releases/download/${ETCD_VERSION}/etcd-${ETCD_VERSION}-linux-${ETCD_ARCH}.tar.gz" -O etcd.tar.gz 2>/dev/null || {
            ewarn "Failed to download etcd, will run without distributed coordination"
        }
        
        if [ -f /tmp/etcd.tar.gz ]; then
            tar -xzf etcd.tar.gz
            cp etcd-${ETCD_VERSION}-linux-${ETCD_ARCH}/etcd /usr/bin/
            cp etcd-${ETCD_VERSION}-linux-${ETCD_ARCH}/etcdctl /usr/bin/
            chmod +x /usr/bin/etcd /usr/bin/etcdctl
            rm -rf etcd.tar.gz etcd-${ETCD_VERSION}-linux-${ETCD_ARCH}
            einfo "etcd installed successfully"
            
            # Create etcd OpenRC init script
            cat > /etc/init.d/etcd << 'ETCDINIT'
#!/sbin/openrc-run
name="etcd"
description="etcd distributed key-value store"
command="/usr/bin/etcd"
command_args="--data-dir=/var/lib/etcd --listen-client-urls=http://127.0.0.1:2379 --advertise-client-urls=http://127.0.0.1:2379"
command_background="yes"
pidfile="/run/etcd.pid"
output_log="/var/log/etcd.log"
error_log="/var/log/etcd.err"

depend() {
    need net localmount
    after quantix-firstboot
}

start_pre() {
    mkdir -p /var/lib/etcd
    chmod 700 /var/lib/etcd
}
ETCDINIT
            chmod +x /etc/init.d/etcd
            rc-update add etcd default 2>/dev/null || true
        fi
    fi

    # Initialize etcd data directory
    if [ ! -d /var/lib/etcd ]; then
        einfo "Creating etcd data directory..."
        mkdir -p /var/lib/etcd
        chown -R root:root /var/lib/etcd
        chmod 700 /var/lib/etcd
    fi

    # Initialize Redis data directory
    if [ ! -d /var/lib/redis ]; then
        einfo "Creating Redis data directory..."
        mkdir -p /var/lib/redis
        chown -R redis:redis /var/lib/redis 2>/dev/null || chown -R root:root /var/lib/redis
        chmod 700 /var/lib/redis
    fi

    # Create log directories
    mkdir -p /var/log/quantix-vdc
    chmod 755 /var/log/quantix-vdc

    # Create nginx runtime directories
    einfo "Creating nginx runtime directories..."
    rm -rf /var/lib/nginx/logs /var/lib/nginx/tmp /var/log/nginx 2>/dev/null || true
    mkdir -p /var/lib/nginx/logs
    mkdir -p /var/lib/nginx/tmp/client_body
    mkdir -p /var/lib/nginx/tmp/proxy
    mkdir -p /var/lib/nginx/tmp/fastcgi
    mkdir -p /var/log/nginx
    chown -R nginx:nginx /var/lib/nginx /var/log/nginx 2>/dev/null || true

    # Ensure Quantix boot entry is first in UEFI BootOrder (avoid PXE stalls)
    if command -v efibootmgr >/dev/null 2>&1 && [ -d /sys/firmware/efi/efivars ]; then
        einfo "Checking UEFI boot order..."
        BOOT_ENTRY=$(efibootmgr | awk 'tolower($0) ~ /quantix/ && $1 ~ /^Boot[0-9A-F]{4}/ {gsub(/^Boot/,"",$1); gsub(/\*/,"",$1); print $1; exit}')
        if [ -n "$BOOT_ENTRY" ]; then
            CURRENT_ORDER=$(efibootmgr | awk -F'BootOrder: ' 'NF==2 {print $2}' | tr -d '\r')
            if [ -n "$CURRENT_ORDER" ]; then
                # Check if Quantix is already first
                FIRST_ENTRY=$(echo "$CURRENT_ORDER" | cut -d',' -f1)
                if [ "$FIRST_ENTRY" != "$BOOT_ENTRY" ]; then
                    einfo "Moving Quantix to first boot entry..."
                    REST_ORDER=$(printf '%s' "$CURRENT_ORDER" | awk -v entry="$BOOT_ENTRY" 'BEGIN{RS=","; ORS=","} toupper($0)!=toupper(entry) && length($0)>0 {print $0}' | sed 's/,$//')
                    if [ -n "$REST_ORDER" ]; then
                        NEW_ORDER="${BOOT_ENTRY},${REST_ORDER}"
                    else
                        NEW_ORDER="${BOOT_ENTRY}"
                    fi
                    efibootmgr -o "$NEW_ORDER" >/dev/null 2>&1 || ewarn "Failed to update UEFI BootOrder"
                    efibootmgr -n "$BOOT_ENTRY" >/dev/null 2>&1 || true
                fi
            fi
        fi
    fi

    # Mark first boot complete
    mkdir -p /var/lib/quantix-vdc
    touch /var/lib/quantix-vdc/.setup_complete

    eend 0
}

stop() {
    return 0
}
