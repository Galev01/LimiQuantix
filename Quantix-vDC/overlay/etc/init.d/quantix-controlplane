#!/sbin/openrc-run
# =============================================================================
# Quantix-vDC Control Plane Service
# =============================================================================
# Manages the Quantix control plane backend (Go).
# =============================================================================

name="Quantix Control Plane"
description="Quantix-vDC centralized control plane"
command="/usr/bin/qx-controlplane"
command_args="--config /etc/quantix-vdc/config.yaml"
command_background="yes"
pidfile="/run/quantix-controlplane.pid"
output_log="/var/log/quantix-controlplane.log"
error_log="/var/log/quantix-controlplane.err.log"

depend() {
    need net localmount
    after postgresql redis etcd quantix-firstboot
    before nginx
    provide quantix-controlplane
}

start_pre() {
    # Ensure log directory exists
    mkdir -p /var/log
    
    # Ensure runtime directory exists
    mkdir -p /run/quantix-vdc
    
    # Ensure config directory exists
    mkdir -p /etc/quantix-vdc
    
    # Ensure data directories exist
    mkdir -p /var/lib/quantix-vdc
    mkdir -p /var/lib/quantix-vdc/certs
    chmod 700 /var/lib/quantix-vdc/certs
    
    # Check if binary exists
    if [ ! -x "$command" ]; then
        eerror "Control plane binary not found: $command"
        eerror "The control plane may not be installed properly."
        return 1
    fi
    
    # Wait for PostgreSQL to be ready
    if command -v pg_isready >/dev/null 2>&1; then
        einfo "Waiting for PostgreSQL..."
        for i in $(seq 1 30); do
            if pg_isready -q; then
                einfo "PostgreSQL is ready"
                break
            fi
            sleep 1
        done
    fi
    
    # Create database if it doesn't exist
    if command -v psql >/dev/null 2>&1 && pg_isready -q 2>/dev/null; then
        if ! su -s /bin/sh postgres -c "psql -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw quantix_vdc"; then
            einfo "Creating quantix_vdc database..."
            su -s /bin/sh postgres -c "createdb quantix_vdc" 2>/dev/null || \
                su -s /bin/sh postgres -c "psql -c 'CREATE DATABASE quantix_vdc;'" 2>/dev/null || \
                ewarn "Failed to create database"
        fi
        
        # Run migrations if database exists
        MIGRATIONS_DIR="/usr/share/quantix-vdc/migrations"
        if [ -d "$MIGRATIONS_DIR" ] && su -s /bin/sh postgres -c "psql -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw quantix_vdc"; then
            # Check if migrations have been run by looking for a known table
            if ! su -s /bin/sh postgres -c "psql -d quantix_vdc -c '\\dt' 2>/dev/null | grep -q 'virtual_machines'"; then
                einfo "Running database migrations..."
                for migration in $(ls -1 ${MIGRATIONS_DIR}/*.up.sql 2>/dev/null | sort); do
                    MIGRATION_NAME=$(basename "$migration")
                    einfo "  Applying: $MIGRATION_NAME"
                    su -s /bin/sh postgres -c "psql -d quantix_vdc -f '$migration'" >/dev/null 2>&1 || true
                done
                
                # Grant permissions
                su -s /bin/sh postgres -c "psql -d quantix_vdc -c 'GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO postgres;'" >/dev/null 2>&1 || true
                su -s /bin/sh postgres -c "psql -d quantix_vdc -c 'GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO postgres;'" >/dev/null 2>&1 || true
                einfo "Migrations complete"
            fi
        fi
    fi
    
    return 0
}

start() {
    ebegin "Starting $name"
    
    start-stop-daemon --start \
        --background \
        --make-pidfile \
        --pidfile "$pidfile" \
        --stdout "$output_log" \
        --stderr "$error_log" \
        --exec "$command" \
        -- $command_args
    
    eend $?
}

stop() {
    ebegin "Stopping $name"
    
    start-stop-daemon --stop \
        --pidfile "$pidfile" \
        --retry TERM/30/KILL/5
    
    eend $?
}

# Note: We intentionally do NOT override status() here.
# OpenRC's default status function outputs "started" or "stopped" which is
# what our DCUI's get_service_status() function expects to see.
# Custom status() functions that output different text break the TUI detection.
