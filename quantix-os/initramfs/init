#!/bin/sh
# =============================================================================
# Quantix-OS Init Script (initramfs)
# =============================================================================
# This script runs from initramfs and sets up the root filesystem.
# Supports:
#   - Live boot from ISO/USB (boot=live)
#   - Installed system boot (root=LABEL=QUANTIX-A)
#   - A/B partitioning with automatic rollback
# =============================================================================

# VERY FIRST THING: Try to get output working
# This runs before anything else to ensure we can see messages

# Mount essential filesystems
/bin/busybox mount -t proc none /proc 2>/dev/null || mount -t proc none /proc
/bin/busybox mount -t sysfs none /sys 2>/dev/null || mount -t sysfs none /sys
/bin/busybox mount -t devtmpfs none /dev 2>/dev/null || mount -t devtmpfs none /dev

# Enable ALL kernel messages to console
echo 8 > /proc/sys/kernel/printk 2>/dev/null

# Create essential device nodes if devtmpfs didn't
[ -c /dev/console ] || mknod -m 622 /dev/console c 5 1 2>/dev/null
[ -c /dev/null ] || mknod -m 666 /dev/null c 1 3 2>/dev/null
[ -c /dev/tty ] || mknod -m 666 /dev/tty c 5 0 2>/dev/null
[ -c /dev/tty0 ] || mknod -m 666 /dev/tty0 c 4 0 2>/dev/null
[ -c /dev/tty1 ] || mknod -m 666 /dev/tty1 c 4 1 2>/dev/null

# Redirect output to console
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

echo ""
echo "============================================================"
echo "     QUANTIX-OS INITRAMFS STARTING"
echo "============================================================"
echo ""
echo "[INIT] Script is running!"
echo "[INIT] Date: $(date 2>/dev/null || echo 'unknown')"
echo "[INIT] Shell: $0"
echo "[INIT] PID: $$"
echo ""

# =============================================================================
# CRITICAL: Load kernel modules for block devices FIRST
# =============================================================================
echo "[INIT] Loading kernel modules..."

# Find kernel version
KVER=""
if [ -d /lib/modules ]; then
    KVER=$(ls /lib/modules 2>/dev/null | head -1)
    echo "[INIT] Kernel modules directory: /lib/modules/$KVER"
    ls -la /lib/modules/ 2>/dev/null
else
    echo "[INIT] WARNING: No /lib/modules directory!"
fi

if [ -n "$KVER" ] && [ -d "/lib/modules/$KVER" ]; then
    # SCSI subsystem (MUST load first - other drivers depend on it)
    echo "[INIT] Loading SCSI subsystem..."
    for mod in scsi_mod sd_mod sr_mod; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || echo "[INIT]   - $mod (built-in?)"
    done
    
    # USB drivers (for USB boot)
    echo "[INIT] Loading USB drivers..."
    for mod in usbcore usb_common xhci_hcd xhci_pci ehci_hcd ehci_pci uhci_hcd usb_storage uas; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
    
    # SATA/AHCI drivers
    echo "[INIT] Loading SATA/AHCI drivers..."
    for mod in libata ahci ata_piix ata_generic; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
    
    # NVMe drivers
    echo "[INIT] Loading NVMe drivers..."
    for mod in nvme nvme_core; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
    
    # VirtIO drivers (for QEMU/KVM)
    echo "[INIT] Loading VirtIO drivers..."
    for mod in virtio virtio_ring virtio_pci virtio_blk virtio_scsi virtio_net; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
    
    # Filesystem drivers
    echo "[INIT] Loading filesystem drivers..."
    for mod in loop squashfs overlay isofs iso9660 vfat fat ext4 xfs; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
    
    # CD-ROM driver
    echo "[INIT] Loading CD-ROM driver..."
    modprobe cdrom 2>/dev/null && echo "[INIT]   ✓ cdrom" || true
    
    # Video drivers (optional, for display)
    echo "[INIT] Loading video drivers..."
    for mod in drm drm_kms_helper i915 amdgpu nouveau; do
        modprobe $mod 2>/dev/null && echo "[INIT]   ✓ $mod" || true
    done
else
    echo "[INIT] WARNING: No kernel modules available!"
    echo "[INIT] Block devices may not be detected."
fi

# Rescan devices after loading modules
echo "[INIT] Rescanning devices..."
mdev -s 2>/dev/null || true
sleep 1
mdev -s 2>/dev/null || true

echo "[INIT] Module loading complete"

# Parse kernel command line
echo "[INIT] Parsing kernel command line..."
echo "[INIT] cmdline: $(cat /proc/cmdline)"

LIVE_BOOT=""
TORAM=""
SYSTEM_LABEL=""
CONFIG_LABEL="QUANTIX-CFG"
DATA_LABEL="QUANTIX-DATA"
INSTALL_MODE=""
DEBUG_MODE=""
BREAK_POINT=""

for param in $(cat /proc/cmdline); do
    case $param in
        boot=live)
            LIVE_BOOT="1"
            echo "[INIT]   Found: boot=live"
            ;;
        toram)
            TORAM="1"
            echo "[INIT]   Found: toram"
            ;;
        root=LABEL=*)
            SYSTEM_LABEL="${param#root=LABEL=}"
            echo "[INIT]   Found: root=LABEL=$SYSTEM_LABEL"
            ;;
        quantix.config=LABEL=*)
            CONFIG_LABEL="${param#quantix.config=LABEL=}"
            ;;
        quantix.data=LABEL=*)
            DATA_LABEL="${param#quantix.data=LABEL=}"
            ;;
        quantix.install=*)
            INSTALL_MODE="1"
            echo "[INIT]   Found: install mode"
            ;;
        debug)
            DEBUG_MODE="1"
            echo "[INIT]   Found: debug mode"
            ;;
        break=*)
            BREAK_POINT="${param#break=}"
            echo "[INIT]   Found: break=$BREAK_POINT"
            ;;
    esac
done

echo ""
echo "[INIT] Parsed configuration:"
echo "[INIT]   LIVE_BOOT=$LIVE_BOOT"
echo "[INIT]   TORAM=$TORAM"  
echo "[INIT]   DEBUG_MODE=$DEBUG_MODE"
echo "[INIT]   SYSTEM_LABEL=$SYSTEM_LABEL"
echo "[INIT]   BREAK_POINT=$BREAK_POINT"
echo ""

# Debug breakpoint - drop to shell before mounting
if [ "$BREAK_POINT" = "premount" ]; then
    echo ""
    echo "============================================================"
    echo "  DEBUG BREAKPOINT: premount"
    echo "  Dropping to shell for manual debugging."
    echo "  Type 'exit' to continue boot process."
    echo "============================================================"
    echo ""
    echo "Useful commands:"
    echo "  cat /proc/cmdline    - see kernel parameters"
    echo "  ls /dev/             - see available devices"
    echo "  blkid                - see block device labels"
    echo "  ls /                 - see initramfs contents"
    echo "  cat /init            - see this init script"
    echo ""
    /bin/sh
    echo "[INIT] Continuing boot after debug shell..."
fi

# Wait for devices to settle
echo "[INIT] Waiting for devices..."
sleep 3

# Scan for new devices
echo "[INIT] Scanning for block devices..."
for i in 1 2 3; do
    mdev -s 2>/dev/null || true
    sleep 1
done

# =============================================================================
# LIVE BOOT MODE (from ISO/USB)
# =============================================================================
if [ -n "$LIVE_BOOT" ]; then
    echo "[INIT] Live boot mode detected"
    
    # Find the boot media (CD-ROM or USB)
    BOOT_MEDIA=""
    SQUASHFS_PATH=""
    
    # Try CD-ROM devices first
    for dev in /dev/sr0 /dev/sr1 /dev/cdrom; do
        if [ -b "$dev" ]; then
            echo "[INIT] Trying CD-ROM: $dev"
            mkdir -p /mnt/cdrom
            if mount -t iso9660 -o ro "$dev" /mnt/cdrom 2>/dev/null; then
                if [ -f "/mnt/cdrom/quantix/system.squashfs" ]; then
                    BOOT_MEDIA="$dev"
                    SQUASHFS_PATH="/mnt/cdrom/quantix/system.squashfs"
                    echo "[INIT] Found squashfs on CD-ROM: $dev"
                    break
                fi
                umount /mnt/cdrom 2>/dev/null
            fi
        fi
    done
    
    # Try USB/disk devices if CD-ROM not found
    if [ -z "$SQUASHFS_PATH" ]; then
        for dev in /dev/sd[a-z] /dev/sd[a-z][0-9] /dev/nvme[0-9]n[0-9]p[0-9]; do
            if [ -b "$dev" ]; then
                echo "[INIT] Trying device: $dev"
                mkdir -p /mnt/usb
                # Try ISO9660 first (for USB with ISO written via dd)
                if mount -t iso9660 -o ro "$dev" /mnt/usb 2>/dev/null || \
                   mount -t vfat -o ro "$dev" /mnt/usb 2>/dev/null || \
                   mount -t ext4 -o ro "$dev" /mnt/usb 2>/dev/null; then
                    if [ -f "/mnt/usb/quantix/system.squashfs" ]; then
                        BOOT_MEDIA="$dev"
                        SQUASHFS_PATH="/mnt/usb/quantix/system.squashfs"
                        # Remount at /mnt/cdrom for consistency
                        umount /mnt/usb
                        mount -o ro "$dev" /mnt/cdrom 2>/dev/null
                        SQUASHFS_PATH="/mnt/cdrom/quantix/system.squashfs"
                        echo "[INIT] Found squashfs on USB: $dev"
                        break
                    fi
                    umount /mnt/usb 2>/dev/null
                fi
            fi
        done
    fi
    
    if [ -z "$SQUASHFS_PATH" ]; then
        echo "[ERROR] Could not find Quantix-OS boot media!"
        echo "[ERROR] Available block devices:"
        ls -la /dev/sd* /dev/sr* /dev/nvme* 2>/dev/null || echo "  (none found)"
        echo ""
        echo "[ERROR] Trying blkid:"
        blkid 2>/dev/null || echo "  (blkid not available)"
        echo ""
        echo "[ERROR] Dropping to emergency shell..."
        exec /bin/sh
    fi
    
    echo "[INIT] Using squashfs: $SQUASHFS_PATH"
    
    # Cache installer scripts before unmounting boot media (toram mode)
    echo "[INIT] Checking for installer on boot media..."
    echo "[INIT] Contents of /mnt/cdrom:"
    ls -la /mnt/cdrom/ 2>/dev/null || echo "[INIT]   (empty or not mounted)"
    echo "[INIT] Contents of /mnt/cdrom/installer:"
    ls -la /mnt/cdrom/installer/ 2>/dev/null || echo "[INIT]   (not found)"
    
    if [ -n "$INSTALL_MODE" ]; then
        if [ -d "/mnt/cdrom/installer" ]; then
            echo "[INIT] Caching installer scripts for install mode..."
            mkdir -p /mnt/installer-cache
            cp -rv /mnt/cdrom/installer/* /mnt/installer-cache/ 2>&1 || echo "[INIT] WARNING: Copy failed"
            echo "[INIT] Cached installer contents:"
            ls -la /mnt/installer-cache/ 2>/dev/null || echo "[INIT]   (empty)"
        else
            echo "[INIT] WARNING: Install mode but /mnt/cdrom/installer not found!"
        fi
    fi

    # Copy squashfs to RAM if requested
    if [ -n "$TORAM" ]; then
        echo "[INIT] Copying system to RAM (this may take a moment)..."
        mkdir -p /mnt/toram
        mount -t tmpfs -o size=80% tmpfs /mnt/toram
        cp "$SQUASHFS_PATH" /mnt/toram/system.squashfs
        SQUASHFS_PATH="/mnt/toram/system.squashfs"
        # Unmount boot media - no longer needed
        umount /mnt/cdrom 2>/dev/null || true
        echo "[INIT] System loaded to RAM"
    fi
    
    # Mount squashfs
    echo "[INIT] Mounting system image..."
    mkdir -p /mnt/lower
    mount -t squashfs -o ro "$SQUASHFS_PATH" /mnt/lower
    if [ $? -ne 0 ]; then
        echo "[ERROR] Failed to mount squashfs: $SQUASHFS_PATH"
        exec /bin/sh
    fi
    
    # Create tmpfs overlay for writable root
    echo "[INIT] Creating overlay filesystem..."
    mkdir -p /mnt/upper /mnt/work /mnt/merged
    mount -t tmpfs -o size=512M tmpfs /mnt/upper
    mkdir -p /mnt/upper/data /mnt/upper/work
    
    mount -t overlay overlay \
        -o lowerdir=/mnt/lower,upperdir=/mnt/upper/data,workdir=/mnt/upper/work \
        /mnt/merged
    if [ $? -ne 0 ]; then
        echo "[ERROR] Failed to create overlay filesystem"
        exec /bin/sh
    fi
    
    # Create required directories
    mkdir -p /mnt/merged/run
    mkdir -p /mnt/merged/tmp
    mkdir -p /mnt/merged/var/log
    mkdir -p /mnt/merged/mnt/cdrom
    
    # Keep boot media mounted if not using toram
    if [ -z "$TORAM" ] && [ -d "/mnt/cdrom" ]; then
        mount --move /mnt/cdrom /mnt/merged/mnt/cdrom 2>/dev/null || true
    fi
    
    # Check if installer mode
    if [ -n "$INSTALL_MODE" ]; then
        echo "[INIT] Installer mode - will launch installer after boot"
        touch /mnt/merged/tmp/.quantix_install_mode

        # Ensure installer scripts are available after pivot_root
        mkdir -p /mnt/merged/installer
        
        if [ -d "/mnt/installer-cache" ] && [ "$(ls -A /mnt/installer-cache 2>/dev/null)" ]; then
            echo "[INIT] Copying installer from cache to live root..."
            cp -rv /mnt/installer-cache/* /mnt/merged/installer/ 2>&1 || echo "[INIT] WARNING: Copy from cache failed"
        elif [ -d "/mnt/cdrom/installer" ] && [ "$(ls -A /mnt/cdrom/installer 2>/dev/null)" ]; then
            echo "[INIT] Copying installer from boot media to live root..."
            cp -rv /mnt/cdrom/installer/* /mnt/merged/installer/ 2>&1 || echo "[INIT] WARNING: Copy from cdrom failed"
        elif [ -d "/mnt/merged/mnt/cdrom/installer" ] && [ "$(ls -A /mnt/merged/mnt/cdrom/installer 2>/dev/null)" ]; then
            echo "[INIT] Copying installer from moved cdrom mount..."
            cp -rv /mnt/merged/mnt/cdrom/installer/* /mnt/merged/installer/ 2>&1 || echo "[INIT] WARNING: Copy from moved cdrom failed"
        else
            echo "[WARN] Installer directory not found anywhere!"
            echo "[WARN] Checked: /mnt/installer-cache, /mnt/cdrom/installer, /mnt/merged/mnt/cdrom/installer"
        fi
        
        # Make scripts executable
        chmod +x /mnt/merged/installer/*.sh 2>/dev/null || true
        
        echo "[INIT] Final installer contents in live root:"
        ls -la /mnt/merged/installer/ 2>/dev/null || echo "[INIT]   (empty)"
    fi
    
    # Switch to new root
    echo "[INIT] Switching to Quantix-OS Live..."
    echo ""
    
    # Clean up
    umount /proc 2>/dev/null
    umount /sys 2>/dev/null
    umount /dev 2>/dev/null
    
    cd /mnt/merged
    pivot_root . mnt/initramfs 2>/dev/null || {
        # Fallback if pivot_root fails
        exec switch_root /mnt/merged /sbin/init
    }
    
    # Execute init
    exec /sbin/init
    
    # Fallback
    echo "[ERROR] Failed to start init!"
    exec /bin/sh
fi

# =============================================================================
# INSTALLED SYSTEM BOOT MODE
# =============================================================================

# Default to System A if not specified
[ -z "$SYSTEM_LABEL" ] && SYSTEM_LABEL="QUANTIX-A"

echo "[INIT] Installed system boot mode"
echo "[INIT] Boot configuration:"
echo "       System: ${SYSTEM_LABEL}"
echo "       Config: ${CONFIG_LABEL}"
echo "       Data:   ${DATA_LABEL}"

# =============================================================================
# DIAGNOSTIC: Show partition layout and filesystem types
# =============================================================================
echo ""
echo "[DIAG] =============================================="
echo "[DIAG] PARTITION AND FILESYSTEM DIAGNOSTIC"
echo "[DIAG] =============================================="
echo "[DIAG] blkid output (shows all detected filesystems):"
blkid 2>&1 | while read line; do echo "[DIAG]   $line"; done
echo ""
echo "[DIAG] Block devices:"
ls -la /dev/nvme* /dev/sd* /dev/vd* 2>/dev/null | while read line; do echo "[DIAG]   $line"; done
echo ""
echo "[DIAG] Checking for XFS-related kernel messages:"
dmesg 2>/dev/null | grep -i xfs | tail -5 | while read line; do echo "[DIAG]   $line"; done
echo "[DIAG] =============================================="
echo ""

# Find and mount system partition
echo "[INIT] Mounting system partition..."
echo "[INIT] Looking for LABEL=${SYSTEM_LABEL}..."
SYSTEM_DEV=$(findfs LABEL="${SYSTEM_LABEL}" 2>/dev/null)

if [ -z "$SYSTEM_DEV" ]; then
    echo "[ERROR] System partition not found: ${SYSTEM_LABEL}"
    echo "[ERROR] Available partitions:"
    blkid 2>/dev/null || ls -la /dev/sd* /dev/nvme* 2>/dev/null
    echo ""
    echo "[ERROR] Dropping to emergency shell..."
    exec /bin/sh
fi

mkdir -p /mnt/system
mount -t ext4 -o ro "$SYSTEM_DEV" /mnt/system
if [ $? -ne 0 ]; then
    echo "[ERROR] Failed to mount system partition: ${SYSTEM_DEV}"
    exec /bin/sh
fi

# Find squashfs
echo "[INIT] Locating system image..."
SQUASHFS_PATH=""
for path in \
    "/mnt/system/quantix/system.squashfs" \
    "/mnt/system/system.squashfs" \
    "/mnt/system/boot/system.squashfs"; do
    if [ -f "$path" ]; then
        SQUASHFS_PATH="$path"
        break
    fi
done

if [ -z "$SQUASHFS_PATH" ]; then
    # Try to find any squashfs
    SQUASHFS_PATH=$(find /mnt/system -name "system*.squashfs" 2>/dev/null | head -1)
fi

if [ -z "$SQUASHFS_PATH" ] || [ ! -f "$SQUASHFS_PATH" ]; then
    echo "[ERROR] System image not found!"
    echo "[ERROR] Contents of /mnt/system:"
    ls -la /mnt/system/
    exec /bin/sh
fi

echo "[INIT] Found system image: ${SQUASHFS_PATH}"

# Mount squashfs
echo "[INIT] Mounting system image..."
mkdir -p /mnt/lower
mount -t squashfs -o ro "$SQUASHFS_PATH" /mnt/lower
if [ $? -ne 0 ]; then
    echo "[ERROR] Failed to mount squashfs"
    exec /bin/sh
fi

# Create tmpfs for overlay upper layer
echo "[INIT] Creating overlay filesystem..."
mkdir -p /mnt/upper /mnt/work /mnt/merged
mount -t tmpfs -o size=512M tmpfs /mnt/upper
mkdir -p /mnt/upper/data /mnt/upper/work

# Create overlay
mount -t overlay overlay \
    -o lowerdir=/mnt/lower,upperdir=/mnt/upper/data,workdir=/mnt/upper/work \
    /mnt/merged
if [ $? -ne 0 ]; then
    echo "[ERROR] Failed to create overlay filesystem"
    exec /bin/sh
fi

# Mount config partition
echo "[INIT] Mounting config partition..."

# =============================================================================
# SMART CONFIG PARTITION DISCOVERY
# Config partition should be partition 4 on the same disk as system
# =============================================================================

# Determine expected config partition based on system device
case "$SYSTEM_DEV" in
    /dev/nvme*p*)
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/p[0-9]*$//')
        CONFIG_PART="${BASE_DISK}p4"
        ;;
    /dev/sd*|/dev/vd*|/dev/hd*)
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/[0-9]*$//')
        CONFIG_PART="${BASE_DISK}4"
        ;;
    /dev/mmcblk*p*)
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/p[0-9]*$//')
        CONFIG_PART="${BASE_DISK}p4"
        ;;
    *)
        CONFIG_PART=""
        ;;
esac

CONFIG_DEV=""

# Method 1: Use expected partition on same disk
if [ -n "$CONFIG_PART" ] && [ -b "$CONFIG_PART" ]; then
    CFG_LABEL=$(blkid -o value -s LABEL "$CONFIG_PART" 2>/dev/null)
    if [ "$CFG_LABEL" = "QUANTIX-CFG" ]; then
        CONFIG_DEV="$CONFIG_PART"
        echo "[INIT] ✓ Found config partition at expected location: ${CONFIG_DEV}"
    fi
fi

# Method 2: Fallback to findfs
if [ -z "$CONFIG_DEV" ]; then
    CONFIG_DEV=$(findfs LABEL="${CONFIG_LABEL}" 2>/dev/null)
fi

if [ -n "$CONFIG_DEV" ]; then
    echo "[INIT] Config device: ${CONFIG_DEV}"
    mkdir -p /mnt/merged/quantix
    if mount -t ext4 -o noatime "$CONFIG_DEV" /mnt/merged/quantix; then
        echo "[INIT] ✓ Config partition mounted"
    else
        echo "[WARN] Failed to mount config partition"
    fi
else
    echo "[WARN] Config partition not found"
fi

# Mount data partition
echo "[INIT] Mounting data partition..."

# =============================================================================
# SMART PARTITION DISCOVERY
# The data partition should be on the SAME DISK as the system partition
# For Quantix-OS: System=p2, Data=p5 (both on same disk)
# =============================================================================

# Extract the base disk from the system device
# e.g., /dev/nvme0n1p2 -> /dev/nvme0n1
#       /dev/sda2 -> /dev/sda
case "$SYSTEM_DEV" in
    /dev/nvme*p*)
        # NVMe: /dev/nvme0n1p2 -> /dev/nvme0n1
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/p[0-9]*$//')
        DATA_PART="${BASE_DISK}p5"
        ;;
    /dev/sd*|/dev/vd*|/dev/hd*)
        # SATA/VirtIO: /dev/sda2 -> /dev/sda
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/[0-9]*$//')
        DATA_PART="${BASE_DISK}5"
        ;;
    /dev/mmcblk*p*)
        # MMC: /dev/mmcblk0p2 -> /dev/mmcblk0
        BASE_DISK=$(echo "$SYSTEM_DEV" | sed 's/p[0-9]*$//')
        DATA_PART="${BASE_DISK}p5"
        ;;
    *)
        BASE_DISK=""
        DATA_PART=""
        ;;
esac

echo "[INIT] System device: ${SYSTEM_DEV}"
echo "[INIT] Base disk: ${BASE_DISK}"
echo "[INIT] Expected data partition: ${DATA_PART}"

# Try to find data partition in order of preference:
# 1. Partition 5 on the same disk (most reliable)
# 2. Partition with label QUANTIX-DATA AND type XFS on same disk
# 3. Any partition with label QUANTIX-DATA

DATA_DEV=""

# Method 1: Use expected partition number on same disk
if [ -n "$DATA_PART" ] && [ -b "$DATA_PART" ]; then
    DATA_DEV_LABEL=$(blkid -o value -s LABEL "$DATA_PART" 2>/dev/null)
    DATA_DEV_TYPE=$(blkid -o value -s TYPE "$DATA_PART" 2>/dev/null)
    echo "[INIT] Partition 5 check: LABEL='${DATA_DEV_LABEL}' TYPE='${DATA_DEV_TYPE}'"
    
    if [ "$DATA_DEV_LABEL" = "QUANTIX-DATA" ]; then
        DATA_DEV="$DATA_PART"
        echo "[INIT] ✓ Found data partition at expected location: ${DATA_DEV}"
    else
        echo "[INIT] Partition 5 exists but has wrong label (expected QUANTIX-DATA, got '${DATA_DEV_LABEL}')"
    fi
fi

# Method 2: Search all partitions on same disk for correct label AND XFS type
if [ -z "$DATA_DEV" ] && [ -n "$BASE_DISK" ]; then
    echo "[INIT] Searching ${BASE_DISK}* for QUANTIX-DATA with XFS..."
    for part in ${BASE_DISK}p* ${BASE_DISK}[0-9]*; do
        [ -b "$part" ] || continue
        PART_LABEL=$(blkid -o value -s LABEL "$part" 2>/dev/null)
        PART_TYPE=$(blkid -o value -s TYPE "$part" 2>/dev/null)
        if [ "$PART_LABEL" = "QUANTIX-DATA" ] && [ "$PART_TYPE" = "xfs" ]; then
            DATA_DEV="$part"
            echo "[INIT] ✓ Found XFS data partition: ${DATA_DEV}"
            break
        fi
    done
fi

# Method 3: Fallback to findfs (may find wrong partition on multi-disk systems)
if [ -z "$DATA_DEV" ]; then
    echo "[INIT] Falling back to findfs LABEL=${DATA_LABEL}..."
    DATA_DEV=$(findfs LABEL="${DATA_LABEL}" 2>/dev/null)
    if [ -n "$DATA_DEV" ]; then
        echo "[INIT] findfs returned: ${DATA_DEV}"
        echo "[WARN] This may be from a different disk/installation!"
    fi
fi

echo "[INIT] Final data device: DATA_DEV='${DATA_DEV}'"

if [ -n "$DATA_DEV" ]; then
    # Show what we're about to mount
    echo "[INIT] Data device details:"
    blkid "$DATA_DEV" 2>&1 | while read line; do echo "[INIT]   $line"; done
    
    # Check filesystem type before mounting
    DATA_FSTYPE=$(blkid -o value -s TYPE "$DATA_DEV" 2>/dev/null)
    echo "[INIT] Detected filesystem type: ${DATA_FSTYPE}"
    
    mkdir -p /mnt/merged/data
    
    # Mount with detected filesystem type
    if [ "$DATA_FSTYPE" = "xfs" ]; then
        echo "[INIT] Mounting ${DATA_DEV} as XFS..."
        if mount -t xfs -o noatime "$DATA_DEV" /mnt/merged/data; then
            echo "[INIT] ✓ Data partition mounted successfully as XFS"
        else
            echo "[WARN] ✗ Failed to mount data partition as XFS"
        fi
    elif [ "$DATA_FSTYPE" = "ext4" ]; then
        echo "[INIT] Mounting ${DATA_DEV} as ext4..."
        if mount -t ext4 -o noatime "$DATA_DEV" /mnt/merged/data; then
            echo "[INIT] ✓ Data partition mounted successfully as ext4"
        else
            echo "[WARN] ✗ Failed to mount data partition as ext4"
        fi
    else
        echo "[WARN] Unknown or missing filesystem type: ${DATA_FSTYPE}"
        # Try common types
        if mount -t xfs -o noatime "$DATA_DEV" /mnt/merged/data 2>/dev/null; then
            echo "[INIT] ✓ Mounted as XFS"
        elif mount -t ext4 -o noatime "$DATA_DEV" /mnt/merged/data 2>/dev/null; then
            echo "[INIT] ✓ Mounted as ext4"
        else
            echo "[WARN] ✗ Failed to mount data partition"
        fi
    fi
else
    echo "[WARN] Data partition not found!"
    echo "[WARN] Available partitions:"
    blkid 2>&1 | while read line; do echo "[WARN]   $line"; done
fi

# Move system mount for later access
echo "[INIT] Preparing for root switch..."
mkdir -p /mnt/merged/mnt/system
mount --move /mnt/system /mnt/merged/mnt/system 2>/dev/null || true

# Create required directories
mkdir -p /mnt/merged/run
mkdir -p /mnt/merged/tmp
mkdir -p /mnt/merged/var/log

# Clean up
umount /proc 2>/dev/null
umount /sys 2>/dev/null
umount /dev 2>/dev/null

# Switch to new root
echo "[INIT] Switching to Quantix-OS..."
echo ""

cd /mnt/merged
pivot_root . mnt/initramfs 2>/dev/null || {
    exec switch_root /mnt/merged /sbin/init
}

# Execute init
exec /sbin/init

# Fallback
echo "[ERROR] Failed to start init!"
exec /bin/sh
