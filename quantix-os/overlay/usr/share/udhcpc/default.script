#!/bin/sh
# =============================================================================
# Quantix-OS udhcpc Default Script
# =============================================================================
# This script is called by udhcpc when DHCP events occur.
# It configures the network interface and DNS settings.
#
# udhcpc provides these environment variables:
#   $interface - network interface name
#   $ip        - IP address obtained
#   $subnet    - subnet mask (e.g., 255.255.255.0)
#   $router    - default gateway(s)
#   $dns       - DNS server(s)
#   $domain    - domain name
#   $lease     - lease time in seconds
# =============================================================================

# Logging function
log() {
    logger -t "udhcpc[$interface]" "$1"
}

# Convert subnet mask to CIDR prefix length
# e.g., 255.255.255.0 -> 24
mask_to_cidr() {
    local mask="$1"
    local cidr=0
    local octet
    
    # Handle common masks directly for speed
    case "$mask" in
        255.255.255.255) echo 32; return ;;
        255.255.255.254) echo 31; return ;;
        255.255.255.252) echo 30; return ;;
        255.255.255.248) echo 29; return ;;
        255.255.255.240) echo 28; return ;;
        255.255.255.224) echo 27; return ;;
        255.255.255.192) echo 26; return ;;
        255.255.255.128) echo 25; return ;;
        255.255.255.0)   echo 24; return ;;
        255.255.254.0)   echo 23; return ;;
        255.255.252.0)   echo 22; return ;;
        255.255.248.0)   echo 21; return ;;
        255.255.240.0)   echo 20; return ;;
        255.255.224.0)   echo 19; return ;;
        255.255.192.0)   echo 18; return ;;
        255.255.128.0)   echo 17; return ;;
        255.255.0.0)     echo 16; return ;;
        255.0.0.0)       echo 8; return ;;
        0.0.0.0)         echo 0; return ;;
    esac
    
    # Fallback: count bits (slower but handles any mask)
    for octet in $(echo "$mask" | tr '.' ' '); do
        case "$octet" in
            255) cidr=$((cidr + 8)) ;;
            254) cidr=$((cidr + 7)) ;;
            252) cidr=$((cidr + 6)) ;;
            248) cidr=$((cidr + 5)) ;;
            240) cidr=$((cidr + 4)) ;;
            224) cidr=$((cidr + 3)) ;;
            192) cidr=$((cidr + 2)) ;;
            128) cidr=$((cidr + 1)) ;;
            0)   ;;
        esac
    done
    echo "$cidr"
}

# Setup interface with obtained IP
setup_interface() {
    # Convert subnet mask to CIDR
    local prefix
    if [ -n "$subnet" ]; then
        prefix=$(mask_to_cidr "$subnet")
    else
        # Default to /24 if no subnet provided
        prefix=24
    fi
    
    log "Configuring $interface with IP $ip/$prefix (mask: $subnet)"
    
    # Remove any existing IP on this interface
    ip addr flush dev "$interface" 2>/dev/null
    
    # Add the new IP
    ip addr add "$ip/$prefix" dev "$interface"
    
    # Bring interface up
    ip link set "$interface" up
    
    # Add default route if gateway provided
    if [ -n "$router" ]; then
        log "Setting default gateway: $router"
        # Remove existing default routes via this interface
        ip route del default dev "$interface" 2>/dev/null
        # Add new default route
        for gw in $router; do
            ip route add default via "$gw" dev "$interface" metric 100
            break  # Only use first gateway
        done
    fi
}

# Configure DNS
setup_dns() {
    # Create resolv.conf
    log "Configuring DNS servers"
    
    # Start with search domain if provided
    {
        if [ -n "$domain" ]; then
            echo "search $domain"
        fi
        
        # Add DNS servers
        if [ -n "$dns" ]; then
            for ns in $dns; do
                echo "nameserver $ns"
            done
        else
            # Fallback DNS servers if none provided
            log "No DNS servers from DHCP, using fallback"
            echo "nameserver 8.8.8.8"
            echo "nameserver 1.1.1.1"
        fi
    } > /etc/resolv.conf
    
    chmod 644 /etc/resolv.conf
    log "DNS configuration complete"
}

# Deconfig interface (called when lease lost)
deconfig_interface() {
    log "Deconfiguring $interface"
    ip addr flush dev "$interface" 2>/dev/null
    ip link set "$interface" up
}

# Main handler
case "$1" in
    deconfig)
        deconfig_interface
        ;;
    
    bound|renew)
        setup_interface
        setup_dns
        
        # Log success
        log "DHCP $1: $ip (subnet: $subnet) via $router (lease: ${lease}s)"
        ;;
    
    leasefail|nak)
        log "DHCP failed: $1"
        
        # Ensure we have at least fallback DNS
        if [ ! -f /etc/resolv.conf ]; then
            log "Creating fallback resolv.conf"
            {
                echo "# Fallback DNS (DHCP failed)"
                echo "nameserver 8.8.8.8"
                echo "nameserver 1.1.1.1"
            } > /etc/resolv.conf
            chmod 644 /etc/resolv.conf
        fi
        ;;
    
    *)
        log "Unknown action: $1"
        ;;
esac

exit 0
