#!/bin/sh
# ============================================================================
# Quantix Console Launcher
# ============================================================================
# Intelligently detects available graphics capabilities and launches the
# appropriate console interface.
#
# Rendering backend priority:
# 1. Slint LinuxKMS with GPU (femtovg) - requires DRM card with GPU
# 2. Slint LinuxKMS with software renderer - requires DRM card, no GPU needed
# 3. Raw framebuffer (embedded-graphics) - requires /dev/fb0, bypasses DRM
# 4. TUI fallback (ratatui) - works on any terminal, no framebuffer needed
# ============================================================================

# IMPORTANT: Remove set -e to prevent silent exits on errors
# set -e

# Function to print to both log and screen (visible during boot)
boot_msg() {
    echo "[QUANTIX] $1"
    echo "$(date '+%Y-%m-%dT%H:%M:%S') $1" >> /tmp/console-launcher.log 2>/dev/null || true
}

# Trap errors to show them on screen
trap 'boot_msg "ERROR: Script failed at line $LINENO"' ERR

boot_msg "=== Console Launcher Starting ==="

# Setup environment
export XDG_RUNTIME_DIR="/run/user/0"
export HOME="/root"

# Ensure runtime directories exist (these are on tmpfs, so writable)
mkdir -p /run/user/0 2>/dev/null || true
chmod 700 /run/user/0 2>/dev/null || true

# Create log directory in /run (tmpfs, writable)
mkdir -p /run/quantix 2>/dev/null || true
chmod 755 /run/quantix 2>/dev/null || true

# ============================================================================
# Setup Input Devices
# ============================================================================
boot_msg "Setting up input devices..."

# Load input drivers
modprobe evdev 2>/dev/null || true
modprobe uinput 2>/dev/null || true
modprobe psmouse 2>/dev/null || true      # PS/2 mouse
modprobe vmmouse 2>/dev/null || true      # VMware mouse driver
modprobe mousedev 2>/dev/null || true     # Mouse device support
modprobe hid-generic 2>/dev/null || true  # Generic HID

# Ensure input devices have correct permissions
chmod 666 /dev/input/event* 2>/dev/null || true
chmod 666 /dev/input/mice 2>/dev/null || true
chmod 666 /dev/input/mouse* 2>/dev/null || true

# Ensure seatd is running (required for Slint LinuxKMS input)
if ! pgrep -x seatd >/dev/null 2>&1; then
    boot_msg "Starting seatd for input device access..."
    # Try to start seatd service
    rc-service seatd start 2>/dev/null || /usr/sbin/seatd -g video 2>/dev/null &
    sleep 1
fi

# Add root to seat/video groups for input access
addgroup root video 2>/dev/null || true
addgroup root input 2>/dev/null || true
addgroup root seat 2>/dev/null || true

LOG_FILE="/run/quantix/console-launcher.log"

# Logging function
log() {
    echo "$(date '+%Y-%m-%dT%H:%M:%S') $1" >> "$LOG_FILE" 2>/dev/null || true
    echo "[QUANTIX] $1"
}

log_debug() {
    echo "$(date '+%Y-%m-%dT%H:%M:%S') [DEBUG] $1" >> "$LOG_FILE" 2>/dev/null || true
}

# ============================================================================
# Graphics Detection Functions
# ============================================================================

# Check if DRM/KMS is available (required for Slint LinuxKMS backend)
has_drm() {
    # Check for any DRM card devices
    if [ -d /sys/class/drm ]; then
        for card in /sys/class/drm/card*; do
            if [ -d "$card" ] && [ "$(basename "$card")" != "card*" ]; then
                log_debug "Found DRM card: $card"
                return 0
            fi
        done
    fi
    return 1
}

# Check if GPU rendering is likely to work (has a render node)
has_gpu_render() {
    # Check for render nodes (indicates GPU acceleration available)
    for render in /dev/dri/renderD*; do
        if [ -c "$render" ]; then
            log_debug "Found render node: $render"
            return 0
        fi
    done
    return 1
}

# Check if legacy framebuffer is available
has_framebuffer() {
    for fb in /dev/fb0 /dev/fb1 /dev/fb2; do
        if [ -c "$fb" ]; then
            log_debug "Found framebuffer: $fb"
            return 0
        fi
    done
    return 1
}

# Wait for graphics devices to appear (udev may still be processing)
wait_for_graphics() {
    local max_wait=5
    local waited=0
    
    log_debug "Waiting for graphics devices..."
    
    while [ $waited -lt $max_wait ]; do
        if has_drm || has_framebuffer; then
            log_debug "Graphics device found after ${waited}s"
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done
    
    log_debug "No graphics devices found after ${max_wait}s"
    return 1
}

# Try to load graphics modules if not already loaded
try_load_graphics_modules() {
    log_debug "Attempting to load graphics modules..."
    boot_msg "Loading graphics modules..."
    
    # Try to load virtual GPU drivers first (most common in VMs)
    # vmwgfx = VMware, virtio_gpu = KVM/QEMU, bochs/cirrus = legacy QEMU
    for mod in vmwgfx virtio_gpu simpledrm bochs cirrus vboxvideo; do
        if modprobe "$mod" 2>/dev/null; then
            log_debug "Loaded module: $mod"
            boot_msg "  Loaded: $mod"
        fi
    done
    
    # Try framebuffer drivers (creates /dev/fb0)
    for mod in vesafb efifb simplefb vga16fb; do
        if modprobe "$mod" 2>/dev/null; then
            log_debug "Loaded module: $mod"
        fi
    done
    
    # Give udev a moment to create devices
    sleep 1
}

# ============================================================================
# Console Launch Functions
# ============================================================================

# Try running GUI with a specific backend
try_gui() {
    local backend="$1"
    local backend_name="$2"
    
    export SLINT_BACKEND="$backend"
    log "Starting Quantix-OS Graphical Console (Slint)"
    log_debug "Backend: $backend_name ($backend)"
    
    /usr/bin/qx-console-gui </dev/tty1 >/dev/tty1 2>/run/quantix/console-gui.err
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        log_debug "GUI exited normally"
        exit 0
    fi
    
    log_debug "GUI failed with exit code: $exit_code"
    if [ -s /run/quantix/console-gui.err ]; then
        log_debug "Error output:"
        cat /run/quantix/console-gui.err >> "$LOG_FILE"
    fi
    
    return $exit_code
}

# Try raw framebuffer mode
try_framebuffer() {
    log "Starting Quantix-OS Framebuffer Console"
    log_debug "Using embedded-graphics framebuffer renderer"
    
    SLINT_BACKEND="" /usr/bin/qx-console-gui --framebuffer </dev/tty1 >/dev/tty1 2>/run/quantix/console-gui.err
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        log_debug "Framebuffer console exited normally"
        exit 0
    fi
    
    log_debug "Framebuffer console failed with exit code: $exit_code"
    return $exit_code
}

# Launch TUI console
launch_tui() {
    log "Starting Quantix-OS Console (TUI)"
    boot_msg "Launching TUI console..."
    
    # Run TUI and capture any errors
    /usr/local/bin/qx-console </dev/tty1 >/dev/tty1 2>/run/quantix/console-tui.err
    local exit_code=$?
    
    if [ $exit_code -ne 0 ]; then
        boot_msg "TUI console exited with code: $exit_code"
        if [ -s /run/quantix/console-tui.err ]; then
            boot_msg "TUI error:"
            cat /run/quantix/console-tui.err
        fi
        # Don't exit - let the fallback shell run
        return $exit_code
    fi
    
    exit 0
}

# ============================================================================
# Main Logic
# ============================================================================

main() {
    boot_msg "Console launcher main() starting..."
    log_debug "=== Console Launcher Starting ==="
    log_debug "Date: $(date)"
    
    # Diagnostic: Show what binaries exist
    boot_msg "Checking console binaries..."
    if [ -x /usr/bin/qx-console-gui ]; then
        boot_msg "  - qx-console-gui: FOUND"
    else
        boot_msg "  - qx-console-gui: NOT FOUND"
    fi
    if [ -x /usr/local/bin/qx-console ]; then
        boot_msg "  - qx-console (TUI): FOUND"
    else
        boot_msg "  - qx-console (TUI): NOT FOUND"
    fi
    
    # Try to ensure graphics modules are loaded
    boot_msg "Loading graphics modules..."
    try_load_graphics_modules
    
    # Wait briefly for graphics devices
    boot_msg "Waiting for graphics devices..."
    wait_for_graphics
    
    # Detect available graphics
    local has_drm_available=false
    local has_gpu_available=false
    local has_fb_available=false
    
    if has_drm; then
        has_drm_available=true
        log_debug "DRM/KMS is available"
    fi
    
    if has_gpu_render; then
        has_gpu_available=true
        log_debug "GPU rendering is available"
    fi
    
    if has_framebuffer; then
        has_fb_available=true
        log_debug "Framebuffer is available"
    fi
    
    boot_msg "Graphics: DRM=$has_drm_available GPU=$has_gpu_available FB=$has_fb_available"
    log_debug "Graphics summary: DRM=$has_drm_available GPU=$has_gpu_available FB=$has_fb_available"
    
    # Try GUI console if available
    if [ -x /usr/bin/qx-console-gui ]; then
        
        # Strategy 1: If DRM is available, try Slint backends
        if [ "$has_drm_available" = "true" ]; then
            
            # Try GPU-accelerated rendering first if GPU is available
            if [ "$has_gpu_available" = "true" ]; then
                boot_msg "Trying LinuxKMS with GPU..."
                log_debug "Trying LinuxKMS with GPU acceleration"
                try_gui "linuxkms" "GPU" || true
            fi
            
            # Try software rendering (still uses DRM for display)
            boot_msg "Trying LinuxKMS software..."
            log_debug "Trying LinuxKMS with software renderer"
            try_gui "linuxkms-software" "Software" || true
        fi
        
        # Strategy 2: Try raw framebuffer if available
        if [ "$has_fb_available" = "true" ]; then
            boot_msg "Trying raw framebuffer..."
            log_debug "Trying raw framebuffer mode"
            try_framebuffer || true
        fi
        
        # All GUI backends failed
        boot_msg "GUI console failed, falling back to TUI..."
        log "GUI console failed, falling back to TUI..."
        if [ -s /run/quantix/console-gui.err ]; then
            boot_msg "Error details:"
            head -3 /run/quantix/console-gui.err 2>/dev/null || true
        fi
        sleep 2
        
    else
        boot_msg "GUI console binary not found, using TUI"
        log_debug "GUI console binary not found, using TUI"
    fi
    
    # Fallback to TUI console
    if [ -x /usr/local/bin/qx-console ]; then
        boot_msg "Starting TUI console..."
        launch_tui
        # If we get here, TUI failed
        boot_msg "TUI console failed"
    else
        boot_msg "TUI binary not found at /usr/local/bin/qx-console"
    fi
    
    # Ultimate fallback: simple shell with banner
    boot_msg "============================================"
    boot_msg "  QUANTIX-OS EMERGENCY SHELL"
    boot_msg "  Graphics: DRM=$has_drm_available FB=$has_fb_available"
    boot_msg "  Console binaries failed to start"
    boot_msg "  Check /run/quantix/*.err for errors"
    boot_msg "============================================"
    log "Dropping to emergency shell..."
    
    # Clear screen and show a proper prompt
    clear 2>/dev/null || true
    echo ""
    echo "=========================================="
    echo "  QUANTIX-OS EMERGENCY SHELL"
    echo "=========================================="
    echo ""
    echo "The graphical/TUI console failed to start."
    echo ""
    echo "Diagnostics:"
    echo "  - DRM available: $has_drm_available"
    echo "  - Framebuffer available: $has_fb_available"
    echo ""
    echo "Check logs with:"
    echo "  cat /run/quantix/console-launcher.log"
    echo "  cat /run/quantix/console-gui.err"
    echo "  cat /run/quantix/console-tui.err"
    echo ""
    echo "To retry TUI: /usr/local/bin/qx-console"
    echo ""
    
    exec /bin/sh
}

boot_msg "About to call main()..."
main "$@"
boot_msg "main() returned unexpectedly"
