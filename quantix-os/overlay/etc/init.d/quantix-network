#!/sbin/openrc-run
# =============================================================================
# Quantix-OS Network Auto-Configuration Service
# =============================================================================
# Configures network interfaces via DHCP or static IP.
# Supports Ethernet and WiFi (if wpa_supplicant is configured).
# 
# Static IP Configuration:
#   - Per-interface: /etc/quantix/network/<interface>.conf
#   - Global static: /etc/quantix/network/static.conf (applies to active interface)
#
# Config file format:
#   IP_ADDRESS=192.168.1.100
#   NETMASK=255.255.255.0
#   GATEWAY=192.168.1.1
#   DNS=8.8.8.8
# =============================================================================

name="Quantix Network"
description="Auto-configure network interfaces (DHCP or static)"

# PID directory for tracking DHCP clients
DHCP_PID_DIR="/run/quantix-dhcp"

# Static IP configuration directory (volatile - in overlay)
STATIC_CONFIG_DIR="/etc/quantix/network"

# Persistent config directory (survives reboots - on QUANTIX-CFG partition)
PERSISTENT_CONFIG_DIR="/quantix/network"

depend() {
    need localmount
    before quantix-node
    provide net
    keyword -jail -prefix -vserver -docker -lxc -systemd-nspawn
}

# Check if interface already has a valid IP
has_valid_ip() {
    local iface="$1"
    ip -4 addr show dev "$iface" scope global 2>/dev/null | grep -q "inet "
}

# Get current IP of interface
get_interface_ip() {
    local iface="$1"
    ip -4 addr show dev "$iface" scope global 2>/dev/null | grep "inet " | head -1 | awk '{print $2}' | cut -d/ -f1
}

# Check if interface has static IP configuration
has_static_config() {
    local iface="$1"
    # Check for interface-specific config
    [ -f "$STATIC_CONFIG_DIR/$iface.conf" ] && return 0
    return 1
}

# Check if global static config exists (for any active interface)
has_global_static_config() {
    [ -f "$STATIC_CONFIG_DIR/static.conf" ] && return 0
    return 1
}

# Convert netmask to CIDR prefix
netmask_to_cidr() {
    local netmask="$1"
    local bits=0
    for octet in $(echo "$netmask" | tr '.' ' '); do
        case "$octet" in
            255) bits=$((bits + 8)) ;;
            254) bits=$((bits + 7)) ;;
            252) bits=$((bits + 6)) ;;
            248) bits=$((bits + 5)) ;;
            240) bits=$((bits + 4)) ;;
            224) bits=$((bits + 3)) ;;
            192) bits=$((bits + 2)) ;;
            128) bits=$((bits + 1)) ;;
            0) ;;
            *) bits=$((bits + 8)) ;;  # Default for invalid
        esac
    done
    echo "$bits"
}

# Apply static IP configuration to interface
apply_static_ip() {
    local iface="$1"
    local config_file="$2"
    
    # Read configuration
    local IP_ADDRESS="" NETMASK="" GATEWAY="" DNS=""
    . "$config_file"
    
    if [ -z "$IP_ADDRESS" ]; then
        ewarn "No IP_ADDRESS in $config_file"
        return 1
    fi
    
    # Default netmask if not specified
    [ -z "$NETMASK" ] && NETMASK="255.255.255.0"
    
    # Calculate CIDR
    local cidr=$(netmask_to_cidr "$NETMASK")
    
    einfo "Applying static IP to $iface: $IP_ADDRESS/$cidr"
    
    # Kill any DHCP client on this interface (aggressive)
    # Method 1: Kill by PID file
    if [ -f "$DHCP_PID_DIR/udhcpc_$iface.pid" ]; then
        local dhcp_pid=$(cat "$DHCP_PID_DIR/udhcpc_$iface.pid" 2>/dev/null)
        if [ -n "$dhcp_pid" ] && kill -0 "$dhcp_pid" 2>/dev/null; then
            kill "$dhcp_pid" 2>/dev/null
        fi
        rm -f "$DHCP_PID_DIR/udhcpc_$iface.pid"
    fi
    
    # Method 2: Kill by process name matching interface
    pkill -f "udhcpc.*-i.*$iface" 2>/dev/null || true
    pkill -f "dhclient.*$iface" 2>/dev/null || true
    
    # Method 3: Kill ALL udhcpc processes (nuclear option for static IP)
    killall udhcpc 2>/dev/null || true
    
    sleep 1
    
    # Flush existing IP
    ip addr flush dev "$iface" 2>/dev/null
    
    # Bring interface up
    ip link set "$iface" up
    
    # Add IP address
    if ! ip addr add "$IP_ADDRESS/$cidr" dev "$iface" 2>/dev/null; then
        ewarn "Failed to add IP $IP_ADDRESS/$cidr to $iface"
        return 1
    fi
    
    # Set default gateway
    if [ -n "$GATEWAY" ]; then
        ip route del default 2>/dev/null
        ip route add default via "$GATEWAY" dev "$iface" 2>/dev/null
    fi
    
    # Set DNS
    if [ -n "$DNS" ]; then
        echo "# Static DNS configuration for $iface" > /etc/resolv.conf
        for dns_server in $(echo "$DNS" | tr ',' ' '); do
            echo "nameserver $dns_server" >> /etc/resolv.conf
        done
    fi
    
    einfo "Static IP configured: $IP_ADDRESS (gateway: ${GATEWAY:-none})"
    return 0
}

start() {
    ebegin "Starting $name"
    
    # Create directories
    mkdir -p "$DHCP_PID_DIR"
    mkdir -p "$STATIC_CONFIG_DIR"
    
    # Restore persistent config if available
    # The /quantix partition is the persistent QUANTIX-CFG partition
    if [ -d "$PERSISTENT_CONFIG_DIR" ]; then
        for conf in "$PERSISTENT_CONFIG_DIR"/*.conf; do
            [ -f "$conf" ] || continue
            local name=$(basename "$conf")
            if [ ! -f "$STATIC_CONFIG_DIR/$name" ]; then
                einfo "Restoring persistent config: $name"
                cp "$conf" "$STATIC_CONFIG_DIR/$name"
            fi
        done
    fi
    
    # Ensure fallback resolv.conf exists
    if [ ! -f /etc/resolv.conf ]; then
        einfo "Creating fallback DNS configuration"
        cat > /etc/resolv.conf << 'EOF'
# Quantix-OS fallback DNS
nameserver 8.8.8.8
nameserver 1.1.1.1
EOF
        chmod 644 /etc/resolv.conf
    fi
    
    # Bring up loopback
    ip link set lo up 2>/dev/null
    
    # Track configured interfaces
    local configured_count=0
    local skipped_count=0
    local static_count=0
    local global_static_applied=0
    
    # Check for global static config (applies to first active interface)
    local global_static_config=""
    if has_global_static_config; then
        global_static_config="$STATIC_CONFIG_DIR/static.conf"
        einfo "Found global static IP configuration"
    fi
    
    # Find and configure all physical interfaces
    for iface_path in /sys/class/net/*; do
        local iface=$(basename "$iface_path")
        
        # Skip loopback and virtual interfaces
        case "$iface" in
            lo|bond*|br*|veth*|docker*|virbr*|ovs*|vnet*|tap*)
                continue
                ;;
        esac
        
        # Check if it's a physical interface
        if [ ! -d "/sys/class/net/$iface/device" ]; then
            continue
        fi
        
        # CRITICAL: Check for static config FIRST, BEFORE checking existing IP
        # Static config takes priority over any existing DHCP configuration
        # This ensures static IP persists across reboots even if DHCP runs first
        if has_static_config "$iface"; then
            einfo "Found static config for $iface (takes priority)"
            # Bring up the interface first
            ip link set "$iface" up
            if apply_static_ip "$iface" "$STATIC_CONFIG_DIR/$iface.conf"; then
                static_count=$((static_count + 1))
                continue
            else
                ewarn "Static config failed for $iface, falling back to DHCP"
            fi
        fi
        
        # Check for global static config (apply to first physical interface)
        if [ -n "$global_static_config" ] && [ "$global_static_applied" -eq 0 ]; then
            einfo "Applying global static config to $iface (takes priority)"
            ip link set "$iface" up
            if apply_static_ip "$iface" "$global_static_config"; then
                static_count=$((static_count + 1))
                global_static_applied=1
                continue
            else
                ewarn "Global static config failed for $iface, falling back to DHCP"
            fi
        fi
        
        # Check if interface already has an IP (skip DHCP if so)
        if has_valid_ip "$iface"; then
            local current_ip=$(get_interface_ip "$iface")
            einfo "Interface $iface already configured: $current_ip (skipping)"
            skipped_count=$((skipped_count + 1))
            continue
        fi
        
        einfo "Configuring interface: $iface"
        
        # Bring up the interface
        ip link set "$iface" up
        
        # Check if it's a wireless interface
        local is_wifi=0
        if [ -d "/sys/class/net/$iface/wireless" ]; then
            is_wifi=1
            # WiFi interface - check for wpa_supplicant config
            if [ -f "/etc/wpa_supplicant/wpa_supplicant.conf" ] && command -v wpa_supplicant >/dev/null 2>&1; then
                einfo "Starting WiFi on $iface"
                wpa_supplicant -B -i "$iface" -c /etc/wpa_supplicant/wpa_supplicant.conf \
                    -P "$DHCP_PID_DIR/wpa_$iface.pid" 2>/dev/null
                sleep 3  # Wait for WiFi association
            else
                ewarn "WiFi interface $iface found but no wpa_supplicant config"
                continue
            fi
        fi
        
        # Kill any existing udhcpc for this interface
        if [ -f "$DHCP_PID_DIR/udhcpc_$iface.pid" ]; then
            local old_pid=$(cat "$DHCP_PID_DIR/udhcpc_$iface.pid" 2>/dev/null)
            if [ -n "$old_pid" ] && kill -0 "$old_pid" 2>/dev/null; then
                kill "$old_pid" 2>/dev/null
                sleep 0.5
            fi
            rm -f "$DHCP_PID_DIR/udhcpc_$iface.pid"
        fi
        
        # Run DHCP with proper options
        if command -v udhcpc >/dev/null 2>&1; then
            einfo "Running DHCP on $iface"
            udhcpc -i "$iface" \
                -t 4 \
                -T 3 \
                -A 10 \
                -p "$DHCP_PID_DIR/udhcpc_$iface.pid" \
                -S \
                -b 2>/dev/null &
            
            configured_count=$((configured_count + 1))
        elif command -v dhclient >/dev/null 2>&1; then
            dhclient -1 -pf "$DHCP_PID_DIR/dhclient_$iface.pid" "$iface" 2>/dev/null &
            configured_count=$((configured_count + 1))
        else
            ewarn "No DHCP client available"
        fi
    done
    
    # Wait for network to be ready (max 10 seconds)
    local wait_count=0
    while [ $wait_count -lt 10 ]; do
        for iface_path in /sys/class/net/*; do
            local iface=$(basename "$iface_path")
            case "$iface" in
                lo|bond*|br*|veth*|docker*|virbr*|ovs*|vnet*|tap*)
                    continue
                    ;;
            esac
            if [ -d "/sys/class/net/$iface/device" ] && has_valid_ip "$iface"; then
                einfo "Network ready on $iface: $(get_interface_ip $iface)"
                break 2
            fi
        done
        sleep 1
        wait_count=$((wait_count + 1))
    done
    
    # Log the result
    einfo "Network configuration complete:"
    einfo "  Static IP: $static_count interfaces"
    einfo "  DHCP: $configured_count interfaces"
    einfo "  Skipped: $skipped_count interfaces (already configured)"
    
    # Show IP addresses
    ip -4 addr show scope global 2>/dev/null | grep -E "inet |^[0-9]" | head -10 | while read line; do
        einfo "  $line"
    done
    
    eend 0
}

stop() {
    ebegin "Stopping $name"
    
    # Kill all tracked DHCP clients
    if [ -d "$DHCP_PID_DIR" ]; then
        for pidfile in "$DHCP_PID_DIR"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid=$(cat "$pidfile" 2>/dev/null)
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
            fi
            rm -f "$pidfile"
        done
    fi
    
    # Also kill any orphaned udhcpc processes
    killall udhcpc 2>/dev/null || true
    killall dhclient 2>/dev/null || true
    killall wpa_supplicant 2>/dev/null || true
    
    eend 0
}

status() {
    einfo "Network interfaces:"
    ip -4 addr show scope global 2>/dev/null
    
    einfo ""
    einfo "Default route:"
    ip route show default 2>/dev/null
    
    einfo ""
    einfo "DNS configuration:"
    cat /etc/resolv.conf 2>/dev/null || einfo "  (no resolv.conf)"
    
    einfo ""
    einfo "Static IP configurations:"
    if [ -d "$STATIC_CONFIG_DIR" ]; then
        for conf in "$STATIC_CONFIG_DIR"/*.conf; do
            [ -f "$conf" ] || continue
            local name=$(basename "$conf" .conf)
            local ip=$(grep "^IP_ADDRESS=" "$conf" 2>/dev/null | cut -d= -f2)
            # Check if also saved persistently
            local persist=""
            if [ -f "$PERSISTENT_CONFIG_DIR/$name.conf" ]; then
                persist=" (persistent)"
            else
                persist=" (session only)"
            fi
            einfo "  $name: $ip$persist"
        done
    else
        einfo "  (none configured)"
    fi
    
    einfo ""
    einfo "Persistent storage:"
    if [ -d "/quantix" ]; then
        einfo "  /quantix: mounted (config survives reboot)"
    else
        einfo "  /quantix: NOT mounted (config lost on reboot)"
    fi
    
    einfo ""
    einfo "DHCP clients:"
    if [ -d "$DHCP_PID_DIR" ]; then
        for pidfile in "$DHCP_PID_DIR"/udhcpc_*.pid; do
            [ -f "$pidfile" ] || continue
            local iface=$(basename "$pidfile" | sed 's/udhcpc_//;s/\.pid//')
            local pid=$(cat "$pidfile" 2>/dev/null)
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                einfo "  $iface: running (PID $pid)"
            else
                einfo "  $iface: not running"
            fi
        done
    else
        einfo "  (no tracked clients)"
    fi
    
    return 0
}

# Helper: Set static IP for an interface
# Usage: rc-service quantix-network set-static <interface> <ip> <netmask> <gateway> [dns]
set_static() {
    local iface="$1"
    local ip="$2"
    local netmask="$3"
    local gateway="$4"
    local dns="${5:-8.8.8.8}"
    
    if [ -z "$iface" ] || [ -z "$ip" ]; then
        eerror "Usage: rc-service quantix-network set-static <interface> <ip> <netmask> <gateway> [dns]"
        return 1
    fi
    
    mkdir -p "$STATIC_CONFIG_DIR"
    
    cat > "$STATIC_CONFIG_DIR/$iface.conf" << EOF
# Static IP configuration for $iface
IP_ADDRESS=$ip
NETMASK=${netmask:-255.255.255.0}
GATEWAY=$gateway
DNS=$dns
EOF
    
    # Also update global static.conf
    cp "$STATIC_CONFIG_DIR/$iface.conf" "$STATIC_CONFIG_DIR/static.conf"
    
    # Save to persistent storage (survives reboots)
    if [ -d "/quantix" ]; then
        mkdir -p "$PERSISTENT_CONFIG_DIR"
        cp "$STATIC_CONFIG_DIR/$iface.conf" "$PERSISTENT_CONFIG_DIR/$iface.conf"
        cp "$STATIC_CONFIG_DIR/static.conf" "$PERSISTENT_CONFIG_DIR/static.conf"
        einfo "Static IP configuration saved (persistent)"
    else
        ewarn "Persistent storage not available - config will be lost on reboot"
    fi
    
    einfo "Run 'rc-service quantix-network restart' to apply"
    return 0
}

# Helper: Remove static IP config and switch to DHCP
# Usage: rc-service quantix-network use-dhcp [interface]
use_dhcp() {
    local iface="$1"
    
    if [ -n "$iface" ]; then
        rm -f "$STATIC_CONFIG_DIR/$iface.conf"
        rm -f "$PERSISTENT_CONFIG_DIR/$iface.conf" 2>/dev/null
        einfo "Removed static config for $iface"
    else
        rm -f "$STATIC_CONFIG_DIR"/*.conf
        rm -f "$PERSISTENT_CONFIG_DIR"/*.conf 2>/dev/null
        einfo "Removed all static IP configurations"
    fi
    
    einfo "Run 'rc-service quantix-network restart' to switch to DHCP"
    return 0
}
