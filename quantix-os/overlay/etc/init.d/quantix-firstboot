#!/sbin/openrc-run
# =============================================================================
# Quantix-OS First Boot Service
# =============================================================================
# Runs on first boot to perform initial system configuration.
# =============================================================================

name="Quantix First Boot"
description="One-time first boot configuration"

depend() {
    need localmount
    before quantix-node quantix-console ovsdb-server ovs-vswitchd
}

start() {
    # Check if first boot
    if [ -f /quantix/.setup_complete ]; then
        einfo "First boot already completed"
        return 0
    fi

    ebegin "Running first boot configuration"

    # CRITICAL: Ensure /quantix (QUANTIX-CFG partition) is mounted
    # This contains installer configuration including hostname
    if ! mountpoint -q /quantix 2>/dev/null; then
        einfo "Mounting QUANTIX-CFG partition..."
        mkdir -p /quantix
        
        if mount -L QUANTIX-CFG /quantix 2>/dev/null; then
            einfo "Mounted QUANTIX-CFG partition by label"
        else
            # Fallback: find using blkid
            CFG_PART=$(blkid -L QUANTIX-CFG 2>/dev/null)
            if [ -n "$CFG_PART" ]; then
                mount "$CFG_PART" /quantix 2>/dev/null || ewarn "Failed to mount QUANTIX-CFG"
            else
                ewarn "QUANTIX-CFG partition not found"
            fi
        fi
    fi

    # Apply hostname from installer configuration
    HOSTNAME_FILE="/quantix/hostname"
    if [ -f "$HOSTNAME_FILE" ]; then
        NEW_HOSTNAME=$(cat "$HOSTNAME_FILE" | tr -d '[:space:]')
        
        if [ -n "$NEW_HOSTNAME" ]; then
            einfo "Setting hostname to: $NEW_HOSTNAME"
            
            # Set the running hostname
            hostname "$NEW_HOSTNAME"
            
            # Persist to /etc/hostname
            echo "$NEW_HOSTNAME" > /etc/hostname
            
            # Update /etc/hosts
            if grep -q "127.0.1.1" /etc/hosts; then
                sed -i "s/127.0.1.1.*/127.0.1.1\t$NEW_HOSTNAME/" /etc/hosts
            else
                echo "127.0.1.1	$NEW_HOSTNAME" >> /etc/hosts
            fi
            
            einfo "Hostname configured: $NEW_HOSTNAME"
        fi
    fi

    # Generate SSH host keys
    if [ ! -f /etc/ssh/ssh_host_rsa_key ]; then
        einfo "Generating SSH host keys..."
        ssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N "" -q
        ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N "" -q
        ssh-keygen -t ecdsa -b 521 -f /etc/ssh/ssh_host_ecdsa_key -N "" -q
    fi

    # Generate TLS certificates
    CERT_DIR="/etc/limiquantix/certs"
    if [ ! -f "$CERT_DIR/server.key" ]; then
        einfo "Generating TLS certificates..."
        mkdir -p "$CERT_DIR"
        chmod 700 "$CERT_DIR"
        
        HOSTNAME=$(hostname)
        
        # Get primary IP for SAN
        PRIMARY_IP=$(ip -4 addr show scope global | grep inet | head -1 | awk '{print $2}' | cut -d/ -f1)
        PRIMARY_IP=${PRIMARY_IP:-"127.0.0.1"}
        
        openssl genrsa -out "$CERT_DIR/server.key" 4096 2>/dev/null
        openssl req -new -x509 \
            -key "$CERT_DIR/server.key" \
            -out "$CERT_DIR/server.crt" \
            -days 3650 \
            -subj "/CN=${HOSTNAME}/O=Quantix-KVM/OU=Hypervisor" \
            -addext "subjectAltName=DNS:${HOSTNAME},DNS:localhost,IP:127.0.0.1,IP:${PRIMARY_IP}" 2>/dev/null
        
        chmod 600 "$CERT_DIR/server.key"
        chmod 644 "$CERT_DIR/server.crt"
        
        einfo "TLS certificate generated for ${HOSTNAME} (${PRIMARY_IP})"
    fi
    
    # Also create symlink in legacy location for compatibility
    mkdir -p /quantix/certificates
    ln -sf "$CERT_DIR/server.key" /quantix/certificates/server.key 2>/dev/null || true
    ln -sf "$CERT_DIR/server.crt" /quantix/certificates/server.crt 2>/dev/null || true

    # Ensure Quantix boot entry is first when UEFI is present (avoid PXE stalls)
    if command -v efibootmgr >/dev/null 2>&1 && [ -d /sys/firmware/efi/efivars ]; then
        einfo "Ensuring Quantix boot entry is first in UEFI BootOrder..."
        BOOT_ENTRY=$(efibootmgr | awk 'tolower($0) ~ /quantix/ && $1 ~ /^Boot[0-9A-F]{4}/ {gsub(/^Boot/,"",$1); gsub(/\*/,"",$1); print $1; exit}')
        if [ -n "$BOOT_ENTRY" ]; then
            CURRENT_ORDER=$(efibootmgr | awk -F'BootOrder: ' 'NF==2 {print $2}' | tr -d '\r')
            if [ -n "$CURRENT_ORDER" ]; then
                REST_ORDER=$(printf '%s' "$CURRENT_ORDER" | awk -v entry="$BOOT_ENTRY" 'BEGIN{RS=","; ORS=","} toupper($0)!=toupper(entry) && length($0)>0 {print $0}' | sed 's/,$//')
                if [ -n "$REST_ORDER" ]; then
                    NEW_ORDER="${BOOT_ENTRY},${REST_ORDER}"
                else
                    NEW_ORDER="${BOOT_ENTRY}"
                fi
            else
                NEW_ORDER="${BOOT_ENTRY}"
            fi

            efibootmgr -o "$NEW_ORDER" >/dev/null 2>&1 || ewarn "Failed to update UEFI BootOrder"
            efibootmgr -n "$BOOT_ENTRY" >/dev/null 2>&1 || ewarn "Failed to set UEFI BootNext"
            einfo "UEFI BootOrder updated: ${NEW_ORDER}"
        else
            ewarn "Quantix UEFI boot entry not found; PXE may remain first"
        fi
    else
        einfo "UEFI boot manager not available; skipping boot order update"
    fi

    # Create default storage directories
    einfo "Creating storage directories..."
    mkdir -p /data/vms /data/isos /data/images /data/backups
    chmod 755 /data

    # Mount installer-configured storage pools
    POOLS_FSTAB="/quantix/fstab.pools"
    if [ -f "$POOLS_FSTAB" ]; then
        einfo "Mounting installer-configured storage pools..."
        
        # Add to system fstab if not already there
        if ! grep -q "# Quantix storage pools" /etc/fstab 2>/dev/null; then
            echo "" >> /etc/fstab
            echo "# Quantix storage pools (installer-configured)" >> /etc/fstab
            cat "$POOLS_FSTAB" >> /etc/fstab
        fi
        
        # Mount each pool
        while IFS= read -r line || [ -n "$line" ]; do
            [ -z "$line" ] && continue
            echo "$line" | grep -q "^#" && continue
            
            MOUNT_POINT=$(echo "$line" | awk '{print $2}')
            
            if [ -n "$MOUNT_POINT" ]; then
                mkdir -p "$MOUNT_POINT"
                
                if ! mountpoint -q "$MOUNT_POINT" 2>/dev/null; then
                    einfo "  Mounting $MOUNT_POINT..."
                    if mount "$MOUNT_POINT" 2>/dev/null; then
                        POOL_SIZE=$(df -h "$MOUNT_POINT" 2>/dev/null | tail -1 | awk '{print $2}')
                        einfo "  ✓ Mounted ($POOL_SIZE)"
                    else
                        ewarn "  Failed to mount $MOUNT_POINT"
                    fi
                else
                    einfo "  $MOUNT_POINT already mounted"
                fi
            fi
        done < "$POOLS_FSTAB"
    fi

    # Initialize libvirt default pool
    if command -v virsh >/dev/null 2>&1; then
        if ! virsh pool-info default >/dev/null 2>&1; then
            einfo "Creating default libvirt storage pool..."
            virsh pool-define-as default dir --target /data/vms 2>/dev/null || true
            virsh pool-autostart default 2>/dev/null || true
            virsh pool-start default 2>/dev/null || true
        fi
        
        # Register installer-configured storage pools with libvirt
        POOLS_CONFIG="/quantix/limiquantix/storage-pools.yaml"
        if [ -f "$POOLS_CONFIG" ]; then
            einfo "Registering installer-configured storage pools with libvirt..."
            
            # Simple YAML parsing for pool entries
            POOL_NAME=""
            MOUNT_POINT=""
            
            while IFS= read -r line || [ -n "$line" ]; do
                line=$(echo "$line" | sed 's/^[[:space:]]*//')
                
                # Extract pool name
                case "$line" in
                    "- name:"*|"name:"*)
                        POOL_NAME=$(echo "$line" | sed 's/.*name:[[:space:]]*//')
                        ;;
                    "mount_point:"*)
                        MOUNT_POINT=$(echo "$line" | sed 's/mount_point:[[:space:]]*//')
                        
                        # If we have both name and mount_point, register the pool
                        if [ -n "$POOL_NAME" ] && [ -n "$MOUNT_POINT" ]; then
                            if ! virsh pool-info "$POOL_NAME" >/dev/null 2>&1; then
                                if mountpoint -q "$MOUNT_POINT" 2>/dev/null; then
                                    einfo "  Registering pool: $POOL_NAME at $MOUNT_POINT"
                                    virsh pool-define-as "$POOL_NAME" dir --target "$MOUNT_POINT" 2>/dev/null && \
                                    virsh pool-autostart "$POOL_NAME" 2>/dev/null && \
                                    virsh pool-start "$POOL_NAME" 2>/dev/null && \
                                    einfo "  ✓ Pool $POOL_NAME registered"
                                else
                                    ewarn "  Skipping $POOL_NAME - mount point not mounted: $MOUNT_POINT"
                                fi
                            else
                                einfo "  Pool $POOL_NAME already exists"
                            fi
                            POOL_NAME=""
                            MOUNT_POINT=""
                        fi
                        ;;
                esac
            done < "$POOLS_CONFIG"
        fi
    fi

    # Initialize OVS database if needed
    if command -v ovsdb-tool >/dev/null 2>&1; then
        if [ ! -f /etc/openvswitch/conf.db ]; then
            einfo "Initializing Open vSwitch database..."
            mkdir -p /etc/openvswitch /var/lib/openvswitch /run/openvswitch
            ovsdb-tool create /etc/openvswitch/conf.db /usr/share/openvswitch/vswitch.ovsschema 2>/dev/null || true
            # Restart OVS services after database creation
            rc-service ovsdb-server restart 2>/dev/null || true
            sleep 1
            rc-service ovs-vswitchd restart 2>/dev/null || true
            sleep 1
        fi
    fi
    
    # Initialize OVS bridge
    if command -v ovs-vsctl >/dev/null 2>&1; then
        if ! ovs-vsctl br-exists br-int 2>/dev/null; then
            einfo "Creating OVS integration bridge..."
            ovs-vsctl add-br br-int 2>/dev/null || true
        fi
    fi

    # Mark first boot complete
    touch /quantix/.setup_complete
    einfo "First boot configuration complete"

    eend 0
}

stop() {
    return 0
}
