//! Quantix-OS Console TUI
//!
//! Terminal-based fallback console for systems without GPU/KMS support.

// Some screens and features are placeholders for future implementation
#![allow(dead_code)]

use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyModifiers},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, Paragraph, Wrap},
    Frame, Terminal,
};
use std::io;
use std::time::Duration;
use sysinfo::System;
use tracing::info;

mod auth;
mod config;

/// Application state
struct App {
    /// Current screen
    screen: Screen,
    /// Selected menu item
    selected_menu: usize,
    /// System information
    system: System,
    /// Whether to quit
    should_quit: bool,
    /// Error message to display
    error_message: Option<String>,
    /// Success message to display
    success_message: Option<String>,
    /// Cached hostname (read once)
    hostname: String,
    /// Cached primary IP (refreshed periodically)
    primary_ip: String,
    /// Cached VM count (refreshed periodically)
    vm_count: i32,
    /// Static IP configuration state
    static_ip_config: StaticIpConfig,
    /// WiFi configuration state
    wifi_config: WiFiConfig,
    /// SSH configuration state
    ssh_config: SshConfig,
    /// Current input field index (for forms)
    input_field_index: usize,
    /// Available network interfaces
    available_interfaces: Vec<String>,
    /// Selected interface index
    selected_interface: usize,
    /// Status message (shown prominently at top)
    status_message: Option<(String, std::time::Instant)>,
    /// Cluster configuration state
    cluster_config: ClusterConfig,
    /// Last auto-refresh time for resources
    last_resource_refresh: std::time::Instant,
    /// Cached CPU usage percentage
    cpu_usage: f32,
    /// Cached memory used bytes
    memory_used: u64,
    /// Cached memory total bytes
    memory_total: u64,
    /// Cached storage info (mount_point, used, total)
    storage_info: Vec<(String, u64, u64)>,
    /// Quantix-OS version (read from VERSION file)
    os_version: String,
}

/// Static IP configuration
#[derive(Default, Clone)]
struct StaticIpConfig {
    interface: String,
    ip_address: String,
    netmask: String,
    gateway: String,
    dns: String,
}

/// WiFi configuration  
#[derive(Default, Clone)]
struct WiFiConfig {
    ssid: String,
    password: String,
    security: String, // "WPA2", "WPA3", "OPEN"
}

/// SSH configuration with timer
#[derive(Clone)]
struct SshConfig {
    enabled: bool,
    timer_minutes: u32,
    timer_start: Option<std::time::Instant>,
}

impl Default for SshConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            timer_minutes: 30, // Default 30 minutes
            timer_start: None,
        }
    }
}

/// Cluster configuration for joining Quantix-vDC control plane
#[derive(Clone)]
struct ClusterConfig {
    /// Control plane address (e.g., "https://control.example.com:8080")
    control_plane_address: String,
    /// Registration token from control plane (legacy - no longer used)
    registration_token: String,
    /// Current cluster status
    status: ClusterStatus,
    /// Generated registration token (for vDC to use)
    generated_token: Option<GeneratedToken>,
}

/// A registration token generated by this host for vDC to use
#[derive(Clone)]
struct GeneratedToken {
    token: String,
    expires_at: std::time::Instant,
}

#[derive(Clone, PartialEq)]
enum ClusterStatus {
    Standalone,
    Joining,
    Connected,
    Disconnected,
    Error(String),
}

impl Default for ClusterConfig {
    fn default() -> Self {
        Self {
            control_plane_address: String::new(),
            registration_token: String::new(),
            status: ClusterStatus::Standalone,
            generated_token: None,
        }
    }
}

/// Application screens
#[derive(Clone, Copy, PartialEq, Debug)]
enum Screen {
    Main,
    Network,
    StaticIp,
    WiFi,
    Ssh,
    Cluster,
    Services,
    Diagnostics,
    Power,
    Auth,
    FactoryReset,
    Shell,
}

impl App {
    fn new() -> Self {
        let mut system = System::new();
        system.refresh_all();
        
        // Read hostname once at startup
        let hostname = std::fs::read_to_string("/etc/hostname")
            .map(|s| s.trim().to_string())
            .unwrap_or_else(|_| "quantix".to_string());

        // Get available network interfaces
        let available_interfaces = get_interface_names();

        // Check current SSH status
        let ssh_enabled = is_ssh_enabled();
        
        // Read OS version from various locations
        let os_version = get_os_version();
        
        Self {
            screen: Screen::Main,
            selected_menu: 0,
            system,
            should_quit: false,
            error_message: None,
            success_message: None,
            hostname,
            primary_ip: get_primary_ip(),
            vm_count: get_vm_count(),
            static_ip_config: StaticIpConfig {
                interface: available_interfaces.first().cloned().unwrap_or_default(),
                ip_address: String::new(),
                netmask: "255.255.255.0".to_string(),
                gateway: String::new(),
                dns: "8.8.8.8".to_string(),
            },
            wifi_config: WiFiConfig {
                ssid: String::new(),
                password: String::new(),
                security: "WPA2".to_string(),
            },
            ssh_config: SshConfig {
                enabled: ssh_enabled,
                timer_minutes: 30,
                timer_start: None,
            },
            input_field_index: 0,
            available_interfaces,
            selected_interface: 0,
            status_message: None,
            cluster_config: ClusterConfig {
                status: get_cluster_status(),
                ..Default::default()
            },
            last_resource_refresh: std::time::Instant::now(),
            cpu_usage: 0.0,
            memory_used: 0,
            memory_total: 0,
            storage_info: Vec::new(),
            os_version,
        }
    }

    fn refresh(&mut self) {
        // Refresh all dynamic values (called on F5 or auto-refresh)
        self.primary_ip = get_primary_ip();
        self.vm_count = get_vm_count();
        self.cluster_config.status = get_cluster_status();
        self.refresh_resources();
        self.last_resource_refresh = std::time::Instant::now();
    }
    
    fn refresh_resources(&mut self) {
        // Refresh CPU and memory
        self.system.refresh_all();
        
        // Calculate CPU usage (average across all CPUs)
        let cpus = self.system.cpus();
        if !cpus.is_empty() {
            let total_usage: f32 = cpus.iter().map(|cpu| cpu.cpu_usage()).sum();
            self.cpu_usage = total_usage / cpus.len() as f32;
        }
        
        // Get memory usage
        self.memory_total = self.system.total_memory();
        self.memory_used = self.system.used_memory();
        
        // Get storage info for main partitions
        self.storage_info = get_storage_info();
    }
    
    fn should_auto_refresh(&self) -> bool {
        // Auto-refresh resources every 10 seconds
        self.last_resource_refresh.elapsed().as_secs() >= 10
    }

    fn menu_items(&self) -> Vec<(&str, &str)> {
        vec![
            ("Open Local Shell", "F1"),
            ("Configure Management Network", "F2"),
            ("Configure SSH Access", "F3"),
            ("Generate Registration Token", "F4"),
            ("Refresh Display", "F5"),
            ("Restart Management Services", "F6"),
            ("View System Logs", "F7"),
            ("Reset to Factory Defaults", "F9"),
            ("Shutdown / Reboot", "F10"),
        ]
    }
    
    fn set_status(&mut self, msg: &str) {
        self.status_message = Some((msg.to_string(), std::time::Instant::now()));
    }
    
    fn check_ssh_timer(&mut self) {
        if let Some(start) = self.ssh_config.timer_start {
            let elapsed = start.elapsed().as_secs() / 60;
            if elapsed >= self.ssh_config.timer_minutes as u64 {
                // Timer expired, disable SSH
                if disable_ssh().is_ok() {
                    self.ssh_config.enabled = false;
                    self.ssh_config.timer_start = None;
                    self.set_status("SSH auto-disabled (timer expired)");
                }
            }
        }
    }
}

fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter("qx_console=info")
        .init();

    info!("ðŸš€ Starting Quantix-OS Console TUI");

    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = App::new();
    
    // Initial resource refresh
    app.refresh_resources();

    // Main loop
    let result = run_app(&mut terminal, &mut app);

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Err(e) = result {
        eprintln!("Error: {}", e);
    }

    info!("ðŸ‘‹ Quantix-OS Console TUI shutting down");
    Ok(())
}

fn run_app<B: ratatui::backend::Backend>(
    terminal: &mut Terminal<B>,
    app: &mut App,
) -> Result<()> {
    // Initial draw
    terminal.draw(|f| ui(f, app))?;

    loop {
        // Check if we need to drop to shell
        if app.screen == Screen::Shell {
            // Drop to shell - temporarily restore terminal
            drop_to_shell(terminal)?;
            app.screen = Screen::Main;
            app.success_message = Some("Returned from shell".to_string());
            // Redraw immediately after returning
            terminal.draw(|f| ui(f, app))?;
            continue;
        }
        
        // Use poll with timeout to check timers periodically
        // Poll every 1 second to allow for smoother auto-refresh
        if event::poll(Duration::from_secs(1))? {
            if let Event::Key(key) = event::read()? {
                handle_input(app, key.code, key.modifiers);
            }
        }
        
        // Check SSH timer on every loop iteration
        app.check_ssh_timer();
        
        // Auto-refresh resources every 10 seconds (only on main screen)
        if app.screen == Screen::Main && app.should_auto_refresh() {
            app.refresh_resources();
            app.last_resource_refresh = std::time::Instant::now();
        }
        
        // Clear status message after 5 seconds
        if let Some((_, start)) = &app.status_message {
            if start.elapsed().as_secs() > 5 {
                app.status_message = None;
            }
        }

        // Redraw the UI
        terminal.draw(|f| ui(f, app))?;

        if app.should_quit {
            return Ok(());
        }
    }
}

fn handle_input(app: &mut App, key: KeyCode, modifiers: KeyModifiers) {
    // Clear messages on any input
    app.error_message = None;
    app.success_message = None;

    match app.screen {
        Screen::Main => match key {
            KeyCode::Char('q') | KeyCode::Char('Q') => {
                if modifiers.contains(KeyModifiers::CONTROL) {
                    app.should_quit = true;
                }
            }
            KeyCode::Up | KeyCode::Char('k') => {
                if app.selected_menu > 0 {
                    app.selected_menu -= 1;
                }
            }
            KeyCode::Down | KeyCode::Char('j') => {
                let max = app.menu_items().len() - 1;
                if app.selected_menu < max {
                    app.selected_menu += 1;
                }
            }
            KeyCode::Enter => {
                handle_menu_action(app, app.selected_menu);
            }
            KeyCode::F(1) => handle_menu_action(app, 0),  // Local Shell
            KeyCode::F(2) => handle_menu_action(app, 1),  // Network
            KeyCode::F(3) => handle_menu_action(app, 2),  // SSH Config
            KeyCode::F(4) => handle_menu_action(app, 3),  // Cluster
            KeyCode::F(5) => handle_menu_action(app, 4),  // Refresh
            KeyCode::F(6) => handle_menu_action(app, 5),  // Restart Services
            KeyCode::F(7) => handle_menu_action(app, 6),  // Logs
            KeyCode::F(9) => handle_menu_action(app, 7),  // Factory Reset
            KeyCode::F(10) => handle_menu_action(app, 8), // Shutdown
            _ => {}
        },
        Screen::Network => match key {
            KeyCode::Esc | KeyCode::Char('q') => {
                app.screen = Screen::Main;
            }
            KeyCode::Char('d') | KeyCode::Char('D') => {
                app.success_message = Some("Running DHCP on all interfaces...".to_string());
                run_dhcp_all();
            }
            KeyCode::Char('r') | KeyCode::Char('R') => {
                app.success_message = Some("Restarting network service...".to_string());
                restart_network();
            }
            KeyCode::Char('s') | KeyCode::Char('S') => {
                // Go to Static IP configuration screen
                app.input_field_index = 1; // Start at IP Address field, not Interface
                app.available_interfaces = get_interface_names();
                app.selected_interface = 0;
                // Reset the config to clean state
                app.static_ip_config = StaticIpConfig {
                    interface: app.available_interfaces.first().cloned().unwrap_or_else(|| "eth0".to_string()),
                    ip_address: String::new(),
                    netmask: "255.255.255.0".to_string(),
                    gateway: String::new(),
                    dns: "8.8.8.8".to_string(),
                };
                app.screen = Screen::StaticIp;
            }
            KeyCode::Char('w') | KeyCode::Char('W') => {
                // Go to WiFi configuration screen
                app.input_field_index = 0;
                app.wifi_config = WiFiConfig::default();
                app.wifi_config.security = "WPA2".to_string();
                app.screen = Screen::WiFi;
            }
            _ => {}
        },
        Screen::StaticIp => handle_static_ip_input(app, key),
        Screen::WiFi => handle_wifi_input(app, key),
        Screen::Ssh => handle_ssh_input(app, key),
        Screen::Cluster => handle_cluster_input(app, key),
        Screen::FactoryReset => match key {
            KeyCode::Esc | KeyCode::Char('q') | KeyCode::Char('n') | KeyCode::Char('N') => {
                app.screen = Screen::Main;
                app.success_message = Some("Factory reset cancelled".to_string());
            }
            KeyCode::Char('y') | KeyCode::Char('Y') => {
                app.set_status("âš ï¸ Performing factory reset...");
                perform_factory_reset();
                app.success_message = Some("Factory reset complete. Rebooting...".to_string());
                // Reboot after reset
                std::thread::spawn(|| {
                    std::thread::sleep(std::time::Duration::from_secs(2));
                    let _ = std::process::Command::new("reboot").spawn();
                });
            }
            _ => {}
        },
        Screen::Power => match key {
            KeyCode::Esc | KeyCode::Char('q') => {
                app.screen = Screen::Main;
            }
            KeyCode::Char('r') | KeyCode::Char('R') => {
                let _ = std::process::Command::new("reboot").spawn();
            }
            KeyCode::Char('s') | KeyCode::Char('S') => {
                let _ = std::process::Command::new("poweroff").spawn();
            }
            _ => {}
        },
        _ => match key {
            KeyCode::Esc | KeyCode::Char('q') => {
                app.screen = Screen::Main;
            }
            _ => {}
        },
    }
}

fn handle_menu_action(app: &mut App, index: usize) {
    match index {
        0 => {
            // Open local shell - special handling needed
            // Set a flag that will be handled in the main loop
            app.screen = Screen::Shell;
        }
        1 => app.screen = Screen::Network,
        2 => {
            // Go to SSH configuration screen
            app.input_field_index = 0;
            app.ssh_config.enabled = is_ssh_enabled();
            app.screen = Screen::Ssh;
        }
        3 => {
            // Go to Cluster configuration screen
            app.input_field_index = 0;
            app.cluster_config.status = get_cluster_status();
            app.screen = Screen::Cluster;
        }
        4 => {
            // Refresh display
            app.set_status("Refreshing system information...");
            app.refresh();
            app.success_message = Some("Display refreshed".to_string());
        }
        5 => {
            // Restart management services
            app.set_status("â³ Restarting management services...");
            restart_management_services();
            app.success_message = Some("Management services restarting...".to_string());
        }
        6 => app.screen = Screen::Diagnostics,
        7 => {
            // Go to Factory Reset confirmation screen
            app.screen = Screen::FactoryReset;
        }
        8 => app.screen = Screen::Power,
        _ => {}
    }
}

fn restart_management_services() {
    use std::process::Stdio;
    // Redirect all output to null to prevent TUI corruption
    // Use spawn() to avoid blocking the TUI
    let _ = std::process::Command::new("rc-service")
        .args(["quantix-node", "restart"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .stdin(Stdio::null())
        .spawn();
}

/// Drop to an interactive shell, temporarily suspending the TUI
fn drop_to_shell<B: ratatui::backend::Backend>(terminal: &mut Terminal<B>) -> Result<()> {
    // Leave alternate screen and disable raw mode to give shell a normal terminal
    disable_raw_mode()?;
    execute!(
        std::io::stdout(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    let _ = terminal.show_cursor();
    
    // Clear screen and print banner
    print!("\x1B[2J\x1B[H"); // Clear screen and move cursor to top-left
    println!("\x1B[1;36mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\x1B[0m");
    println!("\x1B[1;36mâ•‘\x1B[0m  \x1B[1;33mQuantix-OS Local Shell\x1B[0m                                         \x1B[1;36mâ•‘\x1B[0m");
    println!("\x1B[1;36mâ•‘\x1B[0m                                                                    \x1B[1;36mâ•‘\x1B[0m");
    println!("\x1B[1;36mâ•‘\x1B[0m  You are now in a local shell session.                           \x1B[1;36mâ•‘\x1B[0m");
    println!("\x1B[1;36mâ•‘\x1B[0m  Type '\x1B[1;32mexit\x1B[0m' to return to the console TUI.                        \x1B[1;36mâ•‘\x1B[0m");
    println!("\x1B[1;36mâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1B[0m");
    println!();
    
    // Spawn the shell and wait for it to exit
    // Try /bin/ash first (Alpine's default), then /bin/sh
    let shell = if std::path::Path::new("/bin/ash").exists() {
        "/bin/ash"
    } else {
        "/bin/sh"
    };
    
    let mut child = std::process::Command::new(shell)
        .stdin(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .spawn()?;
    
    // Wait for the shell to exit
    let _ = child.wait();
    
    // Restore terminal state for TUI
    enable_raw_mode()?;
    execute!(
        std::io::stdout(),
        EnterAlternateScreen,
        EnableMouseCapture
    )?;
    let _ = terminal.hide_cursor();
    let _ = terminal.clear();
    
    Ok(())
}

fn handle_static_ip_input(app: &mut App, key: KeyCode) {
    match key {
        KeyCode::Esc => {
            app.screen = Screen::Network;
        }
        KeyCode::Tab | KeyCode::Down => {
            // Move to next field (5 fields: interface, ip, netmask, gateway, dns)
            app.input_field_index = (app.input_field_index + 1) % 5;
        }
        KeyCode::BackTab | KeyCode::Up => {
            // Move to previous field
            if app.input_field_index > 0 {
                app.input_field_index -= 1;
            } else {
                app.input_field_index = 4;
            }
        }
        KeyCode::Left => {
            // For interface selector (field 0), cycle through interfaces
            if app.input_field_index == 0 && !app.available_interfaces.is_empty() {
                if app.selected_interface > 0 {
                    app.selected_interface -= 1;
                } else {
                    app.selected_interface = app.available_interfaces.len() - 1;
                }
                app.static_ip_config.interface = app.available_interfaces[app.selected_interface].clone();
            }
        }
        KeyCode::Right => {
            // For interface selector (field 0), cycle through interfaces
            if app.input_field_index == 0 && !app.available_interfaces.is_empty() {
                app.selected_interface = (app.selected_interface + 1) % app.available_interfaces.len();
                app.static_ip_config.interface = app.available_interfaces[app.selected_interface].clone();
            }
        }
        KeyCode::Char(c) => {
            // Only allow valid IP characters
            if c.is_ascii_digit() || c == '.' {
                match app.input_field_index {
                    1 => app.static_ip_config.ip_address.push(c),
                    2 => app.static_ip_config.netmask.push(c),
                    3 => app.static_ip_config.gateway.push(c),
                    4 => app.static_ip_config.dns.push(c),
                    _ => {}
                }
            }
        }
        KeyCode::Backspace => {
            match app.input_field_index {
                1 => { app.static_ip_config.ip_address.pop(); }
                2 => { app.static_ip_config.netmask.pop(); }
                3 => { app.static_ip_config.gateway.pop(); }
                4 => { app.static_ip_config.dns.pop(); }
                _ => {}
            }
        }
        KeyCode::Enter => {
            // Apply the static IP configuration
            if app.static_ip_config.ip_address.is_empty() {
                app.error_message = Some("IP address is required".to_string());
            } else if !is_valid_ip(&app.static_ip_config.ip_address) {
                app.error_message = Some("Invalid IP address format".to_string());
            } else {
                match apply_static_ip(&app.static_ip_config) {
                    Ok(_) => {
                        app.success_message = Some(format!(
                            "Static IP {} applied to {}",
                            app.static_ip_config.ip_address,
                            app.static_ip_config.interface
                        ));
                        app.primary_ip = app.static_ip_config.ip_address.clone();
                        app.screen = Screen::Network;
                    }
                    Err(e) => {
                        app.error_message = Some(format!("Failed to apply: {}", e));
                    }
                }
            }
        }
        _ => {}
    }
}

fn handle_wifi_input(app: &mut App, key: KeyCode) {
    match key {
        KeyCode::Esc => {
            app.screen = Screen::Network;
        }
        KeyCode::Tab | KeyCode::Down => {
            // Move to next field (3 fields: ssid, password, security)
            app.input_field_index = (app.input_field_index + 1) % 3;
        }
        KeyCode::BackTab | KeyCode::Up => {
            // Move to previous field
            if app.input_field_index > 0 {
                app.input_field_index -= 1;
            } else {
                app.input_field_index = 2;
            }
        }
        KeyCode::Left | KeyCode::Right => {
            // For security selector (field 2), cycle through options
            if app.input_field_index == 2 {
                let options = ["WPA2", "WPA3", "OPEN"];
                let current_idx = options.iter().position(|&s| s == app.wifi_config.security).unwrap_or(0);
                let new_idx = if key == KeyCode::Right {
                    (current_idx + 1) % options.len()
                } else if current_idx > 0 {
                    current_idx - 1
                } else {
                    options.len() - 1
                };
                app.wifi_config.security = options[new_idx].to_string();
            }
        }
        KeyCode::Char(c) => {
            match app.input_field_index {
                0 => app.wifi_config.ssid.push(c),
                1 => app.wifi_config.password.push(c),
                _ => {}
            }
        }
        KeyCode::Backspace => {
            match app.input_field_index {
                0 => { app.wifi_config.ssid.pop(); }
                1 => { app.wifi_config.password.pop(); }
                _ => {}
            }
        }
        KeyCode::Enter => {
            // Apply the WiFi configuration
            if app.wifi_config.ssid.is_empty() {
                app.error_message = Some("SSID is required".to_string());
            } else if app.wifi_config.security != "OPEN" && app.wifi_config.password.len() < 8 {
                app.error_message = Some("Password must be at least 8 characters".to_string());
            } else {
                match apply_wifi_config(&app.wifi_config) {
                    Ok(_) => {
                        app.success_message = Some(format!(
                            "WiFi configured for network: {}",
                            app.wifi_config.ssid
                        ));
                        app.screen = Screen::Network;
                    }
                    Err(e) => {
                        app.error_message = Some(format!("Failed to configure WiFi: {}", e));
                    }
                }
            }
        }
        _ => {}
    }
}

fn is_valid_ip(ip: &str) -> bool {
    let parts: Vec<&str> = ip.split('.').collect();
    if parts.len() != 4 {
        return false;
    }
    for part in parts {
        match part.parse::<u8>() {
            Ok(_) => continue,
            Err(_) => return false,
        }
    }
    true
}

fn apply_static_ip(config: &StaticIpConfig) -> Result<()> {
    use std::process::Stdio;
    
    // First, flush existing IP on interface
    let _ = std::process::Command::new("ip")
        .args(["addr", "flush", "dev", &config.interface])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    // Bring interface up
    let _ = std::process::Command::new("ip")
        .args(["link", "set", &config.interface, "up"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    // Calculate CIDR prefix from netmask
    let prefix = netmask_to_cidr(&config.netmask);
    let ip_cidr = format!("{}/{}", config.ip_address, prefix);
    
    // Add the IP address
    let result = std::process::Command::new("ip")
        .args(["addr", "add", &ip_cidr, "dev", &config.interface])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output()?;
    
    if !result.status.success() {
        return Err(anyhow::anyhow!("Failed to set IP address"));
    }
    
    // Set default gateway if provided
    if !config.gateway.is_empty() {
        // Remove existing default route first
        let _ = std::process::Command::new("ip")
            .args(["route", "del", "default"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .output();
        
        let _ = std::process::Command::new("ip")
            .args(["route", "add", "default", "via", &config.gateway])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .output();
    }
    
    // Set DNS if provided
    if !config.dns.is_empty() {
        let resolv_content = format!("nameserver {}\n", config.dns);
        let _ = std::fs::write("/etc/resolv.conf", resolv_content);
    }
    
    // Save to /etc/network/interfaces for persistence
    let interfaces_content = format!(
        "auto lo\niface lo inet loopback\n\nauto {}\niface {} inet static\n    address {}\n    netmask {}\n    gateway {}\n",
        config.interface, config.interface, config.ip_address, config.netmask, config.gateway
    );
    let _ = std::fs::write("/etc/network/interfaces", interfaces_content);
    
    Ok(())
}

fn netmask_to_cidr(netmask: &str) -> u8 {
    let parts: Vec<u8> = netmask
        .split('.')
        .filter_map(|s| s.parse().ok())
        .collect();
    
    if parts.len() != 4 {
        return 24; // Default to /24
    }
    
    let mut bits = 0u8;
    for octet in parts {
        bits += octet.count_ones() as u8;
    }
    bits
}

fn apply_wifi_config(config: &WiFiConfig) -> Result<()> {
    use std::process::Stdio;
    
    // Generate wpa_supplicant.conf content
    let wpa_content = if config.security == "OPEN" {
        format!(
            r#"ctrl_interface=/run/wpa_supplicant
update_config=1

network={{
    ssid="{}"
    key_mgmt=NONE
}}
"#,
            config.ssid
        )
    } else {
        format!(
            r#"ctrl_interface=/run/wpa_supplicant
update_config=1

network={{
    ssid="{}"
    psk="{}"
    key_mgmt=WPA-PSK
}}
"#,
            config.ssid, config.password
        )
    };
    
    // Write wpa_supplicant.conf
    std::fs::write("/etc/wpa_supplicant/wpa_supplicant.conf", wpa_content)?;
    
    // Find wireless interface
    let wireless_iface = find_wireless_interface().unwrap_or_else(|| "wlan0".to_string());
    
    // Stop any existing wpa_supplicant
    let _ = std::process::Command::new("pkill")
        .args(["-9", "wpa_supplicant"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    // Bring wireless interface up
    let _ = std::process::Command::new("ip")
        .args(["link", "set", &wireless_iface, "up"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    // Start wpa_supplicant
    let _ = std::process::Command::new("wpa_supplicant")
        .args(["-B", "-i", &wireless_iface, "-c", "/etc/wpa_supplicant/wpa_supplicant.conf"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn();
    
    // Wait a moment for connection
    std::thread::sleep(std::time::Duration::from_secs(2));
    
    // Run DHCP on wireless interface
    let _ = std::process::Command::new("udhcpc")
        .args(["-i", &wireless_iface, "-n", "-q"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn();
    
    Ok(())
}

fn find_wireless_interface() -> Option<String> {
    // Look for wireless interfaces in /sys/class/net/*/wireless
    if let Ok(entries) = std::fs::read_dir("/sys/class/net") {
        for entry in entries.flatten() {
            let path = entry.path();
            let wireless_path = path.join("wireless");
            if wireless_path.exists() {
                if let Some(name) = path.file_name() {
                    return Some(name.to_string_lossy().to_string());
                }
            }
        }
    }
    None
}

fn get_interface_names() -> Vec<String> {
    let mut interfaces = Vec::new();
    
    if let Ok(output) = std::process::Command::new("ip")
        .args(["-o", "link", "show"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 2 {
                let iface = parts[1].trim_end_matches(':');
                // Skip loopback
                if iface != "lo" {
                    interfaces.push(iface.to_string());
                }
            }
        }
    }
    
    if interfaces.is_empty() {
        interfaces.push("eth0".to_string());
    }
    
    interfaces
}

fn ui(f: &mut Frame, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),  // Header
            Constraint::Min(0),     // Content
            Constraint::Length(3),  // Footer
        ])
        .split(f.area());

    // Header - ESXi-style DCUI branding
    let header = Paragraph::new(vec![
        Line::from(vec![
            Span::styled(
                "QUANTIX-OS",
                Style::default()
                    .fg(Color::Cyan)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::raw(" v1.0.0 - "),
            Span::styled("Direct Console User Interface (DCUI)", Style::default().fg(Color::Gray)),
        ]),
    ])
    .block(Block::default().borders(Borders::ALL).title(" System Console "));
    f.render_widget(header, chunks[0]);

    // Content based on screen
    match app.screen {
        Screen::Main => render_main_screen(f, app, chunks[1]),
        Screen::Network => render_network_screen(f, chunks[1]),
        Screen::StaticIp => render_static_ip_screen(f, app, chunks[1]),
        Screen::WiFi => render_wifi_screen(f, app, chunks[1]),
        Screen::Ssh => render_ssh_screen(f, app, chunks[1]),
        Screen::Cluster => render_cluster_screen(f, app, chunks[1]),
        Screen::Diagnostics => render_diagnostics_screen(f, app, chunks[1]),
        Screen::Power => render_power_screen(f, chunks[1]),
        Screen::FactoryReset => render_factory_reset_screen(f, chunks[1]),
        _ => render_placeholder_screen(f, chunks[1], &format!("{:?}", app.screen)),
    }

    // Footer with messages or help - improved visibility
    let (footer_text, footer_style) = if let Some(ref msg) = app.error_message {
        (
            vec![
                Line::from(vec![
                    Span::styled(" âŒ ERROR: ", Style::default().fg(Color::White).bg(Color::Red).add_modifier(Modifier::BOLD)),
                    Span::styled(format!(" {} ", msg), Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
                ]),
            ],
            Style::default().fg(Color::Red),
        )
    } else if let Some(ref msg) = app.success_message {
        (
            vec![
                Line::from(vec![
                    Span::styled(" âœ… ", Style::default().fg(Color::White).bg(Color::Green).add_modifier(Modifier::BOLD)),
                    Span::styled(format!(" {} ", msg), Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
                ]),
            ],
            Style::default().fg(Color::Green),
        )
    } else if let Some((ref msg, _)) = app.status_message {
        (
            vec![
                Line::from(vec![
                    Span::styled(" â³ ", Style::default().fg(Color::Black).bg(Color::Yellow).add_modifier(Modifier::BOLD)),
                    Span::styled(format!(" {} ", msg), Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
                ]),
            ],
            Style::default().fg(Color::Yellow),
        )
    } else {
        (
            vec![
                Line::from(vec![
                    Span::styled(" â†‘â†“ ", Style::default().fg(Color::Cyan)),
                    Span::raw("Navigate  "),
                    Span::styled(" Enter ", Style::default().fg(Color::Cyan)),
                    Span::raw("Select  "),
                    Span::styled(" Esc ", Style::default().fg(Color::Cyan)),
                    Span::raw("Back  "),
                    Span::styled(" F5 ", Style::default().fg(Color::Yellow)),
                    Span::raw("Refresh  "),
                    Span::styled(" Ctrl+Q ", Style::default().fg(Color::Red)),
                    Span::raw("Quit"),
                ]),
            ],
            Style::default(),
        )
    };

    let footer_block = if app.error_message.is_some() {
        Block::default().borders(Borders::ALL).border_style(Style::default().fg(Color::Red)).title(" Message ")
    } else if app.success_message.is_some() {
        Block::default().borders(Borders::ALL).border_style(Style::default().fg(Color::Green)).title(" Message ")
    } else if app.status_message.is_some() {
        Block::default().borders(Borders::ALL).border_style(Style::default().fg(Color::Yellow)).title(" Status ")
    } else {
        Block::default().borders(Borders::ALL).title(" Help ")
    };

    let footer = Paragraph::new(footer_text)
        .block(footer_block)
        .style(footer_style);
    f.render_widget(footer, chunks[2]);
}

fn render_main_screen(f: &mut Frame, app: &App, area: Rect) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(60), Constraint::Percentage(40)])
        .split(area);

    // Left panel - System info
    let left_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(9),   // System info (includes version)
            Constraint::Length(8),   // CPU/Memory/Storage
            Constraint::Min(4),      // Management URL
        ])
        .margin(1)
        .split(chunks[0]);

    // System info - use cached values from app state
    let uptime = format_uptime(System::uptime());

    // Determine status display based on cluster status
    let (status_text, status_color) = match &app.cluster_config.status {
        ClusterStatus::Connected => ("Cluster Joined", Color::Green),
        ClusterStatus::Joining => ("Joining...", Color::Cyan),
        ClusterStatus::Disconnected => ("Disconnected", Color::Red),
        ClusterStatus::Error(_) => ("Error", Color::Red),
        ClusterStatus::Standalone => ("Standalone", Color::Yellow),
    };

    let info_text = vec![
        Line::from(vec![
            Span::styled("Version:  ", Style::default().fg(Color::Gray)),
            Span::styled(format!("Quantix-OS v{}", &app.os_version), Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(vec![
            Span::styled("Hostname: ", Style::default().fg(Color::Gray)),
            Span::styled(&app.hostname, Style::default().fg(Color::White)),
        ]),
        Line::from(vec![
            Span::styled("IP:       ", Style::default().fg(Color::Gray)),
            Span::styled(&app.primary_ip, Style::default().fg(Color::Cyan)),
        ]),
        Line::from(vec![
            Span::styled("Status:   ", Style::default().fg(Color::Gray)),
            Span::styled(status_text, Style::default().fg(status_color)),
        ]),
        Line::from(vec![
            Span::styled("Uptime:   ", Style::default().fg(Color::Gray)),
            Span::styled(&uptime, Style::default().fg(Color::White)),
        ]),
        Line::from(vec![
            Span::styled("VMs:      ", Style::default().fg(Color::Gray)),
            Span::styled(format!("{}", app.vm_count), Style::default().fg(Color::White)),
        ]),
    ];

    let info = Paragraph::new(info_text)
        .block(Block::default().borders(Borders::ALL).title("System Information"));
    f.render_widget(info, left_chunks[0]);

    // System resources - CPU, Memory, Storage
    let cpu_percent = app.cpu_usage as u16;
    let cpu_bar = create_usage_bar(cpu_percent, 20);
    
    let mem_percent = if app.memory_total > 0 {
        ((app.memory_used as f64 / app.memory_total as f64) * 100.0) as u16
    } else {
        0
    };
    let mem_bar = create_usage_bar(mem_percent, 20);
    
    let mut resources_text = vec![
        Line::from(vec![
            Span::styled("CPU:  ", Style::default().fg(Color::Gray)),
            Span::styled(cpu_bar, get_usage_color(cpu_percent)),
            Span::styled(format!(" {:3}%", cpu_percent), get_usage_color(cpu_percent)),
        ]),
        Line::from(vec![
            Span::styled("RAM:  ", Style::default().fg(Color::Gray)),
            Span::styled(mem_bar, get_usage_color(mem_percent)),
            Span::styled(
                format!(" {:3}% ({}/{})", 
                    mem_percent, 
                    format_bytes(app.memory_used), 
                    format_bytes(app.memory_total)
                ), 
                get_usage_color(mem_percent)
            ),
        ]),
    ];
    
    // Add storage info
    for (mount, used, total) in &app.storage_info {
        if *total == 0 {
            continue;
        }
        let storage_percent = ((*used as f64 / *total as f64) * 100.0) as u16;
        let storage_bar = create_usage_bar(storage_percent, 20);
        
        // Truncate mount point if too long
        let mount_display = if mount.len() > 6 {
            format!("{}:", &mount[..6])
        } else {
            format!("{}:", mount)
        };
        
        resources_text.push(Line::from(vec![
            Span::styled(format!("{:<6}", mount_display), Style::default().fg(Color::Gray)),
            Span::styled(storage_bar, get_usage_color(storage_percent)),
            Span::styled(
                format!(" {:3}% ({}/{})", storage_percent, format_bytes(*used), format_bytes(*total)), 
                get_usage_color(storage_percent)
            ),
        ]));
    }
    
    let resources = Paragraph::new(resources_text)
        .block(Block::default().borders(Borders::ALL).title("System Resources (auto-refresh 10s)"));
    f.render_widget(resources, left_chunks[1]);

    // Management URL
    let url_text = format!("https://{}:8443", app.primary_ip);
    let url = Paragraph::new(vec![
        Line::from(Span::styled("Management URL:", Style::default().fg(Color::Gray))),
        Line::from(Span::styled(&url_text, Style::default().fg(Color::Cyan))),
    ])
    .block(Block::default().borders(Borders::ALL));
    f.render_widget(url, left_chunks[2]);

    // Right panel - Menu
    let menu_items: Vec<ListItem> = app
        .menu_items()
        .iter()
        .enumerate()
        .map(|(i, (label, shortcut))| {
            let style = if i == app.selected_menu {
                Style::default()
                    .fg(Color::Cyan)
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default().fg(Color::White)
            };

            ListItem::new(Line::from(vec![
                Span::styled(
                    if i == app.selected_menu { "â–¶ " } else { "  " },
                    style,
                ),
                Span::styled(*label, style),
                Span::raw("  "),
                Span::styled(*shortcut, Style::default().fg(Color::DarkGray)),
            ]))
        })
        .collect();

    let menu = List::new(menu_items)
        .block(Block::default().borders(Borders::ALL).title("Menu"));
    f.render_widget(menu, chunks[1]);
}

fn render_network_screen(f: &mut Frame, area: Rect) {
    // Get current network status
    let interfaces = get_network_interfaces();
    
    let mut lines = vec![
        Line::from(Span::styled("Network Configuration", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(Span::styled("Current Interfaces:", Style::default().fg(Color::Cyan))),
        Line::from(""),
    ];
    
    for (iface, ip, status) in &interfaces {
        let status_color = if status == "UP" { Color::Green } else { Color::Red };
        lines.push(Line::from(vec![
            Span::raw("  "),
            Span::styled(format!("{:<12}", iface), Style::default().fg(Color::White)),
            Span::styled(format!("{:<16}", ip), Style::default().fg(Color::Cyan)),
            Span::styled(status, Style::default().fg(status_color)),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Actions:", Style::default().fg(Color::Cyan))));
    lines.push(Line::from(""));
    lines.push(Line::from("  D - Run DHCP on all interfaces"));
    lines.push(Line::from("  R - Restart network service"));
    lines.push(Line::from("  S - Set static IP (manual entry)"));
    lines.push(Line::from("  W - Configure WiFi"));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Press Esc to return", Style::default().fg(Color::Yellow))));

    let text = Paragraph::new(lines)
    .block(Block::default().borders(Borders::ALL).title("Network"))
    .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn render_static_ip_screen(f: &mut Frame, app: &App, area: Rect) {
    let mut lines = vec![
        Line::from(Span::styled("Static IP Configuration", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(Span::styled("Use Tab/â†‘â†“ to navigate fields, Left/Right to select interface", Style::default().fg(Color::DarkGray))),
        Line::from(Span::styled("Press Enter to apply, Esc to cancel", Style::default().fg(Color::DarkGray))),
        Line::from(""),
    ];
    
    // Field labels and values
    let fields = [
        ("Interface:", &app.static_ip_config.interface, true),  // true = selector
        ("IP Address:", &app.static_ip_config.ip_address, false),
        ("Netmask:", &app.static_ip_config.netmask, false),
        ("Gateway:", &app.static_ip_config.gateway, false),
        ("DNS Server:", &app.static_ip_config.dns, false),
    ];
    
    for (i, (label, value, is_selector)) in fields.iter().enumerate() {
        let is_selected = i == app.input_field_index;
        let label_style = Style::default().fg(Color::Gray);
        let value_style = if is_selected {
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(Color::White)
        };
        
        let cursor = if is_selected { "â–¶ " } else { "  " };
        
        // Show cursor indicator for text input fields
        let final_value = if *is_selector {
            if is_selected {
                format!("â—€ {} â–¶", value)
            } else {
                value.to_string()
            }
        } else if is_selected {
            // Show block cursor for selected text field
            if value.is_empty() {
                "â–ˆ (type here)".to_string()
            } else {
                format!("{}â–ˆ", value)
            }
        } else if value.is_empty() {
            "(not set)".to_string()
        } else {
            value.to_string()
        };
        
        lines.push(Line::from(vec![
            Span::styled(cursor, value_style),
            Span::styled(format!("{:<12}", label), label_style),
            Span::styled(final_value, value_style),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Type IP address (numbers and dots only)", Style::default().fg(Color::DarkGray))));
    
    let text = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title("Static IP"))
        .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn render_wifi_screen(f: &mut Frame, app: &App, area: Rect) {
    let mut lines = vec![
        Line::from(Span::styled("WiFi Configuration", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(Span::styled("Use Tab/â†‘â†“ to navigate, Left/Right for security type", Style::default().fg(Color::DarkGray))),
        Line::from(Span::styled("Press Enter to connect, Esc to cancel", Style::default().fg(Color::DarkGray))),
        Line::from(""),
    ];
    
    // Check for wireless interface
    let wireless_iface = find_wireless_interface();
    if wireless_iface.is_none() {
        lines.push(Line::from(Span::styled("âš  No wireless interface detected!", Style::default().fg(Color::Red))));
        lines.push(Line::from(""));
    } else {
        lines.push(Line::from(vec![
            Span::styled("Wireless Interface: ", Style::default().fg(Color::Gray)),
            Span::styled(wireless_iface.as_ref().unwrap(), Style::default().fg(Color::Cyan)),
        ]));
        lines.push(Line::from(""));
    }
    
    // Field labels and values
    let fields = [
        ("SSID:", &app.wifi_config.ssid, false),
        ("Password:", &mask_password(&app.wifi_config.password), false),
        ("Security:", &app.wifi_config.security, true), // true = selector
    ];
    
    for (i, (label, value, is_selector)) in fields.iter().enumerate() {
        let is_selected = i == app.input_field_index;
        let label_style = Style::default().fg(Color::Gray);
        let value_style = if is_selected {
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(Color::White)
        };
        
        let cursor = if is_selected { "â–¶ " } else { "  " };
        
        // Show cursor indicator for text input fields
        let final_value = if *is_selector {
            if is_selected {
                format!("â—€ {} â–¶", value)
            } else {
                value.to_string()
            }
        } else if is_selected {
            // Show block cursor for selected text field
            if value.is_empty() {
                "â–ˆ (type here)".to_string()
            } else {
                format!("{}â–ˆ", value)
            }
        } else if value.is_empty() {
            "(not set)".to_string()
        } else {
            value.to_string()
        };
        
        lines.push(Line::from(vec![
            Span::styled(cursor, value_style),
            Span::styled(format!("{:<12}", label), label_style),
            Span::styled(final_value, value_style),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Security options: WPA2, WPA3, OPEN", Style::default().fg(Color::DarkGray))));
    
    let text = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title("WiFi"))
        .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn handle_ssh_input(app: &mut App, key: KeyCode) {
    match key {
        KeyCode::Esc => {
            app.screen = Screen::Main;
        }
        KeyCode::Tab | KeyCode::Down => {
            // Move to next field (2 fields: enable/disable toggle, timer)
            app.input_field_index = (app.input_field_index + 1) % 2;
        }
        KeyCode::BackTab | KeyCode::Up => {
            // Move to previous field
            if app.input_field_index > 0 {
                app.input_field_index -= 1;
            } else {
                app.input_field_index = 1;
            }
        }
        KeyCode::Left => {
            if app.input_field_index == 1 {
                // Decrease timer (min 5 minutes)
                if app.ssh_config.timer_minutes > 5 {
                    app.ssh_config.timer_minutes -= 5;
                }
            }
        }
        KeyCode::Right => {
            if app.input_field_index == 1 {
                // Increase timer (max 120 minutes)
                if app.ssh_config.timer_minutes < 120 {
                    app.ssh_config.timer_minutes += 5;
                }
            }
        }
        KeyCode::Char(' ') | KeyCode::Enter => {
            if app.input_field_index == 0 {
                // Toggle SSH
                if app.ssh_config.enabled {
                    // Disable SSH
                    if disable_ssh().is_ok() {
                        app.ssh_config.enabled = false;
                        app.ssh_config.timer_start = None;
                        app.set_status("SSH access disabled");
                        app.success_message = Some("SSH disabled successfully".to_string());
                    } else {
                        app.error_message = Some("Failed to disable SSH".to_string());
                    }
                } else {
                    // Enable SSH with timer
                    if enable_ssh().is_ok() {
                        app.ssh_config.enabled = true;
                        app.ssh_config.timer_start = Some(std::time::Instant::now());
                        app.set_status(&format!("SSH enabled for {} minutes", app.ssh_config.timer_minutes));
                        app.success_message = Some(format!(
                            "SSH enabled - will auto-disable in {} minutes",
                            app.ssh_config.timer_minutes
                        ));
                    } else {
                        app.error_message = Some("Failed to enable SSH".to_string());
                    }
                }
            }
        }
        KeyCode::Char('e') | KeyCode::Char('E') => {
            // Quick enable SSH with timer
            if !app.ssh_config.enabled {
                if enable_ssh().is_ok() {
                    app.ssh_config.enabled = true;
                    app.ssh_config.timer_start = Some(std::time::Instant::now());
                    app.set_status(&format!("SSH enabled for {} minutes", app.ssh_config.timer_minutes));
                    app.success_message = Some(format!(
                        "SSH enabled - will auto-disable in {} minutes",
                        app.ssh_config.timer_minutes
                    ));
                }
            }
        }
        KeyCode::Char('d') | KeyCode::Char('D') => {
            // Quick disable SSH
            if app.ssh_config.enabled {
                if disable_ssh().is_ok() {
                    app.ssh_config.enabled = false;
                    app.ssh_config.timer_start = None;
                    app.set_status("SSH access disabled");
                    app.success_message = Some("SSH disabled".to_string());
                }
            }
        }
        KeyCode::Char('p') | KeyCode::Char('P') => {
            // Make SSH permanent (no timer)
            if app.ssh_config.enabled {
                app.ssh_config.timer_start = None;
                app.set_status("SSH set to permanent (no auto-disable)");
                app.success_message = Some("SSH timer disabled - connection is now permanent".to_string());
            }
        }
        _ => {}
    }
}

fn mask_password(password: &str) -> String {
    "*".repeat(password.len())
}

fn get_network_interfaces() -> Vec<(String, String, String)> {
    let mut interfaces = Vec::new();
    
    // Get list of interfaces
    if let Ok(output) = std::process::Command::new("ip")
        .args(["-o", "link", "show"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 2 {
                let iface = parts[1].trim_end_matches(':');
                // Skip loopback
                if iface == "lo" {
                    continue;
                }
                
                // Get IP address
                let ip = get_interface_ip(iface);
                
                // Get status (UP/DOWN)
                let status = if line.contains("state UP") { "UP" } else { "DOWN" };
                
                interfaces.push((iface.to_string(), ip, status.to_string()));
            }
        }
    }
    
    if interfaces.is_empty() {
        interfaces.push(("(no interfaces)".to_string(), "-".to_string(), "-".to_string()));
    }
    
    interfaces
}

fn get_interface_ip(iface: &str) -> String {
    if let Ok(output) = std::process::Command::new("ip")
        .args(["-4", "addr", "show", iface])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            if line.contains("inet ") {
                if let Some(ip) = line.split_whitespace().nth(1) {
                    return ip.to_string();
                }
            }
        }
    }
    "No IP".to_string()
}

fn render_ssh_screen(f: &mut Frame, app: &App, area: Rect) {
    let mut lines = vec![
        Line::from(Span::styled("ðŸ” SSH Access Configuration", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(Span::styled("Configure secure shell access to this host.", Style::default().fg(Color::DarkGray))),
        Line::from(Span::styled("SSH will auto-disable after timer expires for security.", Style::default().fg(Color::DarkGray))),
        Line::from(""),
    ];
    
    // Current status with prominent display
    let status_style = if app.ssh_config.enabled {
        Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)
    };
    
    let status_text = if app.ssh_config.enabled {
        "â— SSH ENABLED"
    } else {
        "â—‹ SSH DISABLED"
    };
    
    lines.push(Line::from(vec![
        Span::styled("Current Status: ", Style::default().fg(Color::Gray)),
        Span::styled(status_text, status_style),
    ]));
    
    // Show remaining time if timer is active
    if let Some(start) = app.ssh_config.timer_start {
        let elapsed_mins = start.elapsed().as_secs() / 60;
        let remaining = app.ssh_config.timer_minutes.saturating_sub(elapsed_mins as u32);
        lines.push(Line::from(vec![
            Span::styled("Time Remaining: ", Style::default().fg(Color::Gray)),
            Span::styled(format!("{} minutes", remaining), Style::default().fg(Color::Yellow)),
        ]));
    } else if app.ssh_config.enabled {
        lines.push(Line::from(vec![
            Span::styled("Timer: ", Style::default().fg(Color::Gray)),
            Span::styled("Permanent (no auto-disable)", Style::default().fg(Color::Cyan)),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("â”€".repeat(50), Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(""));
    
    // Enable/Disable toggle
    let toggle_selected = app.input_field_index == 0;
    let toggle_style = if toggle_selected {
        Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(Color::White)
    };
    
    let toggle_text = if app.ssh_config.enabled {
        "[  ENABLED  ] - Press Space to disable"
    } else {
        "[ DISABLED ] - Press Space to enable"
    };
    
    lines.push(Line::from(vec![
        Span::styled(if toggle_selected { "â–¶ " } else { "  " }, toggle_style),
        Span::styled("SSH Access: ", Style::default().fg(Color::Gray)),
        Span::styled(toggle_text, toggle_style),
    ]));
    
    lines.push(Line::from(""));
    
    // Timer setting
    let timer_selected = app.input_field_index == 1;
    let timer_style = if timer_selected {
        Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(Color::White)
    };
    
    lines.push(Line::from(vec![
        Span::styled(if timer_selected { "â–¶ " } else { "  " }, timer_style),
        Span::styled("Auto-Disable Timer: ", Style::default().fg(Color::Gray)),
        Span::styled(
            format!("â—€ {} minutes â–¶", app.ssh_config.timer_minutes),
            timer_style,
        ),
    ]));
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("â”€".repeat(50), Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Quick Actions:", Style::default().fg(Color::Cyan))));
    lines.push(Line::from(""));
    lines.push(Line::from("  E - Enable SSH with timer"));
    lines.push(Line::from("  D - Disable SSH immediately"));
    lines.push(Line::from("  P - Make SSH permanent (disable timer)"));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Use â†/â†’ to adjust timer (5-120 min), Tab to switch fields", Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(Span::styled("Press Esc to return to main menu", Style::default().fg(Color::Yellow))));
    
    let text = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title("SSH Configuration"))
        .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn render_cluster_screen(f: &mut Frame, app: &App, area: Rect) {
    let mut lines = vec![
        Line::from(Span::styled("ðŸ”— Cluster Registration", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(Span::styled("Generate a registration token for Quantix-vDC to add this host.", Style::default().fg(Color::DarkGray))),
        Line::from(Span::styled("The token is valid for 1 hour.", Style::default().fg(Color::DarkGray))),
        Line::from(""),
    ];
    
    // Current status with prominent display
    let status_style = match &app.cluster_config.status {
        ClusterStatus::Connected => Style::default().fg(Color::Green).add_modifier(Modifier::BOLD),
        ClusterStatus::Standalone => Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD),
        ClusterStatus::Joining => Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD),
        ClusterStatus::Disconnected => Style::default().fg(Color::Red).add_modifier(Modifier::BOLD),
        ClusterStatus::Error(_) => Style::default().fg(Color::Red).add_modifier(Modifier::BOLD),
    };
    
    let status_text = match &app.cluster_config.status {
        ClusterStatus::Connected => "â— CONNECTED TO CLUSTER",
        ClusterStatus::Standalone => "â—‹ STANDALONE MODE",
        ClusterStatus::Joining => "â— JOINING CLUSTER...",
        ClusterStatus::Disconnected => "â—¯ DISCONNECTED",
        ClusterStatus::Error(_) => "âœ– ERROR",
    };
    
    lines.push(Line::from(vec![
        Span::styled("Current Status: ", Style::default().fg(Color::Gray)),
        Span::styled(status_text, status_style),
    ]));
    
    // Show error details if any
    if let ClusterStatus::Error(ref msg) = app.cluster_config.status {
        lines.push(Line::from(vec![
            Span::styled("  Error: ", Style::default().fg(Color::Red)),
            Span::styled(msg.as_str(), Style::default().fg(Color::Red)),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("â”€".repeat(60), Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(""));
    
    // Show token generation section if not connected
    if !matches!(app.cluster_config.status, ClusterStatus::Connected) {
        lines.push(Line::from(Span::styled("ðŸ“‹ Registration Token", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD))));
        lines.push(Line::from(""));
        
        // Show generated token if available
        if let Some(ref token_info) = app.cluster_config.generated_token {
            let remaining = token_info.expires_at.saturating_duration_since(std::time::Instant::now());
            let remaining_mins = remaining.as_secs() / 60;
            
            if remaining_mins > 0 {
                // Token is valid - show it prominently
                lines.push(Line::from(vec![
                    Span::styled("  Token: ", Style::default().fg(Color::Gray)),
                    Span::styled(&token_info.token, Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
                ]));
                lines.push(Line::from(""));
                lines.push(Line::from(vec![
                    Span::styled("  Expires in: ", Style::default().fg(Color::Gray)),
                    Span::styled(format!("{} minutes", remaining_mins), Style::default().fg(Color::Yellow)),
                ]));
                lines.push(Line::from(""));
                lines.push(Line::from(Span::styled("  Copy this token and enter it in Quantix-vDC when adding this host.", Style::default().fg(Color::DarkGray))));
            } else {
                // Token expired
                lines.push(Line::from(vec![
                    Span::styled("  Token: ", Style::default().fg(Color::Gray)),
                    Span::styled("EXPIRED", Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
                ]));
                lines.push(Line::from(""));
                lines.push(Line::from(Span::styled("  Press G to generate a new token.", Style::default().fg(Color::DarkGray))));
            }
        } else {
            // No token generated yet
            lines.push(Line::from(Span::styled("  No token generated yet.", Style::default().fg(Color::DarkGray))));
            lines.push(Line::from(""));
            lines.push(Line::from(Span::styled("  Press G to generate a registration token.", Style::default().fg(Color::DarkGray))));
        }
        
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled("â”€".repeat(60), Style::default().fg(Color::DarkGray))));
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled("Actions:", Style::default().fg(Color::Cyan))));
        lines.push(Line::from(""));
        lines.push(Line::from(vec![
            Span::styled("  G", Style::default().fg(Color::White).add_modifier(Modifier::BOLD)),
            Span::styled(" - Generate Registration Token (valid for 1 hour)", Style::default().fg(Color::White)),
        ]));
        lines.push(Line::from(vec![
            Span::styled("  R", Style::default().fg(Color::White).add_modifier(Modifier::BOLD)),
            Span::styled(" - Refresh Status", Style::default().fg(Color::White)),
        ]));
    } else {
        // Connected - show leave option
        lines.push(Line::from(Span::styled("Cluster Actions:", Style::default().fg(Color::Cyan))));
        lines.push(Line::from(""));
        lines.push(Line::from(vec![
            Span::styled("  L", Style::default().fg(Color::White).add_modifier(Modifier::BOLD)),
            Span::styled(" - Leave Cluster (return to standalone)", Style::default().fg(Color::White)),
        ]));
        lines.push(Line::from(vec![
            Span::styled("  R", Style::default().fg(Color::White).add_modifier(Modifier::BOLD)),
            Span::styled(" - Refresh Status", Style::default().fg(Color::White)),
        ]));
    }
    
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("â”€".repeat(60), Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("How to add this host to Quantix-vDC:", Style::default().fg(Color::Cyan))));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("  1. Generate a token using G", Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(Span::styled("  2. In vDC UI, go to Hosts â†’ Add Host", Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(Span::styled("  3. Enter this host's IP and the token", Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(Span::styled("  4. Select a cluster and confirm", Style::default().fg(Color::DarkGray))));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled("Press Esc to return to main menu", Style::default().fg(Color::Yellow))));
    
    let text = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title("Cluster Registration"))
        .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn handle_cluster_input(app: &mut App, key: KeyCode) {
    match key {
        KeyCode::Esc => {
            app.screen = Screen::Main;
        }
        KeyCode::Char('g') | KeyCode::Char('G') => {
            // Generate registration token
            if !matches!(app.cluster_config.status, ClusterStatus::Connected) {
                generate_registration_token(app);
            }
        }
        KeyCode::Char('l') | KeyCode::Char('L') => {
            if matches!(app.cluster_config.status, ClusterStatus::Connected) {
                attempt_leave_cluster(app);
            }
        }
        KeyCode::Char('r') | KeyCode::Char('R') => {
            // Refresh status
            app.cluster_config.status = get_cluster_status();
            // Also check if current token is still valid
            if let Some(ref token_info) = app.cluster_config.generated_token {
                if std::time::Instant::now() > token_info.expires_at {
                    app.cluster_config.generated_token = None;
                }
            }
            app.success_message = Some("Status refreshed".to_string());
        }
        _ => {}
    }
}

/// Generate a new registration token by calling the node daemon API
fn generate_registration_token(app: &mut App) {
    use std::process::Stdio;
    
    app.set_status("Generating registration token...");
    
    // First check if curl is available
    let curl_check = std::process::Command::new("which")
        .arg("curl")
        .output();
    
    if curl_check.is_err() || !curl_check.unwrap().status.success() {
        // Try wget as fallback
        app.error_message = Some("curl not found. Please ensure curl is installed.".to_string());
        return;
    }
    
    // Check if node daemon is running
    let daemon_check = std::process::Command::new("pgrep")
        .args(["-x", "qx-node"])
        .output();
    
    if daemon_check.is_err() || !daemon_check.unwrap().status.success() {
        app.error_message = Some("Node daemon (qx-node) is not running. Try: rc-service quantix-node start".to_string());
        return;
    }
    
    // Call the local node daemon API to generate a token
    let result = std::process::Command::new("curl")
        .args([
            "-s", "-k", "--max-time", "5",
            "-X", "POST",
            "https://127.0.0.1:8443/api/v1/registration/token"
        ])
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output();
    
    match result {
        Ok(output) => {
            if output.status.success() {
                let stdout = String::from_utf8_lossy(&output.stdout);
                // Parse the JSON response to extract the token
                // Looking for: {"token":"QUANTIX-XXXX-XXXX-XXXX", ...}
                if let Some(token) = extract_json_field(&stdout, "token") {
                    app.cluster_config.generated_token = Some(GeneratedToken {
                        token: token.clone(),
                        expires_at: std::time::Instant::now() + std::time::Duration::from_secs(3600),
                    });
                    app.success_message = Some(format!("Token generated: {}", token));
                } else if stdout.contains("\"error\"") {
                    let error_msg = extract_json_field(&stdout, "message")
                        .unwrap_or_else(|| "Unknown error".to_string());
                    app.error_message = Some(format!("API error: {}", error_msg));
                } else if stdout.is_empty() {
                    app.error_message = Some("Empty response from node daemon - is it running?".to_string());
                } else {
                    app.error_message = Some(format!("Unexpected response: {}", stdout.chars().take(100).collect::<String>()));
                }
            } else {
                let stderr = String::from_utf8_lossy(&output.stderr);
                if stderr.contains("Connection refused") {
                    app.error_message = Some("Connection refused - node daemon not listening on port 8443".to_string());
                } else {
                    app.error_message = Some(format!("API request failed: {}", stderr.chars().take(100).collect::<String>()));
                }
            }
        }
        Err(e) => {
            let error_str = e.to_string();
            if error_str.contains("No such file") {
                app.error_message = Some("curl command not found. Install with: apk add curl".to_string());
            } else {
                app.error_message = Some(format!("Failed to execute curl: {}", error_str));
            }
        }
    }
}

/// Extract a field value from a JSON string (simple parser)
fn extract_json_field(json: &str, field: &str) -> Option<String> {
    // Look for "field":"value" pattern
    let pattern = format!("\"{}\":\"", field);
    if let Some(start) = json.find(&pattern) {
        let value_start = start + pattern.len();
        if let Some(end) = json[value_start..].find('"') {
            return Some(json[value_start..value_start + end].to_string());
        }
    }
    None
}

fn attempt_leave_cluster(app: &mut App) {
    app.set_status("Leaving cluster...");
    
    match leave_cluster_api() {
        Ok(_) => {
            app.cluster_config.status = ClusterStatus::Standalone;
            app.cluster_config.control_plane_address.clear();
            app.cluster_config.registration_token.clear();
            app.success_message = Some("Left cluster. Now in standalone mode.".to_string());
        }
        Err(e) => {
            app.error_message = Some(format!("Failed to leave cluster: {}", e));
        }
    }
}

/// Get current cluster status by checking the cluster marker file and calling the API
fn get_cluster_status() -> ClusterStatus {
    // Method 1: Try to call the local node daemon API first (most accurate)
    // The node daemon runs on localhost:8443
    match std::process::Command::new("curl")
        .args(["-s", "-k", "--max-time", "2", "https://127.0.0.1:8443/api/v1/cluster/status"])
        .output()
    {
        Ok(output) => {
            if output.status.success() {
                let stdout = String::from_utf8_lossy(&output.stdout);
                // Parse JSON response - look for "joined":true (must be exactly true, not just present)
                if stdout.contains("\"joined\":true") {
                    // Also check if status is connected vs pending
                    if stdout.contains("\"status\":\"pending_restart\"") {
                        return ClusterStatus::Joining;
                } else if stdout.contains("\"status\":\"disconnected\"") {
                        return ClusterStatus::Disconnected;
                    }
                    return ClusterStatus::Connected;
                } else if stdout.contains("\"joined\":false") {
                    return ClusterStatus::Standalone;
                }
            }
        }
        Err(_) => {
            // Node daemon not running, fall through to file-based check
        }
    }
    
    // Method 2: Check the cluster marker file (fallback if API unavailable)
    if let Ok(content) = std::fs::read_to_string("/quantix/cluster.yaml") {
        // Must have a valid control_plane address to be considered joined
        let has_control_plane = content.lines().any(|line| {
            let trimmed = line.trim();
            if trimmed.starts_with("control_plane:") {
                let value = trimmed.trim_start_matches("control_plane:").trim().trim_matches('"');
                !value.is_empty() && value != "null" && !value.contains("localhost")
            } else {
                false
            }
        });
        
        if has_control_plane {
            return ClusterStatus::Connected;
        }
    }
    
    // Method 3: Check the node config for control_plane settings (legacy)
    if let Ok(content) = std::fs::read_to_string("/etc/limiquantix/node.yaml") {
        // Must have both control_plane: section AND a valid address
        let mut in_control_plane = false;
        for line in content.lines() {
            let trimmed = line.trim();
            if trimmed == "control_plane:" {
                in_control_plane = true;
            } else if in_control_plane && trimmed.starts_with("address:") {
                let addr = trimmed.trim_start_matches("address:").trim().trim_matches('"');
                // Must be a real address, not localhost or empty
                if !addr.is_empty() && !addr.contains("localhost") && addr != "http://localhost:8080" {
                    return ClusterStatus::Connected;
                }
            } else if !line.starts_with(' ') && !line.starts_with('\t') && !trimmed.is_empty() && trimmed != "control_plane:" {
                in_control_plane = false;
            }
        }
    }
    
    // Default: standalone mode
    ClusterStatus::Standalone
}

/// Call the node daemon API to leave a cluster
fn leave_cluster_api() -> Result<(), String> {
    use std::process::Stdio;
    
    let result = std::process::Command::new("curl")
        .args([
            "-s", "-k", "--max-time", "10",
            "-X", "POST",
            "https://127.0.0.1:8443/api/v1/cluster/leave"
        ])
        .stdout(Stdio::piped())
        .stderr(Stdio::null())
        .output();
    
    match result {
        Ok(output) => {
            if output.status.success() {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if stdout.contains("\"error\"") {
                    Err(stdout.to_string())
                } else {
                    Ok(())
                }
            } else {
                Err("API request failed".to_string())
            }
        }
        Err(e) => Err(format!("Failed to connect to node daemon: {}", e)),
    }
}

fn render_diagnostics_screen(f: &mut Frame, app: &App, area: Rect) {
    let cpus = app.system.cpus();
    let cpu_count = cpus.len();
    let total_mem = app.system.total_memory();
    let used_mem = app.system.used_memory();

    let text = vec![
        Line::from(Span::styled("System Diagnostics", Style::default().add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from(format!("CPU Cores: {}", cpu_count)),
        Line::from(format!("Total Memory: {}", format_bytes(total_mem))),
        Line::from(format!("Used Memory: {}", format_bytes(used_mem))),
        Line::from(format!("Free Memory: {}", format_bytes(total_mem - used_mem))),
        Line::from(""),
        Line::from(Span::styled("Press Esc to return", Style::default().fg(Color::Yellow))),
    ];

    let diag = Paragraph::new(text)
        .block(Block::default().borders(Borders::ALL).title("Diagnostics"))
        .wrap(Wrap { trim: true });
    f.render_widget(diag, area);
}

fn render_power_screen(f: &mut Frame, area: Rect) {
    let text = Paragraph::new(vec![
        Line::from(Span::styled("âš ï¸  Power Options", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD))),
        Line::from(""),
        Line::from("This will affect all running VMs!"),
        Line::from(""),
        Line::from("R - Reboot"),
        Line::from("S - Shutdown"),
        Line::from(""),
        Line::from(Span::styled("Press Esc to cancel", Style::default().fg(Color::Yellow))),
    ])
    .block(Block::default().borders(Borders::ALL).title("Shutdown / Reboot"))
    .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn render_placeholder_screen(f: &mut Frame, area: Rect, name: &str) {
    let text = Paragraph::new(vec![
        Line::from(format!("{} Screen", name)),
        Line::from(""),
        Line::from("This feature is not yet implemented."),
        Line::from(""),
        Line::from(Span::styled("Press Esc to return", Style::default().fg(Color::Yellow))),
    ])
    .block(Block::default().borders(Borders::ALL).title(name))
    .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

fn render_factory_reset_screen(f: &mut Frame, area: Rect) {
    let text = Paragraph::new(vec![
        Line::from(""),
        Line::from(Span::styled(
            "  âš ï¸  FACTORY RESET  âš ï¸",
            Style::default().fg(Color::Red).add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
        Line::from(""),
        Line::from(Span::styled(
            "  This will reset ALL system configuration to defaults!",
            Style::default().fg(Color::Yellow),
        )),
        Line::from(""),
        Line::from("  The following will be DELETED:"),
        Line::from(Span::styled("    â€¢ Network configuration (static IP, WiFi)", Style::default().fg(Color::White))),
        Line::from(Span::styled("    â€¢ SSH keys and authorized_keys", Style::default().fg(Color::White))),
        Line::from(Span::styled("    â€¢ TLS certificates", Style::default().fg(Color::White))),
        Line::from(Span::styled("    â€¢ Cluster registration", Style::default().fg(Color::White))),
        Line::from(Span::styled("    â€¢ Node daemon configuration", Style::default().fg(Color::White))),
        Line::from(""),
        Line::from(Span::styled(
            "  â— Virtual machines and storage data will NOT be deleted.",
            Style::default().fg(Color::Green),
        )),
        Line::from(""),
        Line::from(""),
        Line::from(Span::styled(
            "  The system will REBOOT after reset.",
            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
        Line::from(""),
        Line::from(vec![
            Span::styled("  Press ", Style::default().fg(Color::White)),
            Span::styled("Y", Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
            Span::styled(" to confirm reset, ", Style::default().fg(Color::White)),
            Span::styled("N", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
            Span::styled(" or ", Style::default().fg(Color::White)),
            Span::styled("Esc", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
            Span::styled(" to cancel", Style::default().fg(Color::White)),
        ]),
    ])
    .block(
        Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(Color::Red))
            .title(Span::styled(
                " âš ï¸ Factory Reset Confirmation ",
                Style::default().fg(Color::Red).add_modifier(Modifier::BOLD),
            )),
    )
    .wrap(Wrap { trim: true });
    f.render_widget(text, area);
}

/// Perform factory reset - delete all configuration and return to defaults
fn perform_factory_reset() {
    use std::process::Stdio;
    
    // Files and directories to delete
    let config_paths = [
        // Network configuration
        "/etc/network/interfaces",
        "/etc/wpa_supplicant/wpa_supplicant.conf",
        "/etc/resolv.conf",
        // TLS certificates
        "/etc/limiquantix/certs/server.key",
        "/etc/limiquantix/certs/server.crt",
        "/etc/limiquantix/certs/ca.crt",
        // SSH configuration (keys only, not config)
        "/root/.ssh/authorized_keys",
        "/etc/ssh/ssh_host_rsa_key",
        "/etc/ssh/ssh_host_rsa_key.pub",
        "/etc/ssh/ssh_host_ecdsa_key",
        "/etc/ssh/ssh_host_ecdsa_key.pub",
        "/etc/ssh/ssh_host_ed25519_key",
        "/etc/ssh/ssh_host_ed25519_key.pub",
        // Node daemon configuration
        "/etc/limiquantix/node.yaml",
        "/etc/limiquantix/cluster.yaml",
        // Hostname (will regenerate on boot)
        "/etc/hostname",
        // First boot marker (trigger firstboot script again)
        "/etc/limiquantix/.firstboot-done",
    ];
    
    for path in config_paths {
        let _ = std::fs::remove_file(path);
    }
    
    // Remove any custom network interface configs
    if let Ok(entries) = std::fs::read_dir("/etc/network/interfaces.d") {
        for entry in entries.flatten() {
            let _ = std::fs::remove_file(entry.path());
        }
    }
    
    // Create default network configuration (DHCP on all interfaces)
    let default_network = r#"# Default network configuration - DHCP on all interfaces
auto lo
iface lo inet loopback

# DHCP on primary interface (configured by quantix-network service)
"#;
    let _ = std::fs::write("/etc/network/interfaces", default_network);
    
    // Create a marker file so firstboot knows to run
    let _ = std::fs::remove_file("/etc/limiquantix/.configured");
    
    // Stop services before they might access deleted configs
    let _ = std::process::Command::new("rc-service")
        .args(["quantix-node", "stop"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    let _ = std::process::Command::new("rc-service")
        .args(["sshd", "stop"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
    
    // Sync filesystem to ensure changes are written
    let _ = std::process::Command::new("sync").output();
}

// Helper functions

/// Read the Quantix-OS version from VERSION file
/// Checks multiple locations in order of priority
fn get_os_version() -> String {
    // Priority order of version file locations
    let version_paths = [
        "/quantix/VERSION",           // Installed system (on QUANTIX-A/B partition)
        "/mnt/cdrom/quantix/VERSION", // Boot from ISO
        "/cdrom/quantix/VERSION",     // Alternative ISO mount
        "/etc/quantix-version",       // Legacy location
        "/usr/share/quantix/VERSION", // Distribution package location
    ];
    
    for path in &version_paths {
        if let Ok(content) = std::fs::read_to_string(path) {
            let version = content.trim().to_string();
            if !version.is_empty() {
                return version;
            }
        }
    }
    
    // Try to get version from BUILD_INFO.json in Host UI
    if let Ok(content) = std::fs::read_to_string("/usr/share/quantix-host-ui/BUILD_INFO.json") {
        // Simple JSON parsing - look for "version": "X.Y.Z"
        if let Some(start) = content.find("\"version\"") {
            let rest = &content[start..];
            if let Some(colon) = rest.find(':') {
                let after_colon = &rest[colon + 1..];
                // Find the quoted value
                if let Some(quote1) = after_colon.find('"') {
                    let after_quote1 = &after_colon[quote1 + 1..];
                    if let Some(quote2) = after_quote1.find('"') {
                        return after_quote1[..quote2].to_string();
                    }
                }
            }
        }
    }
    
    // Fallback to environment variable (set during build)
    if let Ok(version) = std::env::var("QUANTIX_VERSION") {
        return version;
    }
    
    // Default fallback
    "0.0.1".to_string()
}

fn get_primary_ip() -> String {
    // Method 1: Use `ip route get` to find the source IP for internet connectivity
    if let Ok(output) = std::process::Command::new("ip")
        .args(["route", "get", "8.8.8.8"])
        .output()
    {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            // Parse output like: "8.8.8.8 via 192.168.0.1 dev wlan0 src 192.168.0.32 uid 0"
            for line in stdout.lines() {
                if line.contains("src") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    for (i, part) in parts.iter().enumerate() {
                        if *part == "src" && i + 1 < parts.len() {
                            let ip = parts[i + 1];
                            if !ip.is_empty() && ip != "0.0.0.0" {
                                return ip.to_string();
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Method 2: Try common interfaces (expanded list including WiFi)
    let interfaces = [
        "eth0", "eth1", 
        "ens3", "ens18", "ens33", "ens160", "ens192", "ens224",
        "enp0s3", "enp0s8", "enp0s25", 
        "eno1", "eno2", 
        "em1", "em2",
        "wlan0", "wlan1", "wlp2s0", "wlp3s0",  // WiFi interfaces
        "bond0", "br0",
    ];
    
    for iface in interfaces {
        if let Ok(content) = std::process::Command::new("ip")
            .args(["-4", "addr", "show", iface])
            .output()
        {
            let stdout = String::from_utf8_lossy(&content.stdout);
            for line in stdout.lines() {
                if line.contains("inet ") {
                    if let Some(ip) = line.split_whitespace().nth(1) {
                        let ip = ip.split('/').next().unwrap_or("0.0.0.0");
                        if !ip.is_empty() && ip != "0.0.0.0" && ip != "127.0.0.1" {
                            return ip.to_string();
                    }
                }
            }
        }
    }
    }
    
    // Method 3: Get any non-loopback interface with an IP
    if let Ok(output) = std::process::Command::new("ip")
        .args(["-4", "-o", "addr", "show"])
        .output()
    {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            for line in stdout.lines() {
                if !line.contains("lo") && line.contains("inet ") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    // Format: "2: eth0    inet 192.168.0.32/24 brd ..."
                    if parts.len() >= 4 {
                        let ip = parts[3].split('/').next().unwrap_or("");
                        if !ip.is_empty() && ip != "127.0.0.1" {
                            return ip.to_string();
                        }
                    }
                }
            }
        }
    }
    
    "0.0.0.0".to_string()
}

fn format_uptime(seconds: u64) -> String {
    let days = seconds / 86400;
    let hours = (seconds % 86400) / 3600;
    if days > 0 {
        format!("{}d {}h", days, hours)
    } else {
        format!("{}h {}m", hours, (seconds % 3600) / 60)
    }
}

/// Create a text-based usage bar like [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]
fn create_usage_bar(percent: u16, width: usize) -> String {
    let filled = ((percent as usize) * width / 100).min(width);
    let empty = width - filled;
    format!("[{}{}]", "â–ˆ".repeat(filled), "â–‘".repeat(empty))
}

/// Get color based on usage percentage (green < 70, yellow 70-90, red > 90)
fn get_usage_color(percent: u16) -> Style {
    if percent >= 90 {
        Style::default().fg(Color::Red)
    } else if percent >= 70 {
        Style::default().fg(Color::Yellow)
    } else {
        Style::default().fg(Color::Green)
    }
}

fn format_bytes(bytes: u64) -> String {
    const GB: u64 = 1024 * 1024 * 1024;
    const MB: u64 = 1024 * 1024;
    if bytes >= GB {
        format!("{:.1} GB", bytes as f64 / GB as f64)
    } else {
        format!("{:.1} MB", bytes as f64 / MB as f64)
    }
}

/// Get storage info for main partitions (mount_point, used_bytes, total_bytes)
fn get_storage_info() -> Vec<(String, u64, u64)> {
    use sysinfo::Disks;
    
    let disks = Disks::new_with_refreshed_list();
    let mut storage: Vec<(String, u64, u64)> = Vec::new();
    
    for disk in disks.list() {
        let mount_point = disk.mount_point().to_string_lossy().to_string();
        
        // Skip system/virtual partitions
        if mount_point == "/" 
            || mount_point == "/boot" 
            || mount_point == "/boot/efi"
            || mount_point.starts_with("/sys")
            || mount_point.starts_with("/proc")
            || mount_point.starts_with("/dev")
            || mount_point.starts_with("/run")
            || mount_point.starts_with("/snap")
        {
            // Include root only if no other storage is found
            if mount_point == "/" {
                let total = disk.total_space();
                let available = disk.available_space();
                let used = total.saturating_sub(available);
                storage.push((mount_point, used, total));
            }
            continue;
        }
        
        let total = disk.total_space();
        let available = disk.available_space();
        let used = total.saturating_sub(available);
        
        // Only include partitions > 1GB
        if total > 1024 * 1024 * 1024 {
            storage.push((mount_point, used, total));
        }
    }
    
    // Sort by mount point for consistent display
    storage.sort_by(|a, b| a.0.cmp(&b.0));
    
    // If we found no partitions, include root
    if storage.is_empty() {
        for disk in disks.list() {
            if disk.mount_point().to_string_lossy() == "/" {
                let total = disk.total_space();
                let available = disk.available_space();
                let used = total.saturating_sub(available);
                storage.push(("/".to_string(), used, total));
                break;
            }
        }
    }
    
    storage
}

fn get_vm_count() -> i32 {
    std::process::Command::new("virsh")
        .args(["list", "--all", "--name"])
        .output()
        .map(|o| {
            String::from_utf8_lossy(&o.stdout)
                .lines()
                .filter(|l| !l.trim().is_empty())
                .count() as i32
        })
        .unwrap_or(0)
}

fn is_ssh_enabled() -> bool {
    // Check if sshd process is running instead of using rc-service (faster, non-blocking)
    std::process::Command::new("pgrep")
        .args(["-x", "sshd"])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

fn enable_ssh() -> Result<()> {
    use std::process::Stdio;
    // Use spawn() to avoid blocking the TUI
    std::process::Command::new("rc-service")
        .args(["sshd", "start"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .stdin(Stdio::null())
        .spawn()?;
    Ok(())
}

fn disable_ssh() -> Result<()> {
    use std::process::Stdio;
    // Use spawn() to avoid blocking the TUI
    std::process::Command::new("rc-service")
        .args(["sshd", "stop"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .stdin(Stdio::null())
        .spawn()?;
    Ok(())
}

fn run_dhcp_all() {
    use std::process::Stdio;
    
    // Spawn a background thread to avoid blocking the TUI at all
    std::thread::spawn(|| {
        // Get all interfaces
    if let Ok(output) = std::process::Command::new("ip")
        .args(["-o", "link", "show"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 2 {
                let iface = parts[1].trim_end_matches(':');
                    // Skip loopback and virtual interfaces
                    if iface == "lo" || iface.starts_with("vir") || iface.starts_with("br-") {
                    continue;
                }
                
                    // Bring interface up
                let _ = std::process::Command::new("ip")
                    .args(["link", "set", iface, "up"])
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                        .output(); // Use output() here - it's fast
                
                    // Kill any existing udhcpc for this interface
                let _ = std::process::Command::new("pkill")
                    .args(["-f", &format!("udhcpc.*{}", iface)])
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                        .output();
                
                    // Run udhcpc in background mode (-b) with timeout
                    // -b = background after getting IP
                    // -t 2 = 2 retries
                    // -T 3 = 3 second timeout per retry
                let _ = std::process::Command::new("udhcpc")
                        .args(["-i", iface, "-b", "-t", "2", "-T", "3", "-S"])
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                    .spawn();
            }
        }
    }
    });
}

fn restart_network() {
    use std::process::Stdio;
    
    // Spawn a background thread to avoid blocking the TUI
    std::thread::spawn(|| {
        // Try quantix-network service first (our custom service)
        let result = std::process::Command::new("rc-service")
            .args(["quantix-network", "restart"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .output();
        
        // If that fails, try the standard networking service
        if result.is_err() || !result.unwrap().status.success() {
    let _ = std::process::Command::new("rc-service")
        .args(["networking", "restart"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
                .output();
        }
    });
}

fn configure_wifi() {
    use std::process::Stdio;
    // Start wpa_supplicant if not running
    let _ = std::process::Command::new("rc-service")
        .args(["wpa_supplicant", "start"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output();
}
