// Package server provides the HTTP/Connect-RPC server for the control plane.
package server

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"go.uber.org/zap"
)

// AgentDownloadHandler handles requests for downloading the Quantix Agent.
type AgentDownloadHandler struct {
	logger    *zap.Logger
	agentDir  string // Directory containing agent binaries
	agentURL  string // External URL to proxy downloads from (fallback)
}

// NewAgentDownloadHandler creates a new agent download handler.
func NewAgentDownloadHandler(logger *zap.Logger) *AgentDownloadHandler {
	// Look for agent binaries in common locations
	agentDir := findAgentDir()
	
	return &AgentDownloadHandler{
		logger:   logger,
		agentDir: agentDir,
		// Fallback to GitHub releases if local binaries not found
		agentURL: "https://github.com/Quantix-KVM/LimiQuantix/releases/download",
	}
}

// findAgentDir looks for agent binaries in common locations.
func findAgentDir() string {
	// Check common locations
	locations := []string{
		"/opt/quantix-kvm/agent",           // Production install
		"/var/lib/quantix-kvm/agent",       // Alternative location
		"./agent-binaries",                 // Development
		"../agent/target/release",          // Build output
	}
	
	for _, loc := range locations {
		if info, err := os.Stat(loc); err == nil && info.IsDir() {
			return loc
		}
	}
	
	return ""
}

// ServeHTTP handles agent download requests.
// Routes:
//   GET /api/agent/linux/amd64       - Linux AMD64 binary
//   GET /api/agent/linux/arm64       - Linux ARM64 binary
//   GET /api/agent/linux/amd64.deb   - Debian package
//   GET /api/agent/linux/amd64.rpm   - RPM package
//   GET /api/agent/windows/amd64     - Windows AMD64 binary
//   GET /api/agent/windows/amd64.msi - Windows MSI installer
//   GET /api/agent/install.sh        - Linux installer script
//   GET /api/agent/version           - Current agent version
func (h *AgentDownloadHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse the path: /api/agent/{os}/{arch}[.ext]
	path := strings.TrimPrefix(r.URL.Path, "/api/agent/")
	
	h.logger.Debug("Agent download request",
		zap.String("path", path),
		zap.String("remote_addr", r.RemoteAddr),
	)

	switch {
	case path == "version":
		h.handleVersion(w, r)
	case path == "install.sh":
		h.handleInstallScript(w, r)
	case path == "install.ps1":
		h.handleWindowsInstallScript(w, r)
	default:
		h.handleBinaryDownload(w, r, path)
	}
}

// handleVersion returns the current agent version.
func (h *AgentDownloadHandler) handleVersion(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	// Read version from file or use default
	version := "0.1.0"
	fmt.Fprintf(w, `{"version":"%s","download_url":"/api/agent/"}`, version)
}

// handleInstallScript returns a shell script that auto-installs the agent.
func (h *AgentDownloadHandler) handleInstallScript(w http.ResponseWriter, r *http.Request) {
	// Get the control plane URL from the request
	scheme := "http"
	if r.TLS != nil {
		scheme = "https"
	}
	baseURL := fmt.Sprintf("%s://%s", scheme, r.Host)

	script := fmt.Sprintf(`#!/bin/bash
# Quantix Agent Installer
# Generated by LimiQuantix Control Plane
# Usage: curl -sSL %s/api/agent/install.sh | sudo bash

set -e

AGENT_VERSION="0.1.0"
CONTROL_PLANE_URL="%s"

echo "[Quantix] Installing Quantix Agent v${AGENT_VERSION}..."

# Detect architecture
ARCH=$(uname -m)
case $ARCH in
    x86_64) ARCH="amd64" ;;
    aarch64) ARCH="arm64" ;;
    *) echo "[Quantix] Unsupported architecture: $ARCH"; exit 1 ;;
esac

echo "[Quantix] Detected architecture: $ARCH"

# Detect OS
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS_ID="${ID}"
else
    echo "[Quantix] Cannot detect OS"
    OS_ID="unknown"
fi

echo "[Quantix] Detected OS: $OS_ID"

# Install based on OS
# Note: -k flag allows self-signed certificates (common in lab environments)
case "${OS_ID}" in
    ubuntu|debian)
        echo "[Quantix] Installing via .deb package..."
        TEMP_DEB=$(mktemp)
        curl -fsSLk "${CONTROL_PLANE_URL}/api/agent/linux/deb/${ARCH}" -o "$TEMP_DEB"
        dpkg -i "$TEMP_DEB" || apt-get install -f -y
        rm -f "$TEMP_DEB"
        ;;
        
    rhel|centos|fedora|rocky|almalinux)
        echo "[Quantix] Installing via .rpm package..."
        TEMP_RPM=$(mktemp)
        curl -fsSLk "${CONTROL_PLANE_URL}/api/agent/linux/rpm/${ARCH}" -o "$TEMP_RPM"
        rpm -ivh "$TEMP_RPM" || yum localinstall -y "$TEMP_RPM" || dnf install -y "$TEMP_RPM"
        rm -f "$TEMP_RPM"
        ;;
        
    *)
        echo "[Quantix] Installing via binary..."
        curl -fsSLk "${CONTROL_PLANE_URL}/api/agent/linux/binary/${ARCH}" -o /usr/local/bin/quantix-kvm-agent
        chmod +x /usr/local/bin/quantix-kvm-agent
        
        # Create systemd service
        cat > /etc/systemd/system/quantix-kvm-agent.service << 'EOF'
[Unit]
Description=Quantix KVM Guest Agent
After=network.target
ConditionVirtualization=vm

[Service]
Type=simple
ExecStart=/usr/local/bin/quantix-kvm-agent
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        ;;
esac

# Enable and start the service
systemctl enable quantix-kvm-agent
systemctl start quantix-kvm-agent

# Create hook directories for snapshot quiescing
mkdir -p /etc/quantix-kvm/pre-freeze.d
mkdir -p /etc/quantix-kvm/post-thaw.d

echo "[Quantix] Agent installed and running!"
echo "[Quantix] Check status with: systemctl status quantix-kvm-agent"
`, baseURL, baseURL)

	w.Header().Set("Content-Type", "text/x-shellscript")
	w.Header().Set("Content-Disposition", "attachment; filename=install.sh")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(script))
}

// handleWindowsInstallScript returns a PowerShell script for Windows.
func (h *AgentDownloadHandler) handleWindowsInstallScript(w http.ResponseWriter, r *http.Request) {
	scheme := "http"
	if r.TLS != nil {
		scheme = "https"
	}
	baseURL := fmt.Sprintf("%s://%s", scheme, r.Host)

	// Using concatenation to avoid backtick escaping issues
	script := "# Quantix Agent Installer for Windows\n"
	script += fmt.Sprintf("# Usage: Invoke-WebRequest -Uri \"%s/api/agent/install.ps1\" | Invoke-Expression\n\n", baseURL)
	script += "$AgentVersion = \"0.1.0\"\n"
	script += fmt.Sprintf("$ControlPlaneURL = \"%s\"\n\n", baseURL)
	script += "Write-Host \"[Quantix] Installing Quantix Agent v$AgentVersion...\"\n\n"
	script += "# Detect architecture\n"
	script += "$Arch = if ([Environment]::Is64BitOperatingSystem) { \"amd64\" } else { \"386\" }\n"
	script += "Write-Host \"[Quantix] Detected architecture: $Arch\"\n\n"
	script += "# Download MSI installer\n"
	script += "$TempMSI = Join-Path $env:TEMP \"quantix-agent.msi\"\n"
	script += "Write-Host \"[Quantix] Downloading installer...\"\n"
	script += "Invoke-WebRequest -Uri \"$ControlPlaneURL/api/agent/windows/$Arch.msi\" -OutFile $TempMSI\n\n"
	script += "# Install silently\n"
	script += "Write-Host \"[Quantix] Installing...\"\n"
	script += "Start-Process msiexec.exe -Wait -ArgumentList \"/i `\"$TempMSI`\" /quiet /norestart\"\n\n"
	script += "# Cleanup\n"
	script += "Remove-Item $TempMSI -Force\n\n"
	script += "# Start the service\n"
	script += "Start-Service -Name \"QuantixAgent\"\n\n"
	script += "Write-Host \"[Quantix] Agent installed and running!\"\n"
	script += "Write-Host \"[Quantix] Check status with: Get-Service QuantixAgent\"\n"

	w.Header().Set("Content-Type", "text/plain")
	w.Header().Set("Content-Disposition", "attachment; filename=install.ps1")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(script))
}

// handleBinaryDownload serves the actual agent binary.
// Supports both old format (linux/amd64.deb) and new format (linux/deb/amd64)
func (h *AgentDownloadHandler) handleBinaryDownload(w http.ResponseWriter, r *http.Request, path string) {
	// Parse path: supports two formats:
	// Old: linux/amd64, linux/amd64.deb, windows/amd64.msi
	// New: linux/binary/amd64, linux/deb/amd64, linux/rpm/amd64
	parts := strings.Split(path, "/")
	
	var osType, arch, ext string
	
	if len(parts) == 3 {
		// New format: linux/deb/amd64
		osType = parts[0]
		pkgType := parts[1]
		arch = parts[2]
		
		switch pkgType {
		case "binary":
			ext = ""
		case "deb":
			ext = ".deb"
		case "rpm":
			ext = ".rpm"
		case "msi":
			ext = ".msi"
		default:
			http.Error(w, "Invalid package type. Use: binary, deb, rpm, or msi", http.StatusBadRequest)
			return
		}
	} else if len(parts) == 2 {
		// Old format: linux/amd64.deb
		osType = parts[0]
		archAndExt := parts[1]
		
		// Parse arch and extension
		arch = archAndExt
		ext = ""
		if idx := strings.LastIndex(archAndExt, "."); idx != -1 {
			arch = archAndExt[:idx]
			ext = archAndExt[idx:]
		}
	} else {
		http.Error(w, "Invalid path. Use: /api/agent/{os}/{type}/{arch} or /api/agent/{os}/{arch}[.ext]", http.StatusBadRequest)
		return
	}

	// Validate OS
	if osType != "linux" && osType != "windows" {
		http.Error(w, "Unsupported OS. Use: linux or windows", http.StatusBadRequest)
		return
	}

	// Validate arch
	if arch != "amd64" && arch != "arm64" && arch != "386" {
		http.Error(w, "Unsupported architecture. Use: amd64, arm64, or 386", http.StatusBadRequest)
		return
	}

	// Determine filename
	var filename string
	var contentType string
	
	switch {
	case osType == "linux" && ext == "":
		filename = fmt.Sprintf("quantix-kvm-agent-%s-%s", osType, arch)
		contentType = "application/octet-stream"
	case osType == "linux" && ext == ".deb":
		filename = fmt.Sprintf("quantix-kvm-agent_%s_%s.deb", "0.1.0", arch)
		contentType = "application/vnd.debian.binary-package"
	case osType == "linux" && ext == ".rpm":
		filename = fmt.Sprintf("quantix-kvm-agent-0.1.0-1.%s.rpm", arch)
		contentType = "application/x-rpm"
	case osType == "windows" && ext == "":
		filename = fmt.Sprintf("quantix-kvm-agent-%s-%s.exe", osType, arch)
		contentType = "application/octet-stream"
	case osType == "windows" && ext == ".msi":
		filename = fmt.Sprintf("quantix-kvm-agent_%s_%s.msi", "0.1.0", arch)
		contentType = "application/x-msi"
	default:
		http.Error(w, "Unsupported format", http.StatusBadRequest)
		return
	}

	// Try to serve from local directory first
	if h.agentDir != "" {
		localPath := filepath.Join(h.agentDir, filename)
		if file, err := os.Open(localPath); err == nil {
			defer file.Close()
			
			info, _ := file.Stat()
			h.logger.Info("Serving agent binary from local file",
				zap.String("path", localPath),
				zap.Int64("size", info.Size()),
			)
			
			w.Header().Set("Content-Type", contentType)
			w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename))
			w.Header().Set("Content-Length", fmt.Sprintf("%d", info.Size()))
			io.Copy(w, file)
			return
		}
	}

	// Binary not found locally - return a helpful error with build instructions
	h.logger.Warn("Agent binary not found locally",
		zap.String("filename", filename),
		zap.String("agent_dir", h.agentDir),
	)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusNotFound)
	fmt.Fprintf(w, `{
		"error": "Agent binary not available",
		"message": "The Quantix Agent binary for %s/%s%s has not been built or deployed yet.",
		"build_instructions": "Run 'make build-agent' from the project root to build agent binaries.",
		"requested_file": "%s"
	}`, osType, arch, ext, filename)
}
