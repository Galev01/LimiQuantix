
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Quantixkvm/Quantixkvm/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/Quantixkvm/Quantixkvm/internal/domain/network.go (0.0%)</option>
				
				<option value="file2">github.com/Quantixkvm/Quantixkvm/internal/domain/node.go (0.0%)</option>
				
				<option value="file3">github.com/Quantixkvm/Quantixkvm/internal/domain/storage.go (0.0%)</option>
				
				<option value="file4">github.com/Quantixkvm/Quantixkvm/internal/domain/user.go (0.0%)</option>
				
				<option value="file5">github.com/Quantixkvm/Quantixkvm/internal/domain/vm.go (0.0%)</option>
				
				<option value="file6">github.com/Quantixkvm/Quantixkvm/internal/drs/engine.go (0.0%)</option>
				
				<option value="file7">github.com/Quantixkvm/Quantixkvm/internal/ha/manager.go (0.0%)</option>
				
				<option value="file8">github.com/Quantixkvm/Quantixkvm/internal/repository/etcd/client.go (0.0%)</option>
				
				<option value="file9">github.com/Quantixkvm/Quantixkvm/internal/repository/redis/cache.go (0.0%)</option>
				
				<option value="file10">github.com/Quantixkvm/Quantixkvm/internal/scheduler/config.go (100.0%)</option>
				
				<option value="file11">github.com/Quantixkvm/Quantixkvm/internal/scheduler/scheduler.go (51.1%)</option>
				
				<option value="file12">github.com/Quantixkvm/Quantixkvm/internal/server/middleware/auth.go (0.0%)</option>
				
				<option value="file13">github.com/Quantixkvm/Quantixkvm/internal/services/alert/service.go (0.0%)</option>
				
				<option value="file14">github.com/Quantixkvm/Quantixkvm/internal/services/auth/jwt.go (78.1%)</option>
				
				<option value="file15">github.com/Quantixkvm/Quantixkvm/internal/services/auth/service.go (0.0%)</option>
				
				<option value="file16">github.com/Quantixkvm/Quantixkvm/internal/services/network/converter.go (0.0%)</option>
				
				<option value="file17">github.com/Quantixkvm/Quantixkvm/internal/services/network/network_service.go (0.0%)</option>
				
				<option value="file18">github.com/Quantixkvm/Quantixkvm/internal/services/network/security_group_service.go (0.0%)</option>
				
				<option value="file19">github.com/Quantixkvm/Quantixkvm/internal/services/storage/pool_converter.go (0.0%)</option>
				
				<option value="file20">github.com/Quantixkvm/Quantixkvm/internal/services/storage/pool_service.go (0.0%)</option>
				
				<option value="file21">github.com/Quantixkvm/Quantixkvm/internal/services/storage/volume_converter.go (0.0%)</option>
				
				<option value="file22">github.com/Quantixkvm/Quantixkvm/internal/services/storage/volume_service.go (0.0%)</option>
				
				<option value="file23">github.com/Quantixkvm/Quantixkvm/internal/services/streaming/service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides configuration management for the Quantixkvm control plane.
package config

import (
        "fmt"
        "strings"
        "time"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application.
type Config struct {
        Server    ServerConfig    `mapstructure:"server"`
        Database  DatabaseConfig  `mapstructure:"database"`
        Etcd      EtcdConfig      `mapstructure:"etcd"`
        Redis     RedisConfig     `mapstructure:"redis"`
        Auth      AuthConfig      `mapstructure:"auth"`
        Scheduler SchedulerConfig `mapstructure:"scheduler"`
        DRS       DRSConfig       `mapstructure:"drs"`
        HA        HAConfig        `mapstructure:"ha"`
        Logging   LoggingConfig   `mapstructure:"logging"`
        CORS      CORSConfig      `mapstructure:"cors"`
}

// ServerConfig holds HTTP server configuration.
type ServerConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout"`
        ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout"`
}

// Address returns the server address string.
func (c ServerConfig) Address() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// DatabaseConfig holds PostgreSQL configuration.
type DatabaseConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        Name            string        `mapstructure:"name"`
        User            string        `mapstructure:"user"`
        Password        string        `mapstructure:"password"`
        SSLMode         string        `mapstructure:"sslmode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

// DSN returns the PostgreSQL connection string.
func (c DatabaseConfig) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Name, c.SSLMode,
        )
}</span>

// EtcdConfig holds etcd configuration.
type EtcdConfig struct {
        Endpoints   []string      `mapstructure:"endpoints"`
        DialTimeout time.Duration `mapstructure:"dial_timeout"`
        Username    string        `mapstructure:"username"`
        Password    string        `mapstructure:"password"`
}

// RedisConfig holds Redis configuration.
type RedisConfig struct {
        Host     string `mapstructure:"host"`
        Port     int    `mapstructure:"port"`
        Password string `mapstructure:"password"`
        DB       int    `mapstructure:"db"`
}

// Address returns the Redis address string.
func (c RedisConfig) Address() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// AuthConfig holds authentication configuration.
type AuthConfig struct {
        JWTSecret     string        `mapstructure:"jwt_secret"`
        TokenExpiry   time.Duration `mapstructure:"token_expiry"`
        RefreshExpiry time.Duration `mapstructure:"refresh_expiry"`
}

// SchedulerConfig holds VM scheduler configuration.
type SchedulerConfig struct {
        PlacementStrategy string  `mapstructure:"placement_strategy"`
        OvercommitCPU     float64 `mapstructure:"overcommit_cpu"`
        OvercommitMemory  float64 `mapstructure:"overcommit_memory"`
}

// DRSConfig holds Distributed Resource Scheduler configuration.
type DRSConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        AutomationLevel string        `mapstructure:"automation_level"`
        Interval        time.Duration `mapstructure:"interval"`
        ThresholdCPU    int           `mapstructure:"threshold_cpu"`
        ThresholdMemory int           `mapstructure:"threshold_memory"`
}

// HAConfig holds High Availability configuration.
type HAConfig struct {
        Enabled          bool          `mapstructure:"enabled"`
        CheckInterval    time.Duration `mapstructure:"check_interval"`
        HeartbeatTimeout time.Duration `mapstructure:"heartbeat_timeout"`
        FailureThreshold int           `mapstructure:"failure_threshold"`
}

// LoggingConfig holds logging configuration.
type LoggingConfig struct {
        Level  string `mapstructure:"level"`
        Format string `mapstructure:"format"`
        Output string `mapstructure:"output"`
}

// CORSConfig holds CORS configuration.
type CORSConfig struct {
        AllowedOrigins   []string `mapstructure:"allowed_origins"`
        AllowedMethods   []string `mapstructure:"allowed_methods"`
        AllowedHeaders   []string `mapstructure:"allowed_headers"`
        AllowCredentials bool     `mapstructure:"allow_credentials"`
}

// Load loads configuration from file and environment variables.
func Load(configPath string) (*Config, error) <span class="cov0" title="0">{
        v := viper.New()

        // Set defaults
        setDefaults(v)

        // Config file
        if configPath != "" </span><span class="cov0" title="0">{
                v.SetConfigFile(configPath)
        }</span> else<span class="cov0" title="0"> {
                v.SetConfigName("config")
                v.SetConfigType("yaml")
                v.AddConfigPath("./configs")
                v.AddConfigPath(".")
        }</span>

        // Environment variables
        <span class="cov0" title="0">v.SetEnvPrefix("Quantixkvm")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Read config file
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config file: %w", err)
                }</span>
                // Config file not found, use defaults and env vars
        }

        // Unmarshal config
        <span class="cov0" title="0">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

func setDefaults(v *viper.Viper) <span class="cov0" title="0">{
        // Server
        v.SetDefault("server.host", "0.0.0.0")
        v.SetDefault("server.port", 8080)
        v.SetDefault("server.read_timeout", "30s")
        v.SetDefault("server.write_timeout", "30s")
        v.SetDefault("server.shutdown_timeout", "10s")

        // Database
        v.SetDefault("database.host", "localhost")
        v.SetDefault("database.port", 5432)
        v.SetDefault("database.name", "Quantixkvm")
        v.SetDefault("database.user", "Quantixkvm")
        v.SetDefault("database.password", "Quantixkvm")
        v.SetDefault("database.sslmode", "disable")
        v.SetDefault("database.max_open_conns", 25)
        v.SetDefault("database.max_idle_conns", 5)
        v.SetDefault("database.conn_max_lifetime", "5m")

        // etcd
        v.SetDefault("etcd.endpoints", []string{"localhost:2379"})
        v.SetDefault("etcd.dial_timeout", "5s")

        // Redis
        v.SetDefault("redis.host", "localhost")
        v.SetDefault("redis.port", 6379)
        v.SetDefault("redis.db", 0)

        // Auth
        v.SetDefault("auth.jwt_secret", "change-me-in-production")
        v.SetDefault("auth.token_expiry", "24h")
        v.SetDefault("auth.refresh_expiry", "168h")

        // Scheduler
        v.SetDefault("scheduler.placement_strategy", "spread")
        v.SetDefault("scheduler.overcommit_cpu", 2.0)
        v.SetDefault("scheduler.overcommit_memory", 1.5)

        // DRS
        v.SetDefault("drs.enabled", true)
        v.SetDefault("drs.automation_level", "partial")
        v.SetDefault("drs.interval", "5m")
        v.SetDefault("drs.threshold_cpu", 80)
        v.SetDefault("drs.threshold_memory", 85)

        // HA
        v.SetDefault("ha.enabled", true)
        v.SetDefault("ha.check_interval", "30s")
        v.SetDefault("ha.failure_threshold", 3)

        // Logging
        v.SetDefault("logging.level", "info")
        v.SetDefault("logging.format", "json")
        v.SetDefault("logging.output", "stdout")

        // CORS
        v.SetDefault("cors.allowed_origins", []string{"http://localhost:5173"})
        v.SetDefault("cors.allowed_methods", []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"})
        v.SetDefault("cors.allowed_headers", []string{"*"})
        v.SetDefault("cors.allow_credentials", true)
}</span>

</pre>
		
		<pre class="file" id="file1" style="display: none">// Package domain contains core business entities for the Quantixkvm platform.
// This file defines network-related domain models: VirtualNetwork, Port, SecurityGroup, etc.
package domain

import "time"

// =============================================================================
// VIRTUAL NETWORK - SDN Network
// =============================================================================

// NetworkPhase represents the lifecycle phase of a virtual network.
type NetworkPhase string

const (
        NetworkPhasePending  NetworkPhase = "PENDING"
        NetworkPhaseReady    NetworkPhase = "READY"
        NetworkPhaseError    NetworkPhase = "ERROR"
        NetworkPhaseDeleting NetworkPhase = "DELETING"
)

// NetworkType represents the type of virtual network.
type NetworkType string

const (
        NetworkTypeOverlay  NetworkType = "OVERLAY"
        NetworkTypeVLAN     NetworkType = "VLAN"
        NetworkTypeExternal NetworkType = "EXTERNAL"
        NetworkTypeIsolated NetworkType = "ISOLATED"
)

// VirtualNetwork represents a software-defined network for VMs.
type VirtualNetwork struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        ProjectID   string            `json:"project_id"`
        Description string            `json:"description"`
        Labels      map[string]string `json:"labels"`

        Spec   VirtualNetworkSpec   `json:"spec"`
        Status VirtualNetworkStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// VirtualNetworkSpec defines the desired configuration of a network.
type VirtualNetworkSpec struct {
        Type                   NetworkType       `json:"type"`
        IPConfig               IPAddressConfig   `json:"ip_config"`
        VLAN                   *VLANConfig       `json:"vlan,omitempty"`
        Router                 *RouterConfig     `json:"router,omitempty"`
        MTU                    uint32            `json:"mtu"`
        DNS                    DNSConfig         `json:"dns"`
        DefaultSecurityGroupID string            `json:"default_security_group_id"`
        PortSecurityEnabled    bool              `json:"port_security_enabled"`
}

// IPAddressConfig defines IP addressing for a network.
type IPAddressConfig struct {
        IPv4Subnet      string        `json:"ipv4_subnet"`
        IPv4Gateway     string        `json:"ipv4_gateway"`
        IPv6Subnet      string        `json:"ipv6_subnet"`
        IPv6Gateway     string        `json:"ipv6_gateway"`
        DHCP            DHCPConfig    `json:"dhcp"`
        AllocationPools []IPRange     `json:"allocation_pools"`
        ReservedIPs     []string      `json:"reserved_ips"`
}

// DHCPConfig defines DHCP settings.
type DHCPConfig struct {
        Enabled        bool           `json:"enabled"`
        LeaseTimeSec   uint32         `json:"lease_time_sec"`
        DNSServers     []string       `json:"dns_servers"`
        NTPServers     []string       `json:"ntp_servers"`
        DomainName     string         `json:"domain_name"`
        StaticBindings []DHCPBinding  `json:"static_bindings"`
}

// DHCPBinding represents a static DHCP binding.
type DHCPBinding struct {
        MACAddress string `json:"mac_address"`
        IPAddress  string `json:"ip_address"`
        Hostname   string `json:"hostname"`
}

// IPRange represents a range of IP addresses.
type IPRange struct {
        Start string `json:"start"`
        End   string `json:"end"`
}

// VLANConfig defines VLAN settings.
type VLANConfig struct {
        VLANID          uint32 `json:"vlan_id"`
        PhysicalNetwork string `json:"physical_network"`
}

// RouterConfig defines router settings for a network.
type RouterConfig struct {
        Enabled                  bool          `json:"enabled"`
        ExternalGatewayNetworkID string        `json:"external_gateway_network_id"`
        EnableSNAT               bool          `json:"enable_snat"`
        Routes                   []StaticRoute `json:"routes"`
}

// StaticRoute represents a static route.
type StaticRoute struct {
        Destination string `json:"destination"`
        NextHop     string `json:"next_hop"`
}

// DNSConfig defines DNS settings.
type DNSConfig struct {
        Nameservers   []string `json:"nameservers"`
        SearchDomains []string `json:"search_domains"`
}

// VirtualNetworkStatus represents the runtime status of a network.
type VirtualNetworkStatus struct {
        Phase              NetworkPhase       `json:"phase"`
        OVNLogicalSwitch   string             `json:"ovn_logical_switch"`
        OVNLogicalRouter   string             `json:"ovn_logical_router"`
        PortCount          uint32             `json:"port_count"`
        IPAllocationStatus IPAllocationStatus `json:"ip_allocation_status"`
        ErrorMessage       string             `json:"error_message"`
}

// IPAllocationStatus shows IP address usage.
type IPAllocationStatus struct {
        IPv4Total     uint32 `json:"ipv4_total"`
        IPv4Allocated uint32 `json:"ipv4_allocated"`
        IPv4Available uint32 `json:"ipv4_available"`
        IPv6Allocated uint64 `json:"ipv6_allocated"`
}

// IsReady returns true if the network is ready to use.
func (n *VirtualNetwork) IsReady() bool <span class="cov0" title="0">{
        return n.Status.Phase == NetworkPhaseReady
}</span>

// =============================================================================
// NETWORK PORT - Virtual NIC Connection Point
// =============================================================================

// PortPhase represents the lifecycle phase of a port.
type PortPhase string

const (
        PortPhasePending PortPhase = "PENDING"
        PortPhaseBuild   PortPhase = "BUILD"
        PortPhaseActive  PortPhase = "ACTIVE"
        PortPhaseDown    PortPhase = "DOWN"
        PortPhaseError   PortPhase = "ERROR"
)

// Port represents a connection point on a virtual network.
type Port struct {
        ID        string            `json:"id"`
        Name      string            `json:"name"`
        NetworkID string            `json:"network_id"`
        ProjectID string            `json:"project_id"`
        Labels    map[string]string `json:"labels"`

        Spec   PortSpec   `json:"spec"`
        Status PortStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// PortSpec defines the desired port configuration.
type PortSpec struct {
        MACAddress          string          `json:"mac_address"`
        FixedIPs            []FixedIP       `json:"fixed_ips"`
        SecurityGroupIDs    []string        `json:"security_group_ids"`
        AllowedAddressPairs []AddressPair   `json:"allowed_address_pairs"`
        PortSecurityEnabled bool            `json:"port_security_enabled"`
        AdminStateUp        bool            `json:"admin_state_up"`
        QoS                 PortQoS         `json:"qos"`
        Binding             BindingProfile  `json:"binding"`
}

// FixedIP represents a fixed IP assignment.
type FixedIP struct {
        SubnetID  string `json:"subnet_id"`
        IPAddress string `json:"ip_address"`
}

// AddressPair allows additional addresses on a port (for HA/failover).
type AddressPair struct {
        IPAddress  string `json:"ip_address"`
        MACAddress string `json:"mac_address"`
}

// PortQoS defines rate limiting for a port.
type PortQoS struct {
        IngressRateKbps uint64 `json:"ingress_rate_kbps"`
        EgressRateKbps  uint64 `json:"egress_rate_kbps"`
        IngressBurstKb  uint64 `json:"ingress_burst_kb"`
        EgressBurstKb   uint64 `json:"egress_burst_kb"`
}

// BindingType represents the port binding type.
type BindingType string

const (
        BindingTypeNormal    BindingType = "NORMAL"
        BindingTypeDirect    BindingType = "DIRECT"    // SR-IOV
        BindingTypeMACVTAP   BindingType = "MACVTAP"
        BindingTypeVHostUser BindingType = "VHOST_USER" // DPDK
)

// BindingProfile defines hardware-specific binding options.
type BindingProfile struct {
        Type         BindingType `json:"type"`
        PCISlot      string      `json:"pci_slot"`
        VHostSocket  string      `json:"vhost_socket"`
        NUMAAffinity uint32      `json:"numa_affinity"`
}

// PortStatus represents the runtime status of a port.
type PortStatus struct {
        Phase        PortPhase `json:"phase"`
        MACAddress   string    `json:"mac_address"`
        IPAddresses  []string  `json:"ip_addresses"`
        OVNPort      string    `json:"ovn_port"`
        VMID         string    `json:"vm_id"`
        HostID       string    `json:"host_id"`
        ErrorMessage string    `json:"error_message"`
}

// IsActive returns true if the port is active.
func (p *Port) IsActive() bool <span class="cov0" title="0">{
        return p.Status.Phase == PortPhaseActive
}</span>

// =============================================================================
// SECURITY GROUP - Firewall Rules
// =============================================================================

// SecurityGroup defines firewall rules for network ports.
type SecurityGroup struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description"`
        ProjectID   string            `json:"project_id"`
        Labels      map[string]string `json:"labels"`

        Rules    []SecurityGroupRule `json:"rules"`
        Stateful bool                `json:"stateful"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// RuleDirection represents the direction of traffic.
type RuleDirection string

const (
        RuleDirectionIngress RuleDirection = "INGRESS"
        RuleDirectionEgress  RuleDirection = "EGRESS"
)

// RuleAction represents what to do with matched traffic.
type RuleAction string

const (
        RuleActionAllow  RuleAction = "ALLOW"
        RuleActionDrop   RuleAction = "DROP"
        RuleActionReject RuleAction = "REJECT"
)

// SecurityGroupRule represents a single firewall rule.
type SecurityGroupRule struct {
        ID                    string        `json:"id"`
        Direction             RuleDirection `json:"direction"`
        Protocol              string        `json:"protocol"` // "tcp", "udp", "icmp", "any"
        PortMin               uint32        `json:"port_min"`
        PortMax               uint32        `json:"port_max"`
        ICMPType              int32         `json:"icmp_type"`
        ICMPCode              int32         `json:"icmp_code"`
        RemoteIPPrefix        string        `json:"remote_ip_prefix"`
        RemoteSecurityGroupID string        `json:"remote_security_group_id"`
        Action                RuleAction    `json:"action"`
        Priority              uint32        `json:"priority"`
        Description           string        `json:"description"`
}

// =============================================================================
// FLOATING IP - Public IP Assignment
// =============================================================================

// FloatingIPPhase represents the lifecycle phase of a floating IP.
type FloatingIPPhase string

const (
        FloatingIPPhasePending FloatingIPPhase = "PENDING"
        FloatingIPPhaseActive  FloatingIPPhase = "ACTIVE"
        FloatingIPPhaseDown    FloatingIPPhase = "DOWN"
        FloatingIPPhaseError   FloatingIPPhase = "ERROR"
)

// FloatingIP represents a public IP that can be assigned to a VM.
type FloatingIP struct {
        ID                string            `json:"id"`
        IPAddress         string            `json:"ip_address"`
        ExternalNetworkID string            `json:"external_network_id"`
        ProjectID         string            `json:"project_id"`
        Description       string            `json:"description"`
        Labels            map[string]string `json:"labels"`

        Assignment FloatingIPAssignment `json:"assignment"`
        Status     FloatingIPStatus     `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// FloatingIPAssignment defines which port has this floating IP.
type FloatingIPAssignment struct {
        PortID  string `json:"port_id"`
        FixedIP string `json:"fixed_ip"`
}

// FloatingIPStatus represents the floating IP status.
type FloatingIPStatus struct {
        Phase        FloatingIPPhase `json:"phase"`
        VMID         string          `json:"vm_id"`
        RouterID     string          `json:"router_id"`
        ErrorMessage string          `json:"error_message"`
}

// IsAssigned returns true if the floating IP is assigned to a port.
func (f *FloatingIP) IsAssigned() bool <span class="cov0" title="0">{
        return f.Assignment.PortID != ""
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

import (
        "time"
)

// NodePhase represents the lifecycle phase of a node.
type NodePhase string

const (
        NodePhaseUnknown     NodePhase = "UNKNOWN"
        NodePhasePending     NodePhase = "PENDING"
        NodePhaseReady       NodePhase = "READY"
        NodePhaseNotReady    NodePhase = "NOT_READY"
        NodePhaseMaintenance NodePhase = "MAINTENANCE"
        NodePhaseDraining    NodePhase = "DRAINING"
        NodePhaseError       NodePhase = "ERROR"
)

// Node represents a physical hypervisor host.
type Node struct {
        ID           string            `json:"id"`
        Hostname     string            `json:"hostname"`
        ManagementIP string            `json:"management_ip"`
        Labels       map[string]string `json:"labels"`
        ClusterID    string            `json:"cluster_id,omitempty"`

        Spec   NodeSpec   `json:"spec"`
        Status NodeStatus `json:"status"`

        CreatedAt     time.Time  `json:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at"`
        LastHeartbeat *time.Time `json:"last_heartbeat,omitempty"`
}

// NodeSpec represents the hardware capabilities of a node.
type NodeSpec struct {
        CPU      NodeCPUInfo      `json:"cpu"`
        Memory   NodeMemoryInfo   `json:"memory"`
        Storage  []StorageDevice  `json:"storage"`
        Networks []NetworkAdapter `json:"networks"`
        Role     NodeRole         `json:"role"`
}

// NodeCPUInfo represents CPU information for a node.
type NodeCPUInfo struct {
        Model       string   `json:"model"`
        Sockets     int32    `json:"sockets"`
        CoresPerSocket int32 `json:"cores_per_socket"`
        ThreadsPerCore int32 `json:"threads_per_core"`
        FrequencyMHz int32   `json:"frequency_mhz"`
        Features    []string `json:"features,omitempty"`
}

// TotalCores returns the total number of CPU cores.
func (c NodeCPUInfo) TotalCores() int32 <span class="cov0" title="0">{
        return c.Sockets * c.CoresPerSocket
}</span>

// TotalThreads returns the total number of CPU threads.
func (c NodeCPUInfo) TotalThreads() int32 <span class="cov0" title="0">{
        return c.Sockets * c.CoresPerSocket * c.ThreadsPerCore
}</span>

// NodeMemoryInfo represents memory information for a node.
type NodeMemoryInfo struct {
        TotalMiB       int64 `json:"total_mib"`
        AllocatableMiB int64 `json:"allocatable_mib"`
}

// StorageDevice represents a storage device on a node.
type StorageDevice struct {
        Name     string `json:"name"`
        Type     string `json:"type"` // HDD, SSD, NVMe
        SizeGiB  int64  `json:"size_gib"`
        Path     string `json:"path"`
        Model    string `json:"model,omitempty"`
        Serial   string `json:"serial,omitempty"`
}

// NetworkAdapter represents a network adapter on a node.
type NetworkAdapter struct {
        Name       string `json:"name"`
        MACAddress string `json:"mac_address"`
        SpeedMbps  int64  `json:"speed_mbps"`
        MTU        int32  `json:"mtu"`
        Driver     string `json:"driver,omitempty"`
        SRIOVCapable bool `json:"sriov_capable"`
}

// NodeRole represents the role of a node in the cluster.
type NodeRole struct {
        Compute      bool `json:"compute"`
        Storage      bool `json:"storage"`
        ControlPlane bool `json:"control_plane"`
}

// NodeStatus represents the current status of a node.
type NodeStatus struct {
        Phase       NodePhase       `json:"phase"`
        Conditions  []NodeCondition `json:"conditions,omitempty"`
        Allocatable Resources       `json:"allocatable"`
        Allocated   Resources       `json:"allocated"`
        VMIDs       []string        `json:"vm_ids,omitempty"`
        SystemInfo  *SystemInfo     `json:"system_info,omitempty"`
}

// NodeCondition represents a condition of a node.
type NodeCondition struct {
        Type    string    `json:"type"`
        Status  string    `json:"status"` // True, False, Unknown
        Reason  string    `json:"reason,omitempty"`
        Message string    `json:"message,omitempty"`
        LastUpdate time.Time `json:"last_update"`
}

// Resources represents allocatable/allocated resources.
type Resources struct {
        CPUCores     int32 `json:"cpu_cores"`
        MemoryMiB    int64 `json:"memory_mib"`
        StorageGiB   int64 `json:"storage_gib"`
        GPUCount     int32 `json:"gpu_count,omitempty"`
}

// SystemInfo represents system information about the node.
type SystemInfo struct {
        OS              string `json:"os"`
        Kernel          string `json:"kernel"`
        Architecture    string `json:"architecture"`
        HypervisorVersion string `json:"hypervisor_version"`
        AgentVersion    string `json:"agent_version"`
}

// IsReady returns true if the node is ready to accept VMs.
func (n *Node) IsReady() bool <span class="cov0" title="0">{
        return n.Status.Phase == NodePhaseReady
}</span>

// IsSchedulable returns true if VMs can be scheduled on this node.
func (n *Node) IsSchedulable() bool <span class="cov0" title="0">{
        return n.Status.Phase == NodePhaseReady &amp;&amp; n.Spec.Role.Compute
}</span>

// AvailableCPU returns the available CPU cores.
func (n *Node) AvailableCPU() int32 <span class="cov0" title="0">{
        return n.Status.Allocatable.CPUCores - n.Status.Allocated.CPUCores
}</span>

// AvailableMemory returns the available memory in MiB.
func (n *Node) AvailableMemory() int64 <span class="cov0" title="0">{
        return n.Status.Allocatable.MemoryMiB - n.Status.Allocated.MemoryMiB
}</span>

// VMCount returns the number of VMs running on this node.
func (n *Node) VMCount() int <span class="cov0" title="0">{
        return len(n.Status.VMIDs)
}</span>

</pre>
		
		<pre class="file" id="file3" style="display: none">// Package domain contains core business entities for the Quantixkvm platform.
// This file defines storage-related domain models: StoragePool, Volume, Snapshot, Image.
package domain

import "time"

// =============================================================================
// STORAGE POOL - Logical Storage Cluster
// =============================================================================

// StoragePoolPhase represents the current lifecycle phase of a storage pool.
type StoragePoolPhase string

const (
        StoragePoolPhasePending  StoragePoolPhase = "PENDING"
        StoragePoolPhaseReady    StoragePoolPhase = "READY"
        StoragePoolPhaseDegraded StoragePoolPhase = "DEGRADED"
        StoragePoolPhaseError    StoragePoolPhase = "ERROR"
        StoragePoolPhaseDeleting StoragePoolPhase = "DELETING"
)

// BackendType represents the type of storage backend.
type BackendType string

const (
        BackendTypeCephRBD   BackendType = "CEPH_RBD"
        BackendTypeCephFS    BackendType = "CEPH_CEPHFS"
        BackendTypeLocalLVM  BackendType = "LOCAL_LVM"
        BackendTypeLocalDir  BackendType = "LOCAL_DIR"
        BackendTypeNFS       BackendType = "NFS"
        BackendTypeISCSI     BackendType = "ISCSI"
)

// StoragePool represents a logical pool of storage resources.
// This abstracts Ceph pools, local LVM volume groups, or NFS shares.
type StoragePool struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        ProjectID   string            `json:"project_id"`
        Description string            `json:"description"`
        Labels      map[string]string `json:"labels"`

        Spec   StoragePoolSpec   `json:"spec"`
        Status StoragePoolStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// StoragePoolSpec defines the desired configuration of a storage pool.
type StoragePoolSpec struct {
        Backend     StorageBackend    `json:"backend"`
        Defaults    VolumeDefaults    `json:"defaults"`
        QoS         StorageQoS        `json:"qos"`
        Encryption  EncryptionConfig  `json:"encryption"`
        Replication ReplicationConfig `json:"replication"`
}

// StorageBackend defines the storage backend configuration.
type StorageBackend struct {
        Type      BackendType `json:"type"`
        CephRBD   *CephConfig `json:"ceph_rbd,omitempty"`
        LocalLVM  *LVMConfig  `json:"local_lvm,omitempty"`
        LocalDir  *DirConfig  `json:"local_dir,omitempty"`
        NFS       *NFSConfig  `json:"nfs,omitempty"`
}

// CephConfig holds Ceph-specific configuration.
type CephConfig struct {
        ClusterID   string   `json:"cluster_id"`
        PoolName    string   `json:"pool_name"`
        Monitors    []string `json:"monitors"`
        User        string   `json:"user"`
        KeyringPath string   `json:"keyring_path"`
        Namespace   string   `json:"namespace"`
}

// LVMConfig holds LVM-specific configuration.
type LVMConfig struct {
        VolumeGroup string `json:"volume_group"`
        ThinPool    string `json:"thin_pool"`
        NodeID      string `json:"node_id"`
}

// DirConfig holds local directory configuration.
type DirConfig struct {
        Path   string `json:"path"`
        NodeID string `json:"node_id"`
}

// NFSConfig holds NFS-specific configuration.
type NFSConfig struct {
        Server     string `json:"server"`
        ExportPath string `json:"export_path"`
        Version    string `json:"version"`
        Options    string `json:"options"`
}

// VolumeDefaults defines default settings for volumes created in this pool.
type VolumeDefaults struct {
        Provisioning string `json:"provisioning"` // "thin" or "thick"
        Filesystem   string `json:"filesystem"`   // "ext4", "xfs", "raw"
        BlockSize    uint32 `json:"block_size"`
}

// StorageQoS defines quality of service settings for a storage pool.
type StorageQoS struct {
        MaxIOPS               uint64 `json:"max_iops"`
        MaxThroughputBytes    uint64 `json:"max_throughput_bytes"`
        BurstIOPS             uint64 `json:"burst_iops"`
        BurstThroughputBytes  uint64 `json:"burst_throughput_bytes"`
        BurstDurationSec      uint32 `json:"burst_duration_sec"`
}

// EncryptionConfig defines encryption settings.
type EncryptionConfig struct {
        Enabled       bool   `json:"enabled"`
        Cipher        string `json:"cipher"`
        KeyManagement string `json:"key_management"` // "internal" or "external_kms"
        KMSEndpoint   string `json:"kms_endpoint"`
        KMSKeyID      string `json:"kms_key_id"`
}

// ReplicationConfig defines replication settings.
type ReplicationConfig struct {
        ReplicaCount  uint32 `json:"replica_count"`
        MinReplicas   uint32 `json:"min_replicas"`
        FailureDomain string `json:"failure_domain"`
}

// StoragePoolStatus represents the current runtime status of a storage pool.
type StoragePoolStatus struct {
        Phase        StoragePoolPhase `json:"phase"`
        Capacity     StorageCapacity  `json:"capacity"`
        Metrics      StorageMetrics   `json:"metrics"`
        Health       StorageHealth    `json:"health"`
        VolumeCount  uint32           `json:"volume_count"`
        ErrorMessage string           `json:"error_message"`
}

// StorageCapacity holds capacity information.
type StorageCapacity struct {
        TotalBytes       uint64 `json:"total_bytes"`
        UsedBytes        uint64 `json:"used_bytes"`
        AvailableBytes   uint64 `json:"available_bytes"`
        ProvisionedBytes uint64 `json:"provisioned_bytes"`
}

// StorageMetrics holds current performance metrics.
type StorageMetrics struct {
        ReadIOPS         uint64 `json:"read_iops"`
        WriteIOPS        uint64 `json:"write_iops"`
        ReadBytesPerSec  uint64 `json:"read_bytes_per_sec"`
        WriteBytesPerSec uint64 `json:"write_bytes_per_sec"`
        ReadLatencyUs    uint64 `json:"read_latency_us"`
        WriteLatencyUs   uint64 `json:"write_latency_us"`
}

// StorageHealth represents health status.
type StorageHealth struct {
        Status string        `json:"status"` // "healthy", "warning", "error"
        Checks []HealthCheck `json:"checks"`
}

// HealthCheck represents a single health check result.
type HealthCheck struct {
        Name    string `json:"name"`
        Passed  bool   `json:"passed"`
        Message string `json:"message"`
}

// IsReady returns true if the storage pool is ready to use.
func (p *StoragePool) IsReady() bool <span class="cov0" title="0">{
        return p.Status.Phase == StoragePoolPhaseReady
}</span>

// =============================================================================
// VOLUME - Virtual Disk
// =============================================================================

// VolumePhase represents the current lifecycle phase of a volume.
type VolumePhase string

const (
        VolumePhasePending  VolumePhase = "PENDING"
        VolumePhaseCreating VolumePhase = "CREATING"
        VolumePhaseReady    VolumePhase = "READY"
        VolumePhaseInUse    VolumePhase = "IN_USE"
        VolumePhaseDeleting VolumePhase = "DELETING"
        VolumePhaseError    VolumePhase = "ERROR"
        VolumePhaseResizing VolumePhase = "RESIZING"
)

// ProvisioningType defines how volume space is allocated.
type ProvisioningType string

const (
        ProvisioningThin       ProvisioningType = "THIN"
        ProvisioningThickLazy  ProvisioningType = "THICK_LAZY"
        ProvisioningThickEager ProvisioningType = "THICK_EAGER"
)

// AccessMode defines how a volume can be accessed.
type AccessMode string

const (
        AccessModeReadWriteOnce AccessMode = "READ_WRITE_ONCE"
        AccessModeReadOnlyMany  AccessMode = "READ_ONLY_MANY"
        AccessModeReadWriteMany AccessMode = "READ_WRITE_MANY"
)

// Volume represents a virtual disk that can be attached to VMs.
type Volume struct {
        ID        string            `json:"id"`
        Name      string            `json:"name"`
        ProjectID string            `json:"project_id"`
        PoolID    string            `json:"pool_id"`
        Labels    map[string]string `json:"labels"`

        Spec   VolumeSpec   `json:"spec"`
        Status VolumeStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// VolumeSpec defines the desired configuration of a volume.
type VolumeSpec struct {
        SizeBytes    uint64           `json:"size_bytes"`
        Provisioning ProvisioningType `json:"provisioning"`
        Source       VolumeSource     `json:"source"`
        QoS          VolumeQoS        `json:"qos"`
        Encryption   EncryptionConfig `json:"encryption"`
        AccessMode   AccessMode       `json:"access_mode"`
}

// VolumeSource defines the source for volume creation.
type VolumeSource struct {
        Type       string `json:"type"` // "empty", "clone", "snapshot", "image"
        VolumeID   string `json:"volume_id,omitempty"`
        SnapshotID string `json:"snapshot_id,omitempty"`
        ImageID    string `json:"image_id,omitempty"`
        Filesystem string `json:"filesystem,omitempty"`
}

// VolumeQoS defines quality of service settings for a volume.
type VolumeQoS struct {
        MaxIOPS              uint64 `json:"max_iops"`
        MinIOPS              uint64 `json:"min_iops"`
        MaxThroughput        uint64 `json:"max_throughput"`
        MinThroughput        uint64 `json:"min_throughput"`
        BurstIOPS            uint64 `json:"burst_iops"`
        BurstThroughput      uint64 `json:"burst_throughput"`
        BurstDurationSec     uint32 `json:"burst_duration_sec"`
}

// VolumeStatus represents the current runtime status of a volume.
type VolumeStatus struct {
        Phase           VolumePhase `json:"phase"`
        AttachedVMID    string      `json:"attached_vm_id"`
        DevicePath      string      `json:"device_path"`
        ActualSizeBytes uint64      `json:"actual_size_bytes"`
        Usage           VolumeUsage `json:"usage"`
        SnapshotCount   uint32      `json:"snapshot_count"`
        ErrorMessage    string      `json:"error_message"`
        BackendID       string      `json:"backend_id"`
}

// VolumeUsage holds usage statistics for a volume.
type VolumeUsage struct {
        UsedBytes        uint64 `json:"used_bytes"`
        ReadIOPS         uint64 `json:"read_iops"`
        WriteIOPS        uint64 `json:"write_iops"`
        ReadBytesPerSec  uint64 `json:"read_bytes_per_sec"`
        WriteBytesPerSec uint64 `json:"write_bytes_per_sec"`
        ReadLatencyUs    uint64 `json:"read_latency_us"`
        WriteLatencyUs   uint64 `json:"write_latency_us"`
}

// IsAttached returns true if the volume is attached to a VM.
func (v *Volume) IsAttached() bool <span class="cov0" title="0">{
        return v.Status.AttachedVMID != ""
}</span>

// IsReady returns true if the volume is ready to use.
func (v *Volume) IsReady() bool <span class="cov0" title="0">{
        return v.Status.Phase == VolumePhaseReady
}</span>

// =============================================================================
// VOLUME SNAPSHOT
// =============================================================================

// SnapshotPhase represents the lifecycle phase of a snapshot.
type SnapshotPhase string

const (
        SnapshotPhasePending  SnapshotPhase = "PENDING"
        SnapshotPhaseCreating SnapshotPhase = "CREATING"
        SnapshotPhaseReady    SnapshotPhase = "READY"
        SnapshotPhaseDeleting SnapshotPhase = "DELETING"
        SnapshotPhaseError    SnapshotPhase = "ERROR"
)

// VolumeSnapshot represents a point-in-time snapshot of a volume.
type VolumeSnapshot struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description"`
        VolumeID    string            `json:"volume_id"`
        Labels      map[string]string `json:"labels"`

        Spec   SnapshotSpec   `json:"spec"`
        Status SnapshotStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
}

// SnapshotSpec defines the snapshot specification.
type SnapshotSpec struct {
        RetainHours uint32     `json:"retain_hours"`
        ExpiresAt   *time.Time `json:"expires_at,omitempty"`
}

// SnapshotStatus represents the snapshot status.
type SnapshotStatus struct {
        Phase        SnapshotPhase `json:"phase"`
        SizeBytes    uint64        `json:"size_bytes"`
        ReadyToUse   bool          `json:"ready_to_use"`
        ErrorMessage string        `json:"error_message"`
}

// =============================================================================
// IMAGE - OS Templates
// =============================================================================

// ImagePhase represents the lifecycle phase of an image.
type ImagePhase string

const (
        ImagePhasePending     ImagePhase = "PENDING"
        ImagePhaseDownloading ImagePhase = "DOWNLOADING"
        ImagePhaseConverting  ImagePhase = "CONVERTING"
        ImagePhaseReady       ImagePhase = "READY"
        ImagePhaseError       ImagePhase = "ERROR"
        ImagePhaseDeleting    ImagePhase = "DELETING"
)

// ImageFormat represents the image file format.
type ImageFormat string

const (
        ImageFormatRaw   ImageFormat = "RAW"
        ImageFormatQCOW2 ImageFormat = "QCOW2"
        ImageFormatVMDK  ImageFormat = "VMDK"
        ImageFormatVHD   ImageFormat = "VHD"
        ImageFormatISO   ImageFormat = "ISO"
)

// ImageVisibility represents who can access the image.
type ImageVisibility string

const (
        ImageVisibilityPrivate ImageVisibility = "PRIVATE"
        ImageVisibilityProject ImageVisibility = "PROJECT"
        ImageVisibilityPublic  ImageVisibility = "PUBLIC"
)

// OSFamily represents the operating system family.
type OSFamily string

const (
        OSFamilyLinux   OSFamily = "LINUX"
        OSFamilyWindows OSFamily = "WINDOWS"
        OSFamilyBSD     OSFamily = "BSD"
        OSFamilyOther   OSFamily = "OTHER"
)

// Image represents a bootable OS image/template.
type Image struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Description string            `json:"description"`
        ProjectID   string            `json:"project_id"`
        Labels      map[string]string `json:"labels"`

        Spec   ImageSpec   `json:"spec"`
        Status ImageStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// ImageSpec defines the image specification.
type ImageSpec struct {
        Format       ImageFormat      `json:"format"`
        Visibility   ImageVisibility  `json:"visibility"`
        OS           OSInfo           `json:"os"`
        Requirements ImageRequirements `json:"requirements"`
}

// OSInfo holds operating system information.
type OSInfo struct {
        Family       OSFamily `json:"family"`
        Distribution string   `json:"distribution"`
        Version      string   `json:"version"`
        Architecture string   `json:"architecture"`
        DefaultUser  string   `json:"default_user"`
}

// ImageRequirements defines minimum requirements for running the image.
type ImageRequirements struct {
        MinCPU              uint32   `json:"min_cpu"`
        MinMemoryMiB        uint64   `json:"min_memory_mib"`
        MinDiskGiB          uint64   `json:"min_disk_gib"`
        SupportedFirmware   []string `json:"supported_firmware"`
        RequiresSecureBoot  bool     `json:"requires_secure_boot"`
        RequiresTPM         bool     `json:"requires_tpm"`
}

// ImageStatus represents the image status.
type ImageStatus struct {
        Phase            ImagePhase `json:"phase"`
        SizeBytes        uint64     `json:"size_bytes"`
        VirtualSizeBytes uint64     `json:"virtual_size_bytes"`
        ProgressPercent  uint32     `json:"progress_percent"`
        Checksum         string     `json:"checksum"`
        ErrorMessage     string     `json:"error_message"`
        StoragePoolID    string     `json:"storage_pool_id"`
}

// IsReady returns true if the image is ready to use.
func (i *Image) IsReady() bool <span class="cov0" title="0">{
        return i.Status.Phase == ImagePhaseReady
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package domain contains core business entities for the Quantixkvm platform.
// This file defines user and authentication-related domain models.
package domain

import (
        "time"
)

// =============================================================================
// USER - User account management
// =============================================================================

// Role represents a user's role in the system.
type Role string

const (
        RoleAdmin    Role = "admin"    // Full system access
        RoleOperator Role = "operator" // Can manage VMs, nodes, etc.
        RoleViewer   Role = "viewer"   // Read-only access
)

// User represents a user account in the system.
type User struct {
        ID           string    `json:"id"`
        Username     string    `json:"username"`
        Email        string    `json:"email"`
        PasswordHash string    `json:"-"` // Never expose password hash
        Role         Role      `json:"role"`
        Enabled      bool      `json:"enabled"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
        LastLogin    *time.Time `json:"last_login,omitempty"`
}

// IsAdmin returns true if the user has admin role.
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.Role == RoleAdmin
}</span>

// CanManage returns true if the user can manage resources.
func (u *User) CanManage() bool <span class="cov0" title="0">{
        return u.Role == RoleAdmin || u.Role == RoleOperator
}</span>

// CanView returns true if the user can view resources.
func (u *User) CanView() bool <span class="cov0" title="0">{
        return u.Enabled // All enabled users can view
}</span>

// =============================================================================
// PERMISSIONS - Role-based access control
// =============================================================================

// Permission represents a specific action on a resource type.
type Permission string

const (
        // VM permissions
        PermissionVMCreate  Permission = "vm:create"
        PermissionVMRead    Permission = "vm:read"
        PermissionVMUpdate  Permission = "vm:update"
        PermissionVMDelete  Permission = "vm:delete"
        PermissionVMStart   Permission = "vm:start"
        PermissionVMStop    Permission = "vm:stop"
        PermissionVMMigrate Permission = "vm:migrate"

        // Node permissions
        PermissionNodeCreate Permission = "node:create"
        PermissionNodeRead   Permission = "node:read"
        PermissionNodeUpdate Permission = "node:update"
        PermissionNodeDelete Permission = "node:delete"
        PermissionNodeDrain  Permission = "node:drain"

        // Network permissions
        PermissionNetworkCreate Permission = "network:create"
        PermissionNetworkRead   Permission = "network:read"
        PermissionNetworkUpdate Permission = "network:update"
        PermissionNetworkDelete Permission = "network:delete"

        // Storage permissions
        PermissionStorageCreate Permission = "storage:create"
        PermissionStorageRead   Permission = "storage:read"
        PermissionStorageUpdate Permission = "storage:update"
        PermissionStorageDelete Permission = "storage:delete"

        // User permissions
        PermissionUserCreate Permission = "user:create"
        PermissionUserRead   Permission = "user:read"
        PermissionUserUpdate Permission = "user:update"
        PermissionUserDelete Permission = "user:delete"

        // System permissions
        PermissionSystemConfig Permission = "system:config"
        PermissionSystemAudit  Permission = "system:audit"
)

// RolePermissions defines which permissions each role has.
var RolePermissions = map[Role][]Permission{
        RoleAdmin: {
                // VMs
                PermissionVMCreate, PermissionVMRead, PermissionVMUpdate, PermissionVMDelete,
                PermissionVMStart, PermissionVMStop, PermissionVMMigrate,
                // Nodes
                PermissionNodeCreate, PermissionNodeRead, PermissionNodeUpdate, PermissionNodeDelete, PermissionNodeDrain,
                // Network
                PermissionNetworkCreate, PermissionNetworkRead, PermissionNetworkUpdate, PermissionNetworkDelete,
                // Storage
                PermissionStorageCreate, PermissionStorageRead, PermissionStorageUpdate, PermissionStorageDelete,
                // Users
                PermissionUserCreate, PermissionUserRead, PermissionUserUpdate, PermissionUserDelete,
                // System
                PermissionSystemConfig, PermissionSystemAudit,
        },
        RoleOperator: {
                // VMs
                PermissionVMCreate, PermissionVMRead, PermissionVMUpdate, PermissionVMDelete,
                PermissionVMStart, PermissionVMStop, PermissionVMMigrate,
                // Nodes
                PermissionNodeRead, PermissionNodeDrain,
                // Network
                PermissionNetworkCreate, PermissionNetworkRead, PermissionNetworkUpdate,
                // Storage
                PermissionStorageCreate, PermissionStorageRead, PermissionStorageUpdate,
                // Users
                PermissionUserRead,
        },
        RoleViewer: {
                PermissionVMRead,
                PermissionNodeRead,
                PermissionNetworkRead,
                PermissionStorageRead,
        },
}

// HasPermission checks if a role has a specific permission.
func HasPermission(role Role, permission Permission) bool <span class="cov0" title="0">{
        perms, ok := RolePermissions[role]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, p := range perms </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// =============================================================================
// AUDIT LOG - Track user actions
// =============================================================================

// AuditAction represents an auditable action.
type AuditAction string

const (
        AuditActionLogin      AuditAction = "LOGIN"
        AuditActionLogout     AuditAction = "LOGOUT"
        AuditActionCreate     AuditAction = "CREATE"
        AuditActionUpdate     AuditAction = "UPDATE"
        AuditActionDelete     AuditAction = "DELETE"
        AuditActionStart      AuditAction = "START"
        AuditActionStop       AuditAction = "STOP"
        AuditActionMigrate    AuditAction = "MIGRATE"
        AuditActionSnapshot   AuditAction = "SNAPSHOT"
        AuditActionRestore    AuditAction = "RESTORE"
        AuditActionConfigChange AuditAction = "CONFIG_CHANGE"
)

// AuditEntry represents a single audit log entry.
type AuditEntry struct {
        ID           string            `json:"id"`
        UserID       string            `json:"user_id"`
        Username     string            `json:"username"`
        Action       AuditAction       `json:"action"`
        ResourceType string            `json:"resource_type"` // vm, node, network, etc.
        ResourceID   string            `json:"resource_id"`
        ResourceName string            `json:"resource_name"`
        Details      map[string]interface{} `json:"details,omitempty"`
        IPAddress    string            `json:"ip_address"`
        UserAgent    string            `json:"user_agent"`
        CreatedAt    time.Time         `json:"created_at"`
}

// =============================================================================
// ALERTS - System alerts and notifications
// =============================================================================

// AlertSeverity represents the severity of an alert.
type AlertSeverity string

const (
        AlertSeverityCritical AlertSeverity = "CRITICAL"
        AlertSeverityWarning  AlertSeverity = "WARNING"
        AlertSeverityInfo     AlertSeverity = "INFO"
)

// AlertSourceType represents the source of an alert.
type AlertSourceType string

const (
        AlertSourceVM      AlertSourceType = "VM"
        AlertSourceNode    AlertSourceType = "HOST"
        AlertSourceStorage AlertSourceType = "STORAGE"
        AlertSourceNetwork AlertSourceType = "NETWORK"
        AlertSourceCluster AlertSourceType = "CLUSTER"
        AlertSourceSystem  AlertSourceType = "SYSTEM"
)

// Alert represents a system alert.
type Alert struct {
        ID             string          `json:"id"`
        Severity       AlertSeverity   `json:"severity"`
        Title          string          `json:"title"`
        Message        string          `json:"message"`
        SourceType     AlertSourceType `json:"source_type"`
        SourceID       string          `json:"source_id"`
        SourceName     string          `json:"source_name"`
        Acknowledged   bool            `json:"acknowledged"`
        AcknowledgedBy string          `json:"acknowledged_by,omitempty"`
        AcknowledgedAt *time.Time      `json:"acknowledged_at,omitempty"`
        Resolved       bool            `json:"resolved"`
        ResolvedAt     *time.Time      `json:"resolved_at,omitempty"`
        CreatedAt      time.Time       `json:"created_at"`
}

// =============================================================================
// DRS RECOMMENDATIONS
// =============================================================================

// DRSPriority represents the priority of a DRS recommendation.
type DRSPriority string

const (
        DRSPriorityCritical DRSPriority = "CRITICAL"
        DRSPriorityHigh     DRSPriority = "HIGH"
        DRSPriorityMedium   DRSPriority = "MEDIUM"
        DRSPriorityLow      DRSPriority = "LOW"
)

// DRSRecommendationType represents the type of DRS recommendation.
type DRSRecommendationType string

const (
        DRSTypeMigrate  DRSRecommendationType = "MIGRATE"
        DRSTypePowerOn  DRSRecommendationType = "POWER_ON"
        DRSTypePowerOff DRSRecommendationType = "POWER_OFF"
)

// DRSStatus represents the status of a DRS recommendation.
type DRSStatus string

const (
        DRSStatusPending  DRSStatus = "PENDING"
        DRSStatusApproved DRSStatus = "APPROVED"
        DRSStatusApplied  DRSStatus = "APPLIED"
        DRSStatusRejected DRSStatus = "REJECTED"
)

// DRSRecommendation represents a DRS migration recommendation.
type DRSRecommendation struct {
        ID                string                `json:"id"`
        ClusterID         string                `json:"cluster_id"`
        Priority          DRSPriority           `json:"priority"`
        RecommendationType DRSRecommendationType `json:"recommendation_type"`
        Reason            string                `json:"reason"`
        VMID              string                `json:"vm_id"`
        VMName            string                `json:"vm_name"`
        SourceNodeID      string                `json:"source_node_id"`
        SourceNodeName    string                `json:"source_node_name"`
        TargetNodeID      string                `json:"target_node_id"`
        TargetNodeName    string                `json:"target_node_name"`
        ImpactCPU         int32                 `json:"impact_cpu"`         // Improvement percentage
        ImpactMemory      int32                 `json:"impact_memory"`      // Improvement percentage
        EstimatedDuration string                `json:"estimated_duration"` // e.g., "2m30s"
        Status            DRSStatus             `json:"status"`
        CreatedAt         time.Time             `json:"created_at"`
        AppliedAt         *time.Time            `json:"applied_at,omitempty"`
        AppliedBy         string                `json:"applied_by,omitempty"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import (
        "time"
)

// VMState represents the power state of a virtual machine.
type VMState string

const (
        VMStatePending   VMState = "PENDING"
        VMStateCreating  VMState = "CREATING"
        VMStateStarting  VMState = "STARTING"
        VMStateRunning   VMState = "RUNNING"
        VMStateStopping  VMState = "STOPPING"
        VMStateStopped   VMState = "STOPPED"
        VMStatePaused    VMState = "PAUSED"
        VMStateSuspended VMState = "SUSPENDED"
        VMStateMigrating VMState = "MIGRATING"
        VMStateError     VMState = "ERROR"
        VMStateFailed    VMState = "FAILED"
        VMStateDeleting  VMState = "DELETING"
)

// VirtualMachine represents a virtual machine in the system.
type VirtualMachine struct {
        ID              string            `json:"id"`
        Name            string            `json:"name"`
        ProjectID       string            `json:"project_id"`
        Description     string            `json:"description"`
        Labels          map[string]string `json:"labels"`
        HardwareVersion string            `json:"hardware_version"`

        Spec   VMSpec   `json:"spec"`
        Status VMStatus `json:"status"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        CreatedBy string    `json:"created_by"`
}

// VMSpec represents the desired configuration of a virtual machine.
type VMSpec struct {
        CPU       CPUConfig        `json:"cpu"`
        Memory    MemoryConfig     `json:"memory"`
        Disks     []DiskDevice     `json:"disks"`
        NICs      []NetworkDevice  `json:"nics"`
        Cdroms    []CDROMDevice    `json:"cdroms,omitempty"`
        Display   *DisplayConfig   `json:"display,omitempty"`
        Boot      *BootConfig      `json:"boot,omitempty"`
        Placement *PlacementPolicy `json:"placement,omitempty"`
        HAPolicy  *HAPolicy        `json:"ha_policy,omitempty"`
}

// HAPolicy defines high availability settings for a VM.
type HAPolicy struct {
        AutoRestart  bool   `json:"auto_restart"`
        Priority     int32  `json:"priority"`
        RestartDelay int32  `json:"restart_delay_seconds,omitempty"`
}

// CPUConfig represents CPU configuration for a VM.
type CPUConfig struct {
        Cores   int32  `json:"cores"`
        Sockets int32  `json:"sockets"`
        Threads int32  `json:"threads"`
        Model   string `json:"model,omitempty"`
}

// TotalCores returns the total number of vCPUs.
func (c CPUConfig) TotalCores() int32 <span class="cov0" title="0">{
        sockets := c.Sockets
        if sockets == 0 </span><span class="cov0" title="0">{
                sockets = 1
        }</span>
        <span class="cov0" title="0">threads := c.Threads
        if threads == 0 </span><span class="cov0" title="0">{
                threads = 1
        }</span>
        <span class="cov0" title="0">return c.Cores * sockets * threads</span>
}

// MemoryConfig represents memory configuration for a VM.
type MemoryConfig struct {
        SizeMiB         int64 `json:"size_mib"`
        BallooningLimit int64 `json:"ballooning_limit,omitempty"`
        HugePagesEnabled bool `json:"huge_pages_enabled,omitempty"`
}

// DiskDevice represents a disk attached to a VM.
type DiskDevice struct {
        Name         string `json:"name"`
        VolumeID     string `json:"volume_id,omitempty"`
        SizeGiB      int64  `json:"size_gib"`
        Bus          string `json:"bus"` // virtio, scsi, sata
        Cache        string `json:"cache,omitempty"`
        IOPSLimit    int64  `json:"iops_limit,omitempty"`
        BootOrder    int32  `json:"boot_order,omitempty"`
        Provisioning string `json:"provisioning,omitempty"` // thin, thick
}

// NetworkDevice represents a network interface attached to a VM.
type NetworkDevice struct {
        Name            string   `json:"name"`
        NetworkID       string   `json:"network_id"`
        MACAddress      string   `json:"mac_address,omitempty"`
        IPAddresses     []string `json:"ip_addresses,omitempty"`
        SecurityGroups  []string `json:"security_groups,omitempty"`
        BandwidthLimitMbps int64 `json:"bandwidth_limit_mbps,omitempty"`
}

// CDROMDevice represents a CD-ROM device attached to a VM.
type CDROMDevice struct {
        Name     string `json:"name"`
        ImageID  string `json:"image_id,omitempty"`
        ISO      string `json:"iso,omitempty"`
        Connected bool  `json:"connected"`
}

// DisplayConfig represents display/console configuration.
type DisplayConfig struct {
        Type     string `json:"type"` // vnc, spice
        Port     int32  `json:"port,omitempty"`
        Password string `json:"password,omitempty"`
}

// BootConfig represents boot configuration.
type BootConfig struct {
        Order   []string `json:"order"` // disk, cdrom, network
        UEFI    bool     `json:"uefi"`
        SecureBoot bool  `json:"secure_boot"`
}

// PlacementPolicy represents VM placement preferences.
type PlacementPolicy struct {
        NodeID            string            `json:"node_id,omitempty"`
        ClusterID         string            `json:"cluster_id,omitempty"`
        AffinityLabels    map[string]string `json:"affinity_labels,omitempty"`
        AntiAffinityLabels map[string]string `json:"anti_affinity_labels,omitempty"`
}

// VMStatus represents the current runtime status of a virtual machine.
type VMStatus struct {
        State       VMState       `json:"state"`
        NodeID      string        `json:"node_id,omitempty"`
        IPAddresses []string      `json:"ip_addresses,omitempty"`
        Resources   ResourceUsage `json:"resources,omitempty"`
        GuestAgent  *GuestAgent   `json:"guest_agent,omitempty"`
        Console     *ConsoleInfo  `json:"console,omitempty"`
        Message     string        `json:"message,omitempty"`
}

// ResourceUsage represents current resource consumption.
type ResourceUsage struct {
        CPUPercent    float64 `json:"cpu_percent"`
        MemoryUsedMiB int64   `json:"memory_used_mib"`
        DiskReadBps   int64   `json:"disk_read_bps"`
        DiskWriteBps  int64   `json:"disk_write_bps"`
        NetworkRxBps  int64   `json:"network_rx_bps"`
        NetworkTxBps  int64   `json:"network_tx_bps"`
}

// GuestAgent represents guest agent information.
type GuestAgent struct {
        Installed bool   `json:"installed"`
        Version   string `json:"version,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        OS        string `json:"os,omitempty"`
}

// ConsoleInfo represents console connection information.
type ConsoleInfo struct {
        Type     string `json:"type"`
        URL      string `json:"url"`
        Password string `json:"password,omitempty"`
}

// IsRunning returns true if the VM is in a running state.
func (vm *VirtualMachine) IsRunning() bool <span class="cov0" title="0">{
        return vm.Status.State == VMStateRunning
}</span>

// IsStopped returns true if the VM is stopped.
func (vm *VirtualMachine) IsStopped() bool <span class="cov0" title="0">{
        return vm.Status.State == VMStateStopped
}</span>

// CanStart returns true if the VM can be started.
func (vm *VirtualMachine) CanStart() bool <span class="cov0" title="0">{
        return vm.Status.State == VMStateStopped || vm.Status.State == VMStatePaused
}</span>

// CanStop returns true if the VM can be stopped.
func (vm *VirtualMachine) CanStop() bool <span class="cov0" title="0">{
        return vm.Status.State == VMStateRunning || vm.Status.State == VMStatePaused
}</span>

</pre>
		
		<pre class="file" id="file6" style="display: none">// Package drs implements the Distributed Resource Scheduler for VM load balancing.
package drs

import (
        "context"
        "fmt"
        "sort"
        "sync"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/config"
        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// NodeRepository defines the interface for node data access.
type NodeRepository interface {
        ListSchedulable(ctx context.Context) ([]*domain.Node, error)
        Get(ctx context.Context, id string) (*domain.Node, error)
}

// VMRepository defines the interface for VM data access.
type VMRepository interface {
        ListByNodeID(ctx context.Context, nodeID string) ([]*domain.VirtualMachine, error)
}

// RecommendationRepository defines the interface for DRS recommendation storage.
type RecommendationRepository interface {
        Create(ctx context.Context, rec *domain.DRSRecommendation) (*domain.DRSRecommendation, error)
        Get(ctx context.Context, id string) (*domain.DRSRecommendation, error)
        List(ctx context.Context, status domain.DRSStatus, limit int) ([]*domain.DRSRecommendation, error)
        Update(ctx context.Context, rec *domain.DRSRecommendation) (*domain.DRSRecommendation, error)
        Delete(ctx context.Context, id string) error
        DeleteOld(ctx context.Context, olderThan time.Time) error
}

// AlertService creates alerts for DRS events.
type AlertService interface {
        ClusterAlert(ctx context.Context, severity domain.AlertSeverity, clusterID, clusterName, title, message string) (*domain.Alert, error)
}

// LeaderChecker checks if this instance is the leader.
type LeaderChecker interface {
        IsLeader() bool
}

// NodeMetrics contains resource usage metrics for a node.
type NodeMetrics struct {
        NodeID       string
        Hostname     string
        TotalCPU     int32
        UsedCPU      float64
        CPUPercent   float64
        TotalMemory  int64
        UsedMemory   float64
        MemoryPercent float64
        VMCount      int
}

// Engine is the DRS engine that analyzes cluster balance and generates recommendations.
type Engine struct {
        config        config.DRSConfig
        nodeRepo      NodeRepository
        vmRepo        VMRepository
        recommRepo    RecommendationRepository
        alertService  AlertService
        leaderChecker LeaderChecker
        logger        *zap.Logger

        mu          sync.RWMutex
        isRunning   bool
        lastAnalysis time.Time
}

// NewEngine creates a new DRS engine.
func NewEngine(
        cfg config.DRSConfig,
        nodeRepo NodeRepository,
        vmRepo VMRepository,
        recommRepo RecommendationRepository,
        alertService AlertService,
        leaderChecker LeaderChecker,
        logger *zap.Logger,
) *Engine <span class="cov0" title="0">{
        return &amp;Engine{
                config:        cfg,
                nodeRepo:      nodeRepo,
                vmRepo:        vmRepo,
                recommRepo:    recommRepo,
                alertService:  alertService,
                leaderChecker: leaderChecker,
                logger:        logger.With(zap.String("component", "drs")),
        }
}</span>

// Start begins the DRS analysis loop.
func (e *Engine) Start(ctx context.Context) <span class="cov0" title="0">{
        if !e.config.Enabled </span><span class="cov0" title="0">{
                e.logger.Info("DRS engine disabled")
                return
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        if e.isRunning </span><span class="cov0" title="0">{
                e.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">e.isRunning = true
        e.mu.Unlock()

        e.logger.Info("Starting DRS engine",
                zap.Duration("interval", e.config.Interval),
                zap.String("automation_level", e.config.AutomationLevel),
                zap.Int("cpu_threshold", e.config.ThresholdCPU),
                zap.Int("memory_threshold", e.config.ThresholdMemory),
        )

        ticker := time.NewTicker(e.config.Interval)
        defer ticker.Stop()

        // Run initial analysis
        e.runAnalysis(ctx)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        e.logger.Info("DRS engine stopped")
                        e.mu.Lock()
                        e.isRunning = false
                        e.mu.Unlock()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        e.runAnalysis(ctx)</span>
                }
        }
}

// runAnalysis performs a single DRS analysis cycle.
func (e *Engine) runAnalysis(ctx context.Context) <span class="cov0" title="0">{
        // Only run on leader
        if e.leaderChecker != nil &amp;&amp; !e.leaderChecker.IsLeader() </span><span class="cov0" title="0">{
                e.logger.Debug("Not leader, skipping DRS analysis")
                return
        }</span>

        <span class="cov0" title="0">e.logger.Debug("Running DRS analysis")
        start := time.Now()

        // Get all schedulable nodes
        nodes, err := e.nodeRepo.ListSchedulable(ctx)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Error("Failed to list nodes", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">if len(nodes) &lt; 2 </span><span class="cov0" title="0">{
                e.logger.Debug("Not enough nodes for DRS", zap.Int("node_count", len(nodes)))
                return
        }</span>

        // Calculate metrics for each node
        <span class="cov0" title="0">var allMetrics []NodeMetrics
        for _, node := range nodes </span><span class="cov0" title="0">{
                metrics := e.calculateNodeMetrics(ctx, node)
                allMetrics = append(allMetrics, metrics)
        }</span>

        // Find imbalanced nodes
        <span class="cov0" title="0">recommendations := e.analyzeBalance(ctx, allMetrics)

        // Store recommendations
        for _, rec := range recommendations </span><span class="cov0" title="0">{
                if _, err := e.recommRepo.Create(ctx, rec); err != nil </span><span class="cov0" title="0">{
                        e.logger.Error("Failed to create recommendation", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">e.logger.Info("DRS recommendation created",
                        zap.String("id", rec.ID),
                        zap.String("priority", string(rec.Priority)),
                        zap.String("vm_id", rec.VMID),
                        zap.String("source_node", rec.SourceNodeName),
                        zap.String("target_node", rec.TargetNodeName),
                        zap.String("reason", rec.Reason),
                )

                // Auto-apply if automation level is "full"
                if e.config.AutomationLevel == "full" &amp;&amp; rec.Priority == domain.DRSPriorityCritical </span><span class="cov0" title="0">{
                        // TODO: Implement auto-migration
                        e.logger.Info("Auto-applying DRS recommendation", zap.String("id", rec.ID))
                }</span>
        }

        // Cleanup old recommendations
        <span class="cov0" title="0">if err := e.recommRepo.DeleteOld(ctx, time.Now().Add(-24*time.Hour)); err != nil </span><span class="cov0" title="0">{
                e.logger.Warn("Failed to cleanup old recommendations", zap.Error(err))
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        e.lastAnalysis = time.Now()
        e.mu.Unlock()

        e.logger.Debug("DRS analysis complete",
                zap.Duration("duration", time.Since(start)),
                zap.Int("recommendations", len(recommendations)),
        )</span>
}

// calculateNodeMetrics computes resource usage for a node.
func (e *Engine) calculateNodeMetrics(ctx context.Context, node *domain.Node) NodeMetrics <span class="cov0" title="0">{
        vms, err := e.vmRepo.ListByNodeID(ctx, node.ID)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warn("Failed to list VMs for node", zap.String("node_id", node.ID), zap.Error(err))
                return NodeMetrics{NodeID: node.ID, Hostname: node.Hostname}
        }</span>

        <span class="cov0" title="0">var usedCPU float64
        var usedMemory float64
        runningVMs := 0

        for _, vm := range vms </span><span class="cov0" title="0">{
                if vm.Status.State == domain.VMStateRunning || vm.Status.State == domain.VMStateStarting </span><span class="cov0" title="0">{
                        usedCPU += float64(vm.Spec.CPU.Cores)
                        usedMemory += float64(vm.Spec.Memory.SizeMiB)
                        runningVMs++
                }</span>
        }

        <span class="cov0" title="0">totalCPU := node.Spec.CPU.TotalCores()
        totalMemory := node.Spec.Memory.TotalMiB

        cpuPercent := 0.0
        if totalCPU &gt; 0 </span><span class="cov0" title="0">{
                cpuPercent = (usedCPU / float64(totalCPU)) * 100
        }</span>

        <span class="cov0" title="0">memPercent := 0.0
        if totalMemory &gt; 0 </span><span class="cov0" title="0">{
                memPercent = (usedMemory / float64(totalMemory)) * 100
        }</span>

        <span class="cov0" title="0">return NodeMetrics{
                NodeID:        node.ID,
                Hostname:      node.Hostname,
                TotalCPU:      totalCPU,
                UsedCPU:       usedCPU,
                CPUPercent:    cpuPercent,
                TotalMemory:   totalMemory,
                UsedMemory:    usedMemory,
                MemoryPercent: memPercent,
                VMCount:       runningVMs,
        }</span>
}

// analyzeBalance identifies imbalanced nodes and generates recommendations.
func (e *Engine) analyzeBalance(ctx context.Context, metrics []NodeMetrics) []*domain.DRSRecommendation <span class="cov0" title="0">{
        var recommendations []*domain.DRSRecommendation

        // Sort by CPU usage (highest first)
        sort.Slice(metrics, func(i, j int) bool </span><span class="cov0" title="0">{
                return metrics[i].CPUPercent &gt; metrics[j].CPUPercent
        }</span>)

        // Find overloaded and underloaded nodes
        <span class="cov0" title="0">var overloaded, underloaded []NodeMetrics
        for _, m := range metrics </span><span class="cov0" title="0">{
                if m.CPUPercent &gt; float64(e.config.ThresholdCPU) || m.MemoryPercent &gt; float64(e.config.ThresholdMemory) </span><span class="cov0" title="0">{
                        overloaded = append(overloaded, m)
                }</span> else<span class="cov0" title="0"> if m.CPUPercent &lt; float64(e.config.ThresholdCPU-20) &amp;&amp; m.MemoryPercent &lt; float64(e.config.ThresholdMemory-20) </span><span class="cov0" title="0">{
                        underloaded = append(underloaded, m)
                }</span>
        }

        // Generate migration recommendations
        <span class="cov0" title="0">for _, source := range overloaded </span><span class="cov0" title="0">{
                if len(underloaded) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find VMs on overloaded node
                <span class="cov0" title="0">vms, err := e.vmRepo.ListByNodeID(ctx, source.NodeID)
                if err != nil || len(vms) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Find best target
                <span class="cov0" title="0">target := underloaded[0] // Least loaded

                // Find a VM to migrate (prefer smaller VMs)
                var vmToMigrate *domain.VirtualMachine
                for _, vm := range vms </span><span class="cov0" title="0">{
                        if vm.Status.State == domain.VMStateRunning </span><span class="cov0" title="0">{
                                if vmToMigrate == nil || vm.Spec.CPU.Cores &lt; vmToMigrate.Spec.CPU.Cores </span><span class="cov0" title="0">{
                                        vmToMigrate = vm
                                }</span>
                        }
                }

                <span class="cov0" title="0">if vmToMigrate == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate priority
                <span class="cov0" title="0">priority := e.calculatePriority(source.CPUPercent, source.MemoryPercent)

                // Calculate impact
                cpuImpact := int32((source.CPUPercent - target.CPUPercent) / 2)
                memImpact := int32((source.MemoryPercent - target.MemoryPercent) / 2)

                rec := &amp;domain.DRSRecommendation{
                        ID:                 uuid.NewString(),
                        Priority:           priority,
                        RecommendationType: domain.DRSTypeMigrate,
                        Reason:             e.generateReason(source),
                        VMID:               vmToMigrate.ID,
                        VMName:             vmToMigrate.Name,
                        SourceNodeID:       source.NodeID,
                        SourceNodeName:     source.Hostname,
                        TargetNodeID:       target.NodeID,
                        TargetNodeName:     target.Hostname,
                        ImpactCPU:          cpuImpact,
                        ImpactMemory:       memImpact,
                        EstimatedDuration:  "2m",
                        Status:             domain.DRSStatusPending,
                        CreatedAt:          time.Now(),
                }

                recommendations = append(recommendations, rec)</span>
        }

        <span class="cov0" title="0">return recommendations</span>
}

// calculatePriority determines recommendation priority based on usage.
func (e *Engine) calculatePriority(cpuPercent, memPercent float64) domain.DRSPriority <span class="cov0" title="0">{
        maxPercent := cpuPercent
        if memPercent &gt; maxPercent </span><span class="cov0" title="0">{
                maxPercent = memPercent
        }</span>

        <span class="cov0" title="0">switch </span>{
        case maxPercent &gt;= 95:<span class="cov0" title="0">
                return domain.DRSPriorityCritical</span>
        case maxPercent &gt;= 90:<span class="cov0" title="0">
                return domain.DRSPriorityHigh</span>
        case maxPercent &gt;= 85:<span class="cov0" title="0">
                return domain.DRSPriorityMedium</span>
        default:<span class="cov0" title="0">
                return domain.DRSPriorityLow</span>
        }
}

// generateReason creates a human-readable reason for the recommendation.
func (e *Engine) generateReason(source NodeMetrics) string <span class="cov0" title="0">{
        if source.CPUPercent &gt; float64(e.config.ThresholdCPU) &amp;&amp; source.MemoryPercent &gt; float64(e.config.ThresholdMemory) </span><span class="cov0" title="0">{
                return fmt.Sprintf("Node %s is overloaded (CPU: %.1f%%, Memory: %.1f%%)", source.Hostname, source.CPUPercent, source.MemoryPercent)
        }</span> else<span class="cov0" title="0"> if source.CPUPercent &gt; float64(e.config.ThresholdCPU) </span><span class="cov0" title="0">{
                return fmt.Sprintf("Node %s has high CPU usage (%.1f%%)", source.Hostname, source.CPUPercent)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("Node %s has high memory usage (%.1f%%)", source.Hostname, source.MemoryPercent)
        }</span>
}

// GetPendingRecommendations returns all pending recommendations.
func (e *Engine) GetPendingRecommendations(ctx context.Context, limit int) ([]*domain.DRSRecommendation, error) <span class="cov0" title="0">{
        return e.recommRepo.List(ctx, domain.DRSStatusPending, limit)
}</span>

// ApproveRecommendation marks a recommendation as approved.
func (e *Engine) ApproveRecommendation(ctx context.Context, id, approvedBy string) (*domain.DRSRecommendation, error) <span class="cov0" title="0">{
        rec, err := e.recommRepo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rec.Status = domain.DRSStatusApproved
        return e.recommRepo.Update(ctx, rec)</span>
}

// ApplyRecommendation executes a recommendation (triggers migration).
func (e *Engine) ApplyRecommendation(ctx context.Context, id, appliedBy string) (*domain.DRSRecommendation, error) <span class="cov0" title="0">{
        rec, err := e.recommRepo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: Trigger actual VM migration via scheduler

        <span class="cov0" title="0">now := time.Now()
        rec.Status = domain.DRSStatusApplied
        rec.AppliedAt = &amp;now
        rec.AppliedBy = appliedBy

        return e.recommRepo.Update(ctx, rec)</span>
}

// RejectRecommendation marks a recommendation as rejected.
func (e *Engine) RejectRecommendation(ctx context.Context, id string) (*domain.DRSRecommendation, error) <span class="cov0" title="0">{
        rec, err := e.recommRepo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rec.Status = domain.DRSStatusRejected
        return e.recommRepo.Update(ctx, rec)</span>
}

// GetLastAnalysisTime returns when the last analysis was performed.
func (e *Engine) GetLastAnalysisTime() time.Time <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.lastAnalysis
}</span>

// IsRunning returns true if the DRS engine is running.
func (e *Engine) IsRunning() bool <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.isRunning
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package ha implements High Availability management for VMs.
package ha

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/config"
        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// NodeRepository defines the interface for node data access.
type NodeRepository interface {
        Get(ctx context.Context, id string) (*domain.Node, error)
        List(ctx context.Context, filter interface{}) ([]*domain.Node, error)
        ListSchedulable(ctx context.Context) ([]*domain.Node, error)
        UpdateStatus(ctx context.Context, id string, status domain.NodeStatus) error
}

// VMRepository defines the interface for VM data access.
type VMRepository interface {
        Get(ctx context.Context, id string) (*domain.VirtualMachine, error)
        ListByNodeID(ctx context.Context, nodeID string) ([]*domain.VirtualMachine, error)
        UpdateStatus(ctx context.Context, id string, status domain.VMStatus) error
}

// Scheduler provides VM placement decisions.
type Scheduler interface {
        FindBestNode(ctx context.Context, vm *domain.VirtualMachine, excludeNodes []string) (string, error)
}

// VMController controls VM lifecycle.
type VMController interface {
        StartVM(ctx context.Context, vmID string, targetNodeID string) error
}

// AlertService creates alerts for HA events.
type AlertService interface {
        VMAlert(ctx context.Context, severity domain.AlertSeverity, vmID, vmName, title, message string) (*domain.Alert, error)
        NodeAlert(ctx context.Context, severity domain.AlertSeverity, nodeID, nodeName, title, message string) (*domain.Alert, error)
}

// LeaderChecker checks if this instance is the leader.
type LeaderChecker interface {
        IsLeader() bool
}

// NodeState tracks the health state of a node.
type NodeState struct {
        NodeID        string
        Hostname      string
        LastHeartbeat time.Time
        FailedChecks  int
        Status        NodeHealthStatus
}

// NodeHealthStatus represents the health status of a node.
type NodeHealthStatus string

const (
        NodeHealthStatusHealthy     NodeHealthStatus = "HEALTHY"
        NodeHealthStatusUnknown     NodeHealthStatus = "UNKNOWN"
        NodeHealthStatusUnreachable NodeHealthStatus = "UNREACHABLE"
        NodeHealthStatusFailed      NodeHealthStatus = "FAILED"
)

// Manager is the HA manager that monitors nodes and restarts failed VMs.
type Manager struct {
        config        config.HAConfig
        nodeRepo      NodeRepository
        vmRepo        VMRepository
        scheduler     Scheduler
        vmController  VMController
        alertService  AlertService
        leaderChecker LeaderChecker
        logger        *zap.Logger

        mu         sync.RWMutex
        nodeStates map[string]*NodeState
        isRunning  bool
}

// NewManager creates a new HA manager.
func NewManager(
        cfg config.HAConfig,
        nodeRepo NodeRepository,
        vmRepo VMRepository,
        scheduler Scheduler,
        vmController VMController,
        alertService AlertService,
        leaderChecker LeaderChecker,
        logger *zap.Logger,
) *Manager <span class="cov0" title="0">{
        return &amp;Manager{
                config:        cfg,
                nodeRepo:      nodeRepo,
                vmRepo:        vmRepo,
                scheduler:     scheduler,
                vmController:  vmController,
                alertService:  alertService,
                leaderChecker: leaderChecker,
                logger:        logger.With(zap.String("component", "ha")),
                nodeStates:    make(map[string]*NodeState),
        }
}</span>

// Start begins the HA monitoring loop.
func (m *Manager) Start(ctx context.Context) <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                m.logger.Info("HA manager disabled")
                return
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        if m.isRunning </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">m.isRunning = true
        m.mu.Unlock()

        m.logger.Info("Starting HA manager",
                zap.Duration("check_interval", m.config.CheckInterval),
                zap.Int("failure_threshold", m.config.FailureThreshold),
        )

        ticker := time.NewTicker(m.config.CheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        m.logger.Info("HA manager stopped")
                        m.mu.Lock()
                        m.isRunning = false
                        m.mu.Unlock()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.checkNodes(ctx)</span>
                }
        }
}

// checkNodes monitors all nodes and triggers failover if needed.
func (m *Manager) checkNodes(ctx context.Context) <span class="cov0" title="0">{
        // Only run on leader
        if m.leaderChecker != nil &amp;&amp; !m.leaderChecker.IsLeader() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nodes, err := m.nodeRepo.ListSchedulable(ctx)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to list nodes", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">for _, node := range nodes </span><span class="cov0" title="0">{
                m.checkNode(ctx, node)
        }</span>
}

// checkNode checks a single node's health.
func (m *Manager) checkNode(ctx context.Context, node *domain.Node) <span class="cov0" title="0">{
        m.mu.Lock()
        state, exists := m.nodeStates[node.ID]
        if !exists </span><span class="cov0" title="0">{
                state = &amp;NodeState{
                        NodeID:   node.ID,
                        Hostname: node.Hostname,
                        Status:   NodeHealthStatusHealthy,
                }
                m.nodeStates[node.ID] = state
        }</span>
        <span class="cov0" title="0">m.mu.Unlock()

        // Check heartbeat age
        var heartbeatAge time.Duration
        if node.LastHeartbeat != nil </span><span class="cov0" title="0">{
                heartbeatAge = time.Since(*node.LastHeartbeat)
        }</span> else<span class="cov0" title="0"> {
                heartbeatAge = time.Hour * 24 // No heartbeat ever received
        }</span>
        <span class="cov0" title="0">isHealthy := heartbeatAge &lt; m.config.HeartbeatTimeout

        if isHealthy </span><span class="cov0" title="0">{
                // Node is healthy
                if state.Status != NodeHealthStatusHealthy </span><span class="cov0" title="0">{
                        m.logger.Info("Node recovered",
                                zap.String("node_id", node.ID),
                                zap.String("hostname", node.Hostname),
                        )
                }</span>
                <span class="cov0" title="0">if node.LastHeartbeat != nil </span><span class="cov0" title="0">{
                        state.LastHeartbeat = *node.LastHeartbeat
                }</span>
                <span class="cov0" title="0">state.FailedChecks = 0
                state.Status = NodeHealthStatusHealthy
                return</span>
        }

        // Node might be failing
        <span class="cov0" title="0">state.FailedChecks++
        m.logger.Warn("Node heartbeat missing",
                zap.String("node_id", node.ID),
                zap.String("hostname", node.Hostname),
                zap.Duration("heartbeat_age", heartbeatAge),
                zap.Int("failed_checks", state.FailedChecks),
        )

        if state.FailedChecks &lt; m.config.FailureThreshold </span><span class="cov0" title="0">{
                state.Status = NodeHealthStatusUnknown
                return
        }</span>

        // Node has failed
        <span class="cov0" title="0">if state.Status != NodeHealthStatusFailed </span><span class="cov0" title="0">{
                state.Status = NodeHealthStatusFailed
                m.logger.Error("Node declared failed",
                        zap.String("node_id", node.ID),
                        zap.String("hostname", node.Hostname),
                )

                // Create alert
                if m.alertService != nil </span><span class="cov0" title="0">{
                        m.alertService.NodeAlert(ctx, domain.AlertSeverityCritical,
                                node.ID, node.Hostname,
                                "Node Failed",
                                fmt.Sprintf("Node %s has failed and is unreachable. HA failover initiated.", node.Hostname),
                        )
                }</span>

                // Trigger failover
                <span class="cov0" title="0">m.triggerFailover(ctx, node)</span>
        }
}

// triggerFailover restarts VMs from a failed node on other nodes.
func (m *Manager) triggerFailover(ctx context.Context, failedNode *domain.Node) <span class="cov0" title="0">{
        m.logger.Info("Initiating HA failover",
                zap.String("failed_node_id", failedNode.ID),
                zap.String("failed_node_hostname", failedNode.Hostname),
        )

        // Get VMs on failed node
        vms, err := m.vmRepo.ListByNodeID(ctx, failedNode.ID)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to list VMs on failed node", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">if len(vms) == 0 </span><span class="cov0" title="0">{
                m.logger.Info("No VMs to failover on failed node")
                return
        }</span>

        // Filter for HA-enabled VMs that were running
        <span class="cov0" title="0">var haVMs []*domain.VirtualMachine
        for _, vm := range vms </span><span class="cov0" title="0">{
                if vm.Status.State == domain.VMStateRunning &amp;&amp; vm.Spec.HAPolicy != nil &amp;&amp; vm.Spec.HAPolicy.AutoRestart </span><span class="cov0" title="0">{
                        haVMs = append(haVMs, vm)
                }</span>
        }

        <span class="cov0" title="0">m.logger.Info("Found HA-enabled VMs to failover",
                zap.Int("total_vms", len(vms)),
                zap.Int("ha_vms", len(haVMs)),
        )

        // Sort by priority (higher priority first)
        // VMs with RestartPriority 1 should start before 2, etc.

        // Restart VMs on other nodes
        for _, vm := range haVMs </span><span class="cov0" title="0">{
                m.failoverVM(ctx, vm, failedNode.ID)
        }</span>

        // Update node status
        <span class="cov0" title="0">failedNode.Status.Phase = domain.NodePhaseNotReady
        if err := m.nodeRepo.UpdateStatus(ctx, failedNode.ID, failedNode.Status); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to update node status", zap.Error(err))
        }</span>
}

// failoverVM restarts a single VM on another node.
func (m *Manager) failoverVM(ctx context.Context, vm *domain.VirtualMachine, failedNodeID string) <span class="cov0" title="0">{
        m.logger.Info("Failing over VM",
                zap.String("vm_id", vm.ID),
                zap.String("vm_name", vm.Name),
        )

        // Find a new node
        targetNodeID, err := m.scheduler.FindBestNode(ctx, vm, []string{failedNodeID})
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to find target node for VM",
                        zap.String("vm_id", vm.ID),
                        zap.Error(err),
                )

                // Create alert
                if m.alertService != nil </span><span class="cov0" title="0">{
                        m.alertService.VMAlert(ctx, domain.AlertSeverityCritical,
                                vm.ID, vm.Name,
                                "VM Failover Failed",
                                fmt.Sprintf("Failed to find available host for VM %s during HA failover.", vm.Name),
                        )
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Start VM on new node
        <span class="cov0" title="0">if m.vmController != nil </span><span class="cov0" title="0">{
                if err := m.vmController.StartVM(ctx, vm.ID, targetNodeID); err != nil </span><span class="cov0" title="0">{
                        m.logger.Error("Failed to start VM on new node",
                                zap.String("vm_id", vm.ID),
                                zap.String("target_node_id", targetNodeID),
                                zap.Error(err),
                        )
                        return
                }</span>
        }

        // Update VM status
        <span class="cov0" title="0">vm.Status.NodeID = targetNodeID
        vm.Status.State = domain.VMStateStarting
        vm.Status.Message = fmt.Sprintf("HA failover from node %s", failedNodeID)

        if err := m.vmRepo.UpdateStatus(ctx, vm.ID, vm.Status); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to update VM status", zap.Error(err))
        }</span>

        <span class="cov0" title="0">m.logger.Info("VM failover initiated",
                zap.String("vm_id", vm.ID),
                zap.String("vm_name", vm.Name),
                zap.String("target_node_id", targetNodeID),
        )

        // Create info alert
        if m.alertService != nil </span><span class="cov0" title="0">{
                m.alertService.VMAlert(ctx, domain.AlertSeverityInfo,
                        vm.ID, vm.Name,
                        "VM Failed Over",
                        fmt.Sprintf("VM %s has been failed over to a new host.", vm.Name),
                )
        }</span>
}

// GetNodeState returns the current health state of a node.
func (m *Manager) GetNodeState(nodeID string) (*NodeState, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        state, exists := m.nodeStates[nodeID]
        return state, exists
}</span>

// GetAllNodeStates returns all node states.
func (m *Manager) GetAllNodeStates() map[string]*NodeState <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]*NodeState, len(m.nodeStates))
        for k, v := range m.nodeStates </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// IsRunning returns true if the HA manager is running.
func (m *Manager) IsRunning() bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.isRunning
}</span>

// ManualFailover manually triggers failover for a node.
func (m *Manager) ManualFailover(ctx context.Context, nodeID string) error <span class="cov0" title="0">{
        node, err := m.nodeRepo.Get(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("node not found: %w", err)
        }</span>

        <span class="cov0" title="0">m.logger.Info("Manual failover initiated", zap.String("node_id", nodeID))

        // Mark node as failed in our state
        m.mu.Lock()
        state, exists := m.nodeStates[nodeID]
        if !exists </span><span class="cov0" title="0">{
                state = &amp;NodeState{
                        NodeID:   node.ID,
                        Hostname: node.Hostname,
                }
                m.nodeStates[nodeID] = state
        }</span>
        <span class="cov0" title="0">state.Status = NodeHealthStatusFailed
        state.FailedChecks = m.config.FailureThreshold
        m.mu.Unlock()

        // Trigger failover
        m.triggerFailover(ctx, node)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package etcd provides etcd client functionality for distributed coordination.
package etcd

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"
        "go.etcd.io/etcd/client/v3/concurrency"
        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/config"
)

// ErrKeyNotFound indicates the key was not found in etcd.
var ErrKeyNotFound = errors.New("key not found")

// Client wraps an etcd client with leader election and distributed locking.
type Client struct {
        client  *clientv3.Client
        session *concurrency.Session
        logger  *zap.Logger
}

// NewClient creates a new etcd client.
func NewClient(cfg config.EtcdConfig, logger *zap.Logger) (*Client, error) <span class="cov0" title="0">{
        client, err := clientv3.New(clientv3.Config{
                Endpoints:   cfg.Endpoints,
                DialTimeout: cfg.DialTimeout,
                Username:    cfg.Username,
                Password:    cfg.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to etcd: %w", err)
        }</span>

        // Create a session for distributed coordination
        <span class="cov0" title="0">session, err := concurrency.NewSession(client, concurrency.WithTTL(30))
        if err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to create etcd session: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Connected to etcd", zap.Strings("endpoints", cfg.Endpoints))

        return &amp;Client{
                client:  client,
                session: session,
                logger:  logger,
        }, nil</span>
}

// Close closes the etcd client and session.
func (c *Client) Close() error <span class="cov0" title="0">{
        if c.session != nil </span><span class="cov0" title="0">{
                c.session.Close()
        }</span>
        <span class="cov0" title="0">return c.client.Close()</span>
}

// Health checks if etcd is reachable.
func (c *Client) Health(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        _, err := c.client.Status(ctx, c.client.Endpoints()[0])
        return err
}</span>

// =============================================================================
// Key-Value Operations
// =============================================================================

// Put stores a value in etcd.
func (c *Client) Put(ctx context.Context, key string, value interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.client.Put(ctx, key, string(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to put key: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a value from etcd.
func (c *Client) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        resp, err := c.client.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get key: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(resp.Kvs[0].Value, dest)</span>
}

// Delete removes a key from etcd.
func (c *Client) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        _, err := c.client.Delete(ctx, key)
        return err
}</span>

// List returns all values with a given key prefix.
func (c *Client) List(ctx context.Context, prefix string, dest interface{}) error <span class="cov0" title="0">{
        resp, err := c.client.Get(ctx, prefix, clientv3.WithPrefix())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list keys: %w", err)
        }</span>

        // Collect values into a slice of raw messages
        <span class="cov0" title="0">var values []json.RawMessage
        for _, kv := range resp.Kvs </span><span class="cov0" title="0">{
                values = append(values, json.RawMessage(kv.Value))
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(values)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(data, dest)</span>
}

// =============================================================================
// Watch Operations
// =============================================================================

// WatchEvent represents an etcd watch event.
type WatchEvent struct {
        Type  EventType
        Key   string
        Value []byte
}

// EventType represents the type of watch event.
type EventType string

const (
        EventTypePut    EventType = "PUT"
        EventTypeDelete EventType = "DELETE"
)

// Watch watches for changes on a key or prefix.
func (c *Client) Watch(ctx context.Context, key string, prefix bool) &lt;-chan WatchEvent <span class="cov0" title="0">{
        events := make(chan WatchEvent, 10)

        opts := []clientv3.OpOption{}
        if prefix </span><span class="cov0" title="0">{
                opts = append(opts, clientv3.WithPrefix())
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(events)

                watchCh := c.client.Watch(ctx, key, opts...)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case resp, ok := &lt;-watchCh:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">for _, ev := range resp.Events </span><span class="cov0" title="0">{
                                        eventType := EventTypePut
                                        if ev.Type == clientv3.EventTypeDelete </span><span class="cov0" title="0">{
                                                eventType = EventTypeDelete
                                        }</span>
                                        <span class="cov0" title="0">events &lt;- WatchEvent{
                                                Type:  eventType,
                                                Key:   string(ev.Kv.Key),
                                                Value: ev.Kv.Value,
                                        }</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return events</span>
}

// =============================================================================
// Distributed Locking
// =============================================================================

// Lock represents a distributed lock.
type Lock struct {
        mutex *concurrency.Mutex
}

// AcquireLock acquires a distributed lock.
func (c *Client) AcquireLock(ctx context.Context, key string) (*Lock, error) <span class="cov0" title="0">{
        mutex := concurrency.NewMutex(c.session, fmt.Sprintf("/locks/%s", key))

        if err := mutex.Lock(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to acquire lock: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Acquired lock", zap.String("key", key))

        return &amp;Lock{mutex: mutex}, nil</span>
}

// TryAcquireLock tries to acquire a lock with a timeout.
func (c *Client) TryAcquireLock(ctx context.Context, key string, timeout time.Duration) (*Lock, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        return c.AcquireLock(ctx, key)
}</span>

// Unlock releases a distributed lock.
func (l *Lock) Unlock(ctx context.Context) error <span class="cov0" title="0">{
        if l.mutex == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return l.mutex.Unlock(ctx)</span>
}

// =============================================================================
// Leader Election
// =============================================================================

// Leader represents a leader election participant.
type Leader struct {
        election *concurrency.Election
        client   *Client
        name     string
        isLeader bool
}

// LeaderCallback is called when leadership status changes.
type LeaderCallback func(isLeader bool)

// CampaignForLeader starts a leader election campaign.
func (c *Client) CampaignForLeader(ctx context.Context, name string, callback LeaderCallback) (*Leader, error) <span class="cov0" title="0">{
        election := concurrency.NewElection(c.session, fmt.Sprintf("/leaders/%s", name))

        leader := &amp;Leader{
                election: election,
                client:   c,
                name:     name,
                isLeader: false,
        }

        // Start campaign in background
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if err := election.Campaign(ctx, fmt.Sprintf("%d", c.session.Lease())); err != nil </span><span class="cov0" title="0">{
                                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">c.logger.Warn("Leader campaign failed, retrying", zap.Error(err))
                                        time.Sleep(5 * time.Second)
                                        continue</span>
                                }

                                // We became the leader
                                <span class="cov0" title="0">leader.isLeader = true
                                c.logger.Info("Became leader", zap.String("name", name))
                                if callback != nil </span><span class="cov0" title="0">{
                                        callback(true)
                                }</span>

                                // Wait until we lose leadership
                                <span class="cov0" title="0">select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-c.session.Done():<span class="cov0" title="0">
                                        leader.isLeader = false
                                        c.logger.Info("Lost leadership", zap.String("name", name))
                                        if callback != nil </span><span class="cov0" title="0">{
                                                callback(false)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return leader, nil</span>
}

// IsLeader returns true if this instance is currently the leader.
func (l *Leader) IsLeader() bool <span class="cov0" title="0">{
        return l.isLeader
}</span>

// Resign resigns from leadership.
func (l *Leader) Resign(ctx context.Context) error <span class="cov0" title="0">{
        if l.election == nil || !l.isLeader </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := l.election.Resign(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resign: %w", err)
        }</span>

        <span class="cov0" title="0">l.isLeader = false
        l.client.logger.Info("Resigned from leadership", zap.String("name", l.name))
        return nil</span>
}

// GetLeader returns the current leader's value.
func (c *Client) GetLeader(ctx context.Context, name string) (string, error) <span class="cov0" title="0">{
        election := concurrency.NewElection(c.session, fmt.Sprintf("/leaders/%s", name))

        resp, err := election.Leader(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get leader: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return "", ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">return string(resp.Kvs[0].Value), nil</span>
}

// =============================================================================
// Node State Management
// =============================================================================

// NodeState represents the state of a node in the cluster.
type NodeState struct {
        ID           string    `json:"id"`
        Hostname     string    `json:"hostname"`
        ManagementIP string    `json:"management_ip"`
        Ready        bool      `json:"ready"`
        LastSeen     time.Time `json:"last_seen"`
}

// RegisterNode registers a node in the cluster.
func (c *Client) RegisterNode(ctx context.Context, state NodeState) error <span class="cov0" title="0">{
        state.LastSeen = time.Now()
        key := fmt.Sprintf("/nodes/%s", state.ID)
        return c.Put(ctx, key, state)
}</span>

// UpdateNodeHeartbeat updates a node's last seen time.
func (c *Client) UpdateNodeHeartbeat(ctx context.Context, nodeID string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("/nodes/%s", nodeID)

        var state NodeState
        if err := c.Get(ctx, key, &amp;state); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">state.LastSeen = time.Now()
        return c.Put(ctx, key, state)</span>
}

// GetNodes returns all registered nodes.
func (c *Client) GetNodes(ctx context.Context) ([]NodeState, error) <span class="cov0" title="0">{
        resp, err := c.client.Get(ctx, "/nodes/", clientv3.WithPrefix())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get nodes: %w", err)
        }</span>

        <span class="cov0" title="0">var nodes []NodeState
        for _, kv := range resp.Kvs </span><span class="cov0" title="0">{
                var state NodeState
                if err := json.Unmarshal(kv.Value, &amp;state); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Failed to unmarshal node state", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">nodes = append(nodes, state)</span>
        }

        <span class="cov0" title="0">return nodes, nil</span>
}

// DeregisterNode removes a node from the cluster.
func (c *Client) DeregisterNode(ctx context.Context, nodeID string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("/nodes/%s", nodeID)
        return c.Delete(ctx, key)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package redis provides Redis caching and pub/sub functionality.
package redis

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/config"
        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// ErrCacheMiss indicates the key was not found in cache.
var ErrCacheMiss = errors.New("cache miss")

// Cache wraps a Redis client for caching operations.
type Cache struct {
        client *redis.Client
        logger *zap.Logger
}

// NewCache creates a new Redis cache connection.
func NewCache(cfg config.RedisConfig, logger *zap.Logger) (*Cache, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Address(),
                Password: cfg.Password,
                DB:       cfg.DB,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Connected to Redis", zap.String("addr", cfg.Address()))

        return &amp;Cache{client: client, logger: logger}, nil</span>
}

// Close closes the Redis connection.
func (c *Cache) Close() error <span class="cov0" title="0">{
        return c.client.Close()
}</span>

// Health checks if Redis is reachable.
func (c *Cache) Health(ctx context.Context) error <span class="cov0" title="0">{
        return c.client.Ping(ctx).Err()
}</span>

// =============================================================================
// Generic Cache Operations
// =============================================================================

// Get retrieves a value from cache and unmarshals it into dest.
func (c *Cache) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        val, err := c.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return ErrCacheMiss
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis get error: %w", err)
        }</span>

        <span class="cov0" title="0">return json.Unmarshal([]byte(val), dest)</span>
}

// Set stores a value in cache with a TTL.
func (c *Cache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">return c.client.Set(ctx, key, data, ttl).Err()</span>
}

// Delete removes a key from cache.
func (c *Cache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        return c.client.Del(ctx, key).Err()
}</span>

// DeletePattern removes all keys matching a pattern.
func (c *Cache) DeletePattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        iter := c.client.Scan(ctx, 0, pattern, 100).Iterator()
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                if err := c.client.Del(ctx, iter.Val()).Err(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Failed to delete key", zap.String("key", iter.Val()), zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">return iter.Err()</span>
}

// =============================================================================
// VM Cache Operations
// =============================================================================

const vmCacheTTL = 5 * time.Minute

// GetVM retrieves a VM from cache.
func (c *Cache) GetVM(ctx context.Context, id string) (*domain.VirtualMachine, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("vm:%s", id)
        var vm domain.VirtualMachine
        if err := c.Get(ctx, key, &amp;vm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;vm, nil</span>
}

// SetVM stores a VM in cache.
func (c *Cache) SetVM(ctx context.Context, vm *domain.VirtualMachine) error <span class="cov0" title="0">{
        key := fmt.Sprintf("vm:%s", vm.ID)
        return c.Set(ctx, key, vm, vmCacheTTL)
}</span>

// InvalidateVM removes a VM from cache.
func (c *Cache) InvalidateVM(ctx context.Context, id string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("vm:%s", id)
        return c.Delete(ctx, key)
}</span>

// InvalidateVMsByProject invalidates all VMs in a project.
func (c *Cache) InvalidateVMsByProject(ctx context.Context, projectID string) error <span class="cov0" title="0">{
        return c.DeletePattern(ctx, fmt.Sprintf("vm:*:project:%s", projectID))
}</span>

// =============================================================================
// Node Cache Operations
// =============================================================================

const nodeCacheTTL = 1 * time.Minute // Shorter TTL for node status

// GetNode retrieves a node from cache.
func (c *Cache) GetNode(ctx context.Context, id string) (*domain.Node, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("node:%s", id)
        var node domain.Node
        if err := c.Get(ctx, key, &amp;node); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;node, nil</span>
}

// SetNode stores a node in cache.
func (c *Cache) SetNode(ctx context.Context, node *domain.Node) error <span class="cov0" title="0">{
        key := fmt.Sprintf("node:%s", node.ID)
        return c.Set(ctx, key, node, nodeCacheTTL)
}</span>

// InvalidateNode removes a node from cache.
func (c *Cache) InvalidateNode(ctx context.Context, id string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("node:%s", id)
        return c.Delete(ctx, key)
}</span>

// =============================================================================
// Pub/Sub Operations for Real-time Updates
// =============================================================================

// Event represents a real-time event.
type Event struct {
        Type       string      `json:"type"`       // "vm.created", "vm.started", "node.updated", etc.
        ResourceID string      `json:"resource_id"`
        Data       interface{} `json:"data,omitempty"`
        Timestamp  time.Time   `json:"timestamp"`
}

// Publish publishes an event to a channel.
func (c *Cache) Publish(ctx context.Context, channel string, event Event) error <span class="cov0" title="0">{
        event.Timestamp = time.Now()
        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>
        <span class="cov0" title="0">return c.client.Publish(ctx, channel, data).Err()</span>
}

// Subscribe subscribes to a channel and returns a message channel.
func (c *Cache) Subscribe(ctx context.Context, channels ...string) &lt;-chan Event <span class="cov0" title="0">{
        pubsub := c.client.Subscribe(ctx, channels...)
        events := make(chan Event, 100)

        go func() </span><span class="cov0" title="0">{
                defer close(events)
                defer pubsub.Close()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case msg := &lt;-pubsub.Channel():<span class="cov0" title="0">
                                var event Event
                                if err := json.Unmarshal([]byte(msg.Payload), &amp;event); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Warn("Failed to unmarshal event", zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">events &lt;- event</span>
                        }
                }
        }()

        <span class="cov0" title="0">return events</span>
}

// PublishVMEvent publishes a VM-related event.
func (c *Cache) PublishVMEvent(ctx context.Context, eventType string, vm *domain.VirtualMachine) error <span class="cov0" title="0">{
        return c.Publish(ctx, "events:vm", Event{
                Type:       eventType,
                ResourceID: vm.ID,
                Data:       vm,
        })
}</span>

// PublishNodeEvent publishes a node-related event.
func (c *Cache) PublishNodeEvent(ctx context.Context, eventType string, node *domain.Node) error <span class="cov0" title="0">{
        return c.Publish(ctx, "events:node", Event{
                Type:       eventType,
                ResourceID: node.ID,
                Data:       node,
        })
}</span>

// =============================================================================
// Session/Token Storage
// =============================================================================

const sessionTTL = 24 * time.Hour

// SetSession stores a user session.
func (c *Cache) SetSession(ctx context.Context, sessionID string, userID string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("session:%s", sessionID)
        return c.client.Set(ctx, key, userID, sessionTTL).Err()
}</span>

// GetSession retrieves a user session.
func (c *Cache) GetSession(ctx context.Context, sessionID string) (string, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("session:%s", sessionID)
        userID, err := c.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return userID, err</span>
}

// DeleteSession removes a user session.
func (c *Cache) DeleteSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("session:%s", sessionID)
        return c.client.Del(ctx, key).Err()
}</span>

// =============================================================================
// Rate Limiting
// =============================================================================

// RateLimitResult contains the result of a rate limit check.
type RateLimitResult struct {
        Allowed   bool
        Remaining int64
        ResetAt   time.Time
}

// CheckRateLimit checks if a request is within rate limits.
// Uses a sliding window algorithm.
func (c *Cache) CheckRateLimit(ctx context.Context, key string, limit int64, window time.Duration) (*RateLimitResult, error) <span class="cov0" title="0">{
        now := time.Now()
        windowStart := now.Add(-window)

        pipe := c.client.Pipeline()

        // Remove old entries
        pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart.UnixNano()))

        // Count current entries
        countCmd := pipe.ZCard(ctx, key)

        // Add current request
        pipe.ZAdd(ctx, key, redis.Z{
                Score:  float64(now.UnixNano()),
                Member: now.UnixNano(),
        })

        // Set expiry
        pipe.Expire(ctx, key, window)

        _, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limit check failed: %w", err)
        }</span>

        <span class="cov0" title="0">count := countCmd.Val()
        allowed := count &lt; limit
        remaining := limit - count - 1
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov0" title="0">return &amp;RateLimitResult{
                Allowed:   allowed,
                Remaining: remaining,
                ResetAt:   now.Add(window),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package scheduler implements VM placement logic for the Quantixkvm control plane.
// It determines which host should run a new VM based on resource availability,
// placement policies, and scoring strategies.
package scheduler

// Config holds the scheduler configuration.
type Config struct {
        // PlacementStrategy determines how VMs are distributed across nodes.
        // - "spread": Distribute VMs evenly across nodes (better HA)
        // - "pack": Consolidate VMs on fewer nodes (better resource efficiency)
        PlacementStrategy string `mapstructure:"placement_strategy"`

        // OvercommitCPU is the CPU overcommit ratio (e.g., 2.0 = 2x overcommit)
        OvercommitCPU float64 `mapstructure:"overcommit_cpu"`

        // OvercommitMemory is the memory overcommit ratio (e.g., 1.5 = 1.5x overcommit)
        OvercommitMemory float64 `mapstructure:"overcommit_memory"`

        // ReservedCPUCores is the number of CPU cores reserved for the hypervisor
        ReservedCPUCores int `mapstructure:"reserved_cpu_cores"`

        // ReservedMemoryMiB is the amount of memory in MiB reserved for the hypervisor
        ReservedMemoryMiB int `mapstructure:"reserved_memory_mib"`

        // EnableNUMAPlacement enables NUMA-aware placement
        EnableNUMAPlacement bool `mapstructure:"enable_numa_placement"`
}

// DefaultConfig returns the default scheduler configuration.
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                PlacementStrategy: "spread",
                OvercommitCPU:     1.0, // No overcommit by default
                OvercommitMemory:  1.0, // No overcommit by default
                ReservedCPUCores:  1,
                ReservedMemoryMiB: 1024, // 1 GiB reserved for hypervisor
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package scheduler implements VM placement logic.
package scheduler

import (
        "context"
        "fmt"
        "sort"

        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        computev1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/compute/v1"
)

// Scheduler determines which host should run a new VM.
type Scheduler struct {
        nodeRepo NodeRepository
        vmRepo   VMRepository
        config   Config
        logger   *zap.Logger
}

// New creates a new Scheduler instance.
func New(nodeRepo NodeRepository, vmRepo VMRepository, config Config, logger *zap.Logger) *Scheduler <span class="cov8" title="1">{
        return &amp;Scheduler{
                nodeRepo: nodeRepo,
                vmRepo:   vmRepo,
                config:   config,
                logger:   logger.With(zap.String("component", "scheduler")),
        }
}</span>

// ScheduleResult contains the scheduling decision.
type ScheduleResult struct {
        NodeID   string
        Hostname string
        Score    float64
        Reason   string
}

// Schedule finds the best node for a VM with the given specification.
func (s *Scheduler) Schedule(ctx context.Context, spec *computev1.VmSpec) (*ScheduleResult, error) <span class="cov8" title="1">{
        logger := s.logger.With(
                zap.Uint32("requested_cpu_cores", spec.Cpu.GetCores()),
                zap.Uint64("requested_memory_mib", spec.Memory.GetSizeMib()),
        )
        logger.Info("Starting scheduling for VM")

        // 1. Get all schedulable nodes
        nodes, err := s.nodeRepo.ListSchedulable(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list schedulable nodes", zap.Error(err))
                return nil, fmt.Errorf("failed to list schedulable nodes: %w", err)
        }</span>

        <span class="cov8" title="1">if len(nodes) == 0 </span><span class="cov8" title="1">{
                logger.Warn("No schedulable nodes available")
                return nil, fmt.Errorf("no schedulable nodes available")
        }</span>

        <span class="cov8" title="1">logger.Debug("Found schedulable nodes", zap.Int("count", len(nodes)))

        // 2. Filter nodes by predicates (hard constraints)
        var feasible []*domain.Node
        for _, node := range nodes </span><span class="cov8" title="1">{
                if s.checkPredicates(ctx, node, spec) </span><span class="cov8" title="1">{
                        feasible = append(feasible, node)
                }</span>
        }

        <span class="cov8" title="1">if len(feasible) == 0 </span><span class="cov8" title="1">{
                logger.Warn("No nodes satisfy scheduling requirements",
                        zap.Int("total_nodes", len(nodes)),
                )
                return nil, fmt.Errorf("no nodes satisfy scheduling requirements (checked %d nodes)", len(nodes))
        }</span>

        <span class="cov8" title="1">logger.Debug("Feasible nodes after predicate filtering", zap.Int("count", len(feasible)))

        // 3. Score and rank nodes
        type scoredNode struct {
                node  *domain.Node
                score float64
        }

        scored := make([]scoredNode, len(feasible))
        for i, node := range feasible </span><span class="cov8" title="1">{
                score := s.scoreNode(ctx, node, spec)
                scored[i] = scoredNode{node: node, score: score}
        }</span>

        // Sort by score (highest first)
        <span class="cov8" title="1">sort.Slice(scored, func(i, j int) bool </span><span class="cov8" title="1">{
                return scored[i].score &gt; scored[j].score
        }</span>)

        <span class="cov8" title="1">best := scored[0]

        logger.Info("Scheduled VM successfully",
                zap.String("node_id", best.node.ID),
                zap.String("hostname", best.node.Hostname),
                zap.Float64("score", best.score),
                zap.Int("feasible_nodes", len(feasible)),
        )

        return &amp;ScheduleResult{
                NodeID:   best.node.ID,
                Hostname: best.node.Hostname,
                Score:    best.score,
                Reason:   fmt.Sprintf("Best score using %s strategy", s.config.PlacementStrategy),
        }, nil</span>
}

// checkPredicates applies hard constraints to filter out unsuitable nodes.
func (s *Scheduler) checkPredicates(ctx context.Context, node *domain.Node, spec *computev1.VmSpec) bool <span class="cov8" title="1">{
        // Check if node is in a schedulable state
        if node.Status.Phase != domain.NodePhaseReady </span><span class="cov0" title="0">{
                s.logger.Debug("Node not ready", zap.String("node_id", node.ID), zap.String("phase", string(node.Status.Phase)))
                return false
        }</span>

        // Check CPU capacity with overcommit
        <span class="cov8" title="1">allocatableCPU := s.getAllocatableCPU(node)
        usedCPU := s.getNodeCPUUsage(ctx, node.ID)
        requestedCPU := float64(spec.Cpu.GetCores())

        if requestedCPU &gt; (allocatableCPU - usedCPU) </span><span class="cov8" title="1">{
                s.logger.Debug("Insufficient CPU",
                        zap.String("node_id", node.ID),
                        zap.Float64("allocatable", allocatableCPU),
                        zap.Float64("used", usedCPU),
                        zap.Float64("requested", requestedCPU),
                )
                return false
        }</span>

        // Check memory capacity with overcommit
        <span class="cov8" title="1">allocatableMem := s.getAllocatableMemory(node)
        usedMem := s.getNodeMemoryUsage(ctx, node.ID)
        requestedMem := float64(spec.Memory.GetSizeMib())

        if requestedMem &gt; (allocatableMem - usedMem) </span><span class="cov0" title="0">{
                s.logger.Debug("Insufficient memory",
                        zap.String("node_id", node.ID),
                        zap.Float64("allocatable_mib", allocatableMem),
                        zap.Float64("used_mib", usedMem),
                        zap.Float64("requested_mib", requestedMem),
                )
                return false
        }</span>

        // Check affinity rules (if placement policy is specified)
        <span class="cov8" title="1">if !s.checkAffinity(ctx, node, spec) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// scoreNode calculates a score for the node based on the placement strategy.
func (s *Scheduler) scoreNode(ctx context.Context, node *domain.Node, spec *computev1.VmSpec) float64 <span class="cov8" title="1">{
        var score float64

        switch s.config.PlacementStrategy </span>{
        case "spread":<span class="cov8" title="1">
                // Prefer nodes with fewer VMs (spread load for HA)
                vmCount := s.getNodeVMCount(ctx, node.ID)
                // Higher score for fewer VMs (max 100)
                score = 100.0 - float64(vmCount)*5.0
                if score &lt; 0 </span><span class="cov0" title="0">{
                        score = 0
                }</span>

        case "pack":<span class="cov0" title="0">
                // Prefer nodes with more VMs (consolidate for efficiency)
                vmCount := s.getNodeVMCount(ctx, node.ID)
                // Higher score for more VMs, but with diminishing returns
                score = float64(vmCount) * 10.0
                if score &gt; 100 </span><span class="cov0" title="0">{
                        score = 100
                }</span>

        default:<span class="cov0" title="0">
                // Balance: consider remaining capacity
                cpuRemaining := s.getAllocatableCPU(node) - s.getNodeCPUUsage(ctx, node.ID)
                memRemaining := s.getAllocatableMemory(node) - s.getNodeMemoryUsage(ctx, node.ID)

                // Normalize to 0-100 scale
                allocatableCPU := s.getAllocatableCPU(node)
                allocatableMem := s.getAllocatableMemory(node)

                cpuScore := 0.0
                if allocatableCPU &gt; 0 </span><span class="cov0" title="0">{
                        cpuScore = (cpuRemaining / allocatableCPU) * 50
                }</span>
                <span class="cov0" title="0">memScore := 0.0
                if allocatableMem &gt; 0 </span><span class="cov0" title="0">{
                        memScore = (memRemaining / allocatableMem) * 50
                }</span>
                <span class="cov0" title="0">score = cpuScore + memScore</span>
        }

        // Apply bonus for preferred nodes (from affinity)
        <span class="cov8" title="1">if s.isPreferredNode(node, spec) </span><span class="cov0" title="0">{
                score += 20.0
        }</span>

        <span class="cov8" title="1">return score</span>
}

// getAllocatableCPU returns the allocatable CPU cores for a node.
func (s *Scheduler) getAllocatableCPU(node *domain.Node) float64 <span class="cov8" title="1">{
        totalCPU := float64(node.Spec.CPU.TotalCores()) - float64(s.config.ReservedCPUCores)
        if totalCPU &lt; 0 </span><span class="cov0" title="0">{
                totalCPU = 0
        }</span>
        <span class="cov8" title="1">return totalCPU * s.config.OvercommitCPU</span>
}

// getAllocatableMemory returns the allocatable memory in MiB for a node.
func (s *Scheduler) getAllocatableMemory(node *domain.Node) float64 <span class="cov8" title="1">{
        totalMem := float64(node.Spec.Memory.TotalMiB) - float64(s.config.ReservedMemoryMiB)
        if totalMem &lt; 0 </span><span class="cov0" title="0">{
                totalMem = 0
        }</span>
        <span class="cov8" title="1">return totalMem * s.config.OvercommitMemory</span>
}

// getNodeCPUUsage returns the CPU cores currently used by VMs on the node.
func (s *Scheduler) getNodeCPUUsage(ctx context.Context, nodeID string) float64 <span class="cov8" title="1">{
        vms, err := s.vmRepo.ListByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get VMs for node", zap.String("node_id", nodeID), zap.Error(err))
                return 0
        }</span>

        <span class="cov8" title="1">var total float64
        for _, vm := range vms </span><span class="cov0" title="0">{
                // Only count running or starting VMs
                if vm.Status.State == domain.VMStateRunning ||
                        vm.Status.State == domain.VMStateStarting </span><span class="cov0" title="0">{
                        total += float64(vm.Spec.CPU.Cores)
                }</span>
        }
        <span class="cov8" title="1">return total</span>
}

// getNodeMemoryUsage returns the memory in MiB currently used by VMs on the node.
func (s *Scheduler) getNodeMemoryUsage(ctx context.Context, nodeID string) float64 <span class="cov8" title="1">{
        vms, err := s.vmRepo.ListByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get VMs for node", zap.String("node_id", nodeID), zap.Error(err))
                return 0
        }</span>

        <span class="cov8" title="1">var total float64
        for _, vm := range vms </span><span class="cov0" title="0">{
                if vm.Status.State == domain.VMStateRunning ||
                        vm.Status.State == domain.VMStateStarting </span><span class="cov0" title="0">{
                        total += float64(vm.Spec.Memory.SizeMiB)
                }</span>
        }
        <span class="cov8" title="1">return total</span>
}

// getNodeVMCount returns the number of VMs on a node.
func (s *Scheduler) getNodeVMCount(ctx context.Context, nodeID string) int <span class="cov8" title="1">{
        count, err := s.vmRepo.CountByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to count VMs for node", zap.String("node_id", nodeID), zap.Error(err))
                return 0
        }</span>
        <span class="cov8" title="1">return count</span>
}

// checkAffinity verifies node affinity rules based on placement policy.
func (s *Scheduler) checkAffinity(ctx context.Context, node *domain.Node, spec *computev1.VmSpec) bool <span class="cov8" title="1">{
        if spec.Placement == nil </span><span class="cov8" title="1">{
                return true // No placement policy
        }</span>

        // Check required nodes (hard affinity)
        <span class="cov0" title="0">if len(spec.Placement.RequiredNodes) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, nodeID := range spec.Placement.RequiredNodes </span><span class="cov0" title="0">{
                        if node.ID == nodeID || node.Hostname == nodeID </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check excluded nodes
        <span class="cov0" title="0">for _, excludedNodeID := range spec.Placement.ExcludedNodes </span><span class="cov0" title="0">{
                if node.ID == excludedNodeID || node.Hostname == excludedNodeID </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check required labels
        <span class="cov0" title="0">if spec.Placement.RequiredLabels != nil </span><span class="cov0" title="0">{
                for key, value := range spec.Placement.RequiredLabels </span><span class="cov0" title="0">{
                        if node.Labels[key] != value </span><span class="cov0" title="0">{
                                s.logger.Debug("Node doesn't match required label",
                                        zap.String("node_id", node.ID),
                                        zap.String("label_key", key),
                                        zap.String("expected", value),
                                        zap.String("actual", node.Labels[key]),
                                )
                                return false
                        }</span>
                }
        }

        // Check anti-affinity VMs (VM shouldn't be on same node as these VMs)
        <span class="cov0" title="0">if len(spec.Placement.AntiAffinityVms) &gt; 0 </span><span class="cov0" title="0">{
                vms, err := s.vmRepo.ListByNodeID(ctx, node.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to check anti-affinity", zap.Error(err))
                        return true // Can't check, assume no violation
                }</span>

                <span class="cov0" title="0">for _, vm := range vms </span><span class="cov0" title="0">{
                        for _, antiAffinityVMID := range spec.Placement.AntiAffinityVms </span><span class="cov0" title="0">{
                                if vm.ID == antiAffinityVMID </span><span class="cov0" title="0">{
                                        s.logger.Debug("Anti-affinity violation",
                                                zap.String("node_id", node.ID),
                                                zap.String("conflicting_vm", vm.ID),
                                        )
                                        return false
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return true</span>
}

// isPreferredNode checks if the node is a preferred node based on soft affinity.
func (s *Scheduler) isPreferredNode(node *domain.Node, spec *computev1.VmSpec) bool <span class="cov8" title="1">{
        if spec.Placement == nil || len(spec.Placement.PreferredNodes) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if this node is in the preferred list
        <span class="cov0" title="0">for _, preferredNodeID := range spec.Placement.PreferredNodes </span><span class="cov0" title="0">{
                if node.ID == preferredNodeID || node.Hostname == preferredNodeID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package middleware provides HTTP and Connect-RPC middleware.
package middleware

import (
        "context"
        "errors"
        "strings"

        "connectrpc.com/connect"
        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        "github.com/Quantixkvm/Quantixkvm/internal/services/auth"
)

// ContextKey is the type for context keys.
type ContextKey string

const (
        // ClaimsKey is the context key for JWT claims.
        ClaimsKey ContextKey = "claims"
        // UserIDKey is the context key for the authenticated user ID.
        UserIDKey ContextKey = "user_id"
        // RoleKey is the context key for the user's role.
        RoleKey ContextKey = "role"
)

// AuthInterceptor provides authentication for Connect-RPC services.
type AuthInterceptor struct {
        jwtManager *auth.JWTManager
        logger     *zap.Logger
}

// NewAuthInterceptor creates a new auth interceptor.
func NewAuthInterceptor(jwtManager *auth.JWTManager, logger *zap.Logger) *AuthInterceptor <span class="cov0" title="0">{
        return &amp;AuthInterceptor{
                jwtManager: jwtManager,
                logger:     logger.With(zap.String("middleware", "auth")),
        }
}</span>

// WrapUnary returns a unary interceptor function.
func (a *AuthInterceptor) WrapUnary(next connect.UnaryFunc) connect.UnaryFunc <span class="cov0" title="0">{
        return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) </span><span class="cov0" title="0">{
                // Skip auth for public endpoints
                if isPublicEndpoint(req.Spec().Procedure) </span><span class="cov0" title="0">{
                        return next(ctx, req)
                }</span>

                // Extract token from Authorization header
                <span class="cov0" title="0">authHeader := req.Header().Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        a.logger.Debug("Missing authorization header", zap.String("procedure", req.Spec().Procedure))
                        return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("missing authorization header"))
                }</span>

                // Parse Bearer token
                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                if tokenString == authHeader </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("invalid authorization format, expected 'Bearer &lt;token&gt;'"))
                }</span>

                // Verify token
                <span class="cov0" title="0">claims, err := a.jwtManager.Verify(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Debug("Token verification failed", zap.Error(err))
                        return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("invalid or expired token"))
                }</span>

                // Add claims to context
                <span class="cov0" title="0">ctx = context.WithValue(ctx, ClaimsKey, claims)
                ctx = context.WithValue(ctx, UserIDKey, claims.UserID)
                ctx = context.WithValue(ctx, RoleKey, claims.Role)

                a.logger.Debug("Request authenticated",
                        zap.String("user_id", claims.UserID),
                        zap.String("username", claims.Username),
                        zap.String("role", string(claims.Role)),
                        zap.String("procedure", req.Spec().Procedure),
                )

                return next(ctx, req)</span>
        }
}

// WrapStreamingClient returns a streaming client interceptor.
func (a *AuthInterceptor) WrapStreamingClient(next connect.StreamingClientFunc) connect.StreamingClientFunc <span class="cov0" title="0">{
        return func(ctx context.Context, spec connect.Spec) connect.StreamingClientConn </span><span class="cov0" title="0">{
                // Client-side streaming doesn't need server auth
                return next(ctx, spec)
        }</span>
}

// WrapStreamingHandler returns a streaming handler interceptor.
func (a *AuthInterceptor) WrapStreamingHandler(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc <span class="cov0" title="0">{
        return func(ctx context.Context, conn connect.StreamingHandlerConn) error </span><span class="cov0" title="0">{
                // Skip auth for public endpoints
                if isPublicEndpoint(conn.Spec().Procedure) </span><span class="cov0" title="0">{
                        return next(ctx, conn)
                }</span>

                // Extract token from Authorization header
                <span class="cov0" title="0">authHeader := conn.RequestHeader().Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeUnauthenticated, errors.New("missing authorization header"))
                }</span>

                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                if tokenString == authHeader </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeUnauthenticated, errors.New("invalid authorization format"))
                }</span>

                // Verify token
                <span class="cov0" title="0">claims, err := a.jwtManager.Verify(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeUnauthenticated, errors.New("invalid or expired token"))
                }</span>

                // Add claims to context
                <span class="cov0" title="0">ctx = context.WithValue(ctx, ClaimsKey, claims)
                ctx = context.WithValue(ctx, UserIDKey, claims.UserID)
                ctx = context.WithValue(ctx, RoleKey, claims.Role)

                return next(ctx, conn)</span>
        }
}

// publicEndpoints lists endpoints that don't require authentication.
var publicEndpoints = []string{
        // Health checks
        "/health",
        "/ready",
        "/live",
        // Auth endpoints
        "/Quantixkvm.auth.v1.AuthService/Login",
        "/Quantixkvm.auth.v1.AuthService/RefreshToken",
        // gRPC reflection (for development tools)
        "/grpc.reflection.v1alpha.ServerReflection",
        "/grpc.reflection.v1.ServerReflection",
}

// isPublicEndpoint checks if a procedure is public (no auth required).
func isPublicEndpoint(procedure string) bool <span class="cov0" title="0">{
        for _, ep := range publicEndpoints </span><span class="cov0" title="0">{
                if strings.Contains(procedure, ep) || strings.HasSuffix(procedure, ep) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetClaims extracts JWT claims from the context.
func GetClaims(ctx context.Context) (*auth.Claims, bool) <span class="cov0" title="0">{
        claims, ok := ctx.Value(ClaimsKey).(*auth.Claims)
        return claims, ok
}</span>

// GetUserID extracts the user ID from the context.
func GetUserID(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        userID, ok := ctx.Value(UserIDKey).(string)
        return userID, ok
}</span>

// GetRole extracts the user's role from the context.
func GetRole(ctx context.Context) (domain.Role, bool) <span class="cov0" title="0">{
        role, ok := ctx.Value(RoleKey).(domain.Role)
        return role, ok
}</span>

// RequireRole returns an error if the user doesn't have the required role.
func RequireRole(ctx context.Context, requiredRoles ...domain.Role) error <span class="cov0" title="0">{
        role, ok := GetRole(ctx)
        if !ok </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeUnauthenticated, errors.New("not authenticated"))
        }</span>

        <span class="cov0" title="0">for _, r := range requiredRoles </span><span class="cov0" title="0">{
                if role == r </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return connect.NewError(connect.CodePermissionDenied, errors.New("insufficient permissions"))</span>
}

// RequirePermission returns an error if the user doesn't have the required permission.
func RequirePermission(ctx context.Context, permission domain.Permission) error <span class="cov0" title="0">{
        role, ok := GetRole(ctx)
        if !ok </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeUnauthenticated, errors.New("not authenticated"))
        }</span>

        <span class="cov0" title="0">if !domain.HasPermission(role, permission) </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodePermissionDenied, errors.New("insufficient permissions"))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package alert provides system alerting and notification services.
package alert

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// Repository defines the interface for alert data access.
type Repository interface {
        Create(ctx context.Context, alert *domain.Alert) (*domain.Alert, error)
        Get(ctx context.Context, id string) (*domain.Alert, error)
        List(ctx context.Context, filter AlertFilter, limit int, offset int) ([]*domain.Alert, int, error)
        Update(ctx context.Context, alert *domain.Alert) (*domain.Alert, error)
        Delete(ctx context.Context, id string) error
        GetUnresolved(ctx context.Context, severity domain.AlertSeverity) ([]*domain.Alert, error)
        CountBySeverity(ctx context.Context) (map[domain.AlertSeverity]int, error)
}

// AlertFilter defines filter criteria for listing alerts.
type AlertFilter struct {
        Severity     domain.AlertSeverity
        SourceType   domain.AlertSourceType
        SourceID     string
        Acknowledged *bool
        Resolved     *bool
        StartTime    *time.Time
        EndTime      *time.Time
}

// EventPublisher publishes alert events for real-time updates.
type EventPublisher interface {
        PublishAlert(ctx context.Context, eventType string, alert *domain.Alert) error
}

// Service provides alert management functionality.
type Service struct {
        repo      Repository
        publisher EventPublisher
        logger    *zap.Logger
}

// NewService creates a new alert service.
func NewService(repo Repository, publisher EventPublisher, logger *zap.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:      repo,
                publisher: publisher,
                logger:    logger.With(zap.String("service", "alert")),
        }
}</span>

// CreateAlert creates a new alert.
func (s *Service) CreateAlert(ctx context.Context, severity domain.AlertSeverity, sourceType domain.AlertSourceType, sourceID, sourceName, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        alert := &amp;domain.Alert{
                ID:         uuid.NewString(),
                Severity:   severity,
                Title:      title,
                Message:    message,
                SourceType: sourceType,
                SourceID:   sourceID,
                SourceName: sourceName,
                CreatedAt:  time.Now(),
        }

        created, err := s.repo.Create(ctx, alert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create alert: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Alert created",
                zap.String("id", created.ID),
                zap.String("severity", string(created.Severity)),
                zap.String("title", created.Title),
                zap.String("source_type", string(created.SourceType)),
                zap.String("source_id", created.SourceID),
        )

        // Publish event for real-time updates
        if s.publisher != nil </span><span class="cov0" title="0">{
                if err := s.publisher.PublishAlert(ctx, "alert.created", created); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to publish alert event", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return created, nil</span>
}

// GetAlert retrieves an alert by ID.
func (s *Service) GetAlert(ctx context.Context, id string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.repo.Get(ctx, id)
}</span>

// ListAlerts returns a paginated list of alerts.
func (s *Service) ListAlerts(ctx context.Context, filter AlertFilter, limit, offset int) ([]*domain.Alert, int, error) <span class="cov0" title="0">{
        return s.repo.List(ctx, filter, limit, offset)
}</span>

// AcknowledgeAlert marks an alert as acknowledged.
func (s *Service) AcknowledgeAlert(ctx context.Context, id, acknowledgedBy string) (*domain.Alert, error) <span class="cov0" title="0">{
        alert, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if alert.Acknowledged </span><span class="cov0" title="0">{
                return alert, nil // Already acknowledged
        }</span>

        <span class="cov0" title="0">now := time.Now()
        alert.Acknowledged = true
        alert.AcknowledgedBy = acknowledgedBy
        alert.AcknowledgedAt = &amp;now

        updated, err := s.repo.Update(ctx, alert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to acknowledge alert: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Alert acknowledged",
                zap.String("id", id),
                zap.String("acknowledged_by", acknowledgedBy),
        )

        if s.publisher != nil </span><span class="cov0" title="0">{
                s.publisher.PublishAlert(ctx, "alert.acknowledged", updated)
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

// ResolveAlert marks an alert as resolved.
func (s *Service) ResolveAlert(ctx context.Context, id string) (*domain.Alert, error) <span class="cov0" title="0">{
        alert, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if alert.Resolved </span><span class="cov0" title="0">{
                return alert, nil // Already resolved
        }</span>

        <span class="cov0" title="0">now := time.Now()
        alert.Resolved = true
        alert.ResolvedAt = &amp;now

        updated, err := s.repo.Update(ctx, alert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve alert: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Alert resolved", zap.String("id", id))

        if s.publisher != nil </span><span class="cov0" title="0">{
                s.publisher.PublishAlert(ctx, "alert.resolved", updated)
        }</span>

        <span class="cov0" title="0">return updated, nil</span>
}

// DeleteAlert removes an alert.
func (s *Service) DeleteAlert(ctx context.Context, id string) error <span class="cov0" title="0">{
        return s.repo.Delete(ctx, id)
}</span>

// GetUnresolvedAlerts returns all unresolved alerts of a specific severity.
func (s *Service) GetUnresolvedAlerts(ctx context.Context, severity domain.AlertSeverity) ([]*domain.Alert, error) <span class="cov0" title="0">{
        return s.repo.GetUnresolved(ctx, severity)
}</span>

// GetAlertSummary returns a count of alerts by severity.
func (s *Service) GetAlertSummary(ctx context.Context) (*AlertSummary, error) <span class="cov0" title="0">{
        counts, err := s.repo.CountBySeverity(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;AlertSummary{
                Critical: counts[domain.AlertSeverityCritical],
                Warning:  counts[domain.AlertSeverityWarning],
                Info:     counts[domain.AlertSeverityInfo],
        }, nil</span>
}

// AlertSummary contains alert counts by severity.
type AlertSummary struct {
        Critical int `json:"critical"`
        Warning  int `json:"warning"`
        Info     int `json:"info"`
}

// =============================================================================
// Alert Generators - Create alerts from system events
// =============================================================================

// VMAlert creates a VM-related alert.
func (s *Service) VMAlert(ctx context.Context, severity domain.AlertSeverity, vmID, vmName, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.CreateAlert(ctx, severity, domain.AlertSourceVM, vmID, vmName, title, message)
}</span>

// NodeAlert creates a node-related alert.
func (s *Service) NodeAlert(ctx context.Context, severity domain.AlertSeverity, nodeID, nodeName, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.CreateAlert(ctx, severity, domain.AlertSourceNode, nodeID, nodeName, title, message)
}</span>

// StorageAlert creates a storage-related alert.
func (s *Service) StorageAlert(ctx context.Context, severity domain.AlertSeverity, storageID, storageName, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.CreateAlert(ctx, severity, domain.AlertSourceStorage, storageID, storageName, title, message)
}</span>

// ClusterAlert creates a cluster-related alert.
func (s *Service) ClusterAlert(ctx context.Context, severity domain.AlertSeverity, clusterID, clusterName, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.CreateAlert(ctx, severity, domain.AlertSourceCluster, clusterID, clusterName, title, message)
}</span>

// SystemAlert creates a system-wide alert.
func (s *Service) SystemAlert(ctx context.Context, severity domain.AlertSeverity, title, message string) (*domain.Alert, error) <span class="cov0" title="0">{
        return s.CreateAlert(ctx, severity, domain.AlertSourceSystem, "system", "Quantixkvm", title, message)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package auth provides authentication and authorization services.
package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "github.com/Quantixkvm/Quantixkvm/internal/config"
        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// Claims represents the JWT claims for Quantixkvm.
type Claims struct {
        UserID   string      `json:"user_id"`
        Username string      `json:"username"`
        Email    string      `json:"email"`
        Role     domain.Role `json:"role"`
        jwt.RegisteredClaims
}

// JWTManager handles JWT token generation and verification.
type JWTManager struct {
        secret        []byte
        tokenExpiry   time.Duration
        refreshExpiry time.Duration
}

// NewJWTManager creates a new JWT manager with the given configuration.
func NewJWTManager(cfg config.AuthConfig) *JWTManager <span class="cov8" title="1">{
        return &amp;JWTManager{
                secret:        []byte(cfg.JWTSecret),
                tokenExpiry:   cfg.TokenExpiry,
                refreshExpiry: cfg.RefreshExpiry,
        }
}</span>

// TokenPair contains both access and refresh tokens.
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// Generate creates a new access and refresh token pair for a user.
func (m *JWTManager) Generate(user *domain.User) (*TokenPair, error) <span class="cov8" title="1">{
        now := time.Now()
        expiresAt := now.Add(m.tokenExpiry)

        // Access token claims
        accessClaims := &amp;Claims{
                UserID:   user.ID,
                Username: user.Username,
                Email:    user.Email,
                Role:     user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "Quantixkvm",
                        Subject:   user.ID,
                        Audience:  jwt.ClaimStrings{"Quantixkvm-api"},
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        ID:        fmt.Sprintf("%s-%d", user.ID, now.UnixNano()),
                },
        }

        // Sign access token
        accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
        accessTokenString, err := accessToken.SignedString(m.secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign access token: %w", err)
        }</span>

        // Refresh token claims (minimal claims for security)
        <span class="cov8" title="1">refreshClaims := &amp;Claims{
                UserID: user.ID,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "Quantixkvm",
                        Subject:   user.ID,
                        Audience:  jwt.ClaimStrings{"Quantixkvm-refresh"},
                        ExpiresAt: jwt.NewNumericDate(now.Add(m.refreshExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        ID:        fmt.Sprintf("refresh-%s-%d", user.ID, now.UnixNano()),
                },
        }

        // Sign refresh token
        refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshTokenString, err := refreshToken.SignedString(m.secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign refresh token: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;TokenPair{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresAt:    expiresAt,
                TokenType:    "Bearer",
        }, nil</span>
}

// Verify validates a token and returns the claims if valid.
func (m *JWTManager) Verify(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Validate signing method
                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                }</span>
                <span class="cov8" title="1">return m.secret, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// VerifyRefreshToken verifies a refresh token and returns the user ID.
func (m *JWTManager) VerifyRefreshToken(tokenString string) (string, error) <span class="cov8" title="1">{
        claims, err := m.Verify(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if it's a refresh token
        <span class="cov8" title="1">if len(claims.Audience) == 0 || claims.Audience[0] != "Quantixkvm-refresh" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("not a refresh token")
        }</span>

        <span class="cov8" title="1">return claims.UserID, nil</span>
}

// GetTokenExpiry returns the access token expiry duration.
func (m *JWTManager) GetTokenExpiry() time.Duration <span class="cov0" title="0">{
        return m.tokenExpiry
}</span>

// GetRefreshExpiry returns the refresh token expiry duration.
func (m *JWTManager) GetRefreshExpiry() time.Duration <span class="cov0" title="0">{
        return m.refreshExpiry
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package auth provides authentication and authorization services.
package auth

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// UserRepository defines the interface for user data access.
type UserRepository interface {
        Create(ctx context.Context, user *domain.User) (*domain.User, error)
        Get(ctx context.Context, id string) (*domain.User, error)
        GetByUsername(ctx context.Context, username string) (*domain.User, error)
        GetByEmail(ctx context.Context, email string) (*domain.User, error)
        List(ctx context.Context, limit int, offset int) ([]*domain.User, int, error)
        Update(ctx context.Context, user *domain.User) (*domain.User, error)
        Delete(ctx context.Context, id string) error
        UpdateLastLogin(ctx context.Context, id string) error
}

// AuditRepository defines the interface for audit log storage.
type AuditRepository interface {
        Create(ctx context.Context, entry *domain.AuditEntry) error
        List(ctx context.Context, filter AuditFilter, limit int, offset int) ([]*domain.AuditEntry, int, error)
}

// AuditFilter defines filter criteria for audit logs.
type AuditFilter struct {
        UserID       string
        Action       domain.AuditAction
        ResourceType string
        ResourceID   string
        StartTime    *time.Time
        EndTime      *time.Time
}

// SessionStore defines the interface for session storage (e.g., Redis).
type SessionStore interface {
        SetSession(ctx context.Context, sessionID string, userID string) error
        GetSession(ctx context.Context, sessionID string) (string, error)
        DeleteSession(ctx context.Context, sessionID string) error
}

// Service provides authentication and user management functionality.
type Service struct {
        userRepo     UserRepository
        auditRepo    AuditRepository
        sessionStore SessionStore
        jwtManager   *JWTManager
        logger       *zap.Logger
}

// NewService creates a new auth service.
func NewService(
        userRepo UserRepository,
        auditRepo AuditRepository,
        sessionStore SessionStore,
        jwtManager *JWTManager,
        logger *zap.Logger,
) *Service <span class="cov0" title="0">{
        return &amp;Service{
                userRepo:     userRepo,
                auditRepo:    auditRepo,
                sessionStore: sessionStore,
                jwtManager:   jwtManager,
                logger:       logger.With(zap.String("service", "auth")),
        }
}</span>

// LoginRequest contains login credentials.
type LoginRequest struct {
        Username  string
        Password  string
        IPAddress string
        UserAgent string
}

// LoginResponse contains the result of a successful login.
type LoginResponse struct {
        User      *domain.User
        Tokens    *TokenPair
        SessionID string
}

// Login authenticates a user and returns tokens.
func (s *Service) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Login attempt", zap.String("username", req.Username))

        // Find user by username
        user, err := s.userRepo.GetByUsername(ctx, req.Username)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        s.logger.Warn("Login failed: user not found", zap.String("username", req.Username))
                        s.auditFailedLogin(ctx, req.Username, req.IPAddress, req.UserAgent, "user not found")
                        return nil, fmt.Errorf("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user is enabled
        <span class="cov0" title="0">if !user.Enabled </span><span class="cov0" title="0">{
                s.logger.Warn("Login failed: user disabled", zap.String("username", req.Username))
                s.auditFailedLogin(ctx, req.Username, req.IPAddress, req.UserAgent, "user disabled")
                return nil, fmt.Errorf("account is disabled")
        }</span>

        // Verify password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Login failed: invalid password", zap.String("username", req.Username))
                s.auditFailedLogin(ctx, req.Username, req.IPAddress, req.UserAgent, "invalid password")
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Generate tokens
        <span class="cov0" title="0">tokens, err := s.jwtManager.Generate(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Create session
        <span class="cov0" title="0">sessionID := tokens.AccessToken[:32] // Use first 32 chars as session ID
        if s.sessionStore != nil </span><span class="cov0" title="0">{
                if err := s.sessionStore.SetSession(ctx, sessionID, user.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to create session", zap.Error(err))
                }</span>
        }

        // Update last login
        <span class="cov0" title="0">if err := s.userRepo.UpdateLastLogin(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to update last login", zap.Error(err))
        }</span>

        // Audit successful login
        <span class="cov0" title="0">s.auditLogin(ctx, user, req.IPAddress, req.UserAgent)

        s.logger.Info("Login successful",
                zap.String("user_id", user.ID),
                zap.String("username", user.Username),
                zap.String("role", string(user.Role)),
        )

        return &amp;LoginResponse{
                User:      user,
                Tokens:    tokens,
                SessionID: sessionID,
        }, nil</span>
}

// Logout invalidates a user session.
func (s *Service) Logout(ctx context.Context, sessionID string, userID string) error <span class="cov0" title="0">{
        if s.sessionStore != nil </span><span class="cov0" title="0">{
                if err := s.sessionStore.DeleteSession(ctx, sessionID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to delete session", zap.Error(err))
                }</span>
        }

        // Audit logout
        <span class="cov0" title="0">if s.auditRepo != nil </span><span class="cov0" title="0">{
                entry := &amp;domain.AuditEntry{
                        UserID:    userID,
                        Action:    domain.AuditActionLogout,
                        CreatedAt: time.Now(),
                }
                if err := s.auditRepo.Create(ctx, entry); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to audit logout", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RefreshTokens generates new tokens from a refresh token.
func (s *Service) RefreshTokens(ctx context.Context, refreshToken string) (*TokenPair, error) <span class="cov0" title="0">{
        // Verify refresh token
        userID, err := s.jwtManager.VerifyRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid refresh token: %w", err)
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found: %w", err)
        }</span>

        <span class="cov0" title="0">if !user.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account is disabled")
        }</span>

        // Generate new tokens
        <span class="cov0" title="0">tokens, err := s.jwtManager.Generate(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        <span class="cov0" title="0">return tokens, nil</span>
}

// ValidateToken validates an access token and returns the claims.
func (s *Service) ValidateToken(ctx context.Context, token string) (*Claims, error) <span class="cov0" title="0">{
        return s.jwtManager.Verify(token)
}</span>

// CreateUser creates a new user account.
func (s *Service) CreateUser(ctx context.Context, username, email, password string, role domain.Role) (*domain.User, error) <span class="cov0" title="0">{
        // Hash password
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">user := &amp;domain.User{
                Username:     username,
                Email:        email,
                PasswordHash: string(hashedPassword),
                Role:         role,
                Enabled:      true,
        }

        created, err := s.userRepo.Create(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("User created",
                zap.String("user_id", created.ID),
                zap.String("username", created.Username),
                zap.String("role", string(created.Role)),
        )

        return created, nil</span>
}

// ChangePassword changes a user's password.
func (s *Service) ChangePassword(ctx context.Context, userID, oldPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.userRepo.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found: %w", err)
        }</span>

        // Verify old password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(oldPassword)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid current password")
        }</span>

        // Hash new password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">user.PasswordHash = string(hashedPassword)
        if _, err := s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Password changed", zap.String("user_id", userID))
        return nil</span>
}

// GetUser retrieves a user by ID.
func (s *Service) GetUser(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        return s.userRepo.Get(ctx, id)
}</span>

// ListUsers returns a paginated list of users.
func (s *Service) ListUsers(ctx context.Context, limit, offset int) ([]*domain.User, int, error) <span class="cov0" title="0">{
        return s.userRepo.List(ctx, limit, offset)
}</span>

// UpdateUser updates a user's profile.
func (s *Service) UpdateUser(ctx context.Context, user *domain.User) (*domain.User, error) <span class="cov0" title="0">{
        return s.userRepo.Update(ctx, user)
}</span>

// DeleteUser removes a user account.
func (s *Service) DeleteUser(ctx context.Context, id string) error <span class="cov0" title="0">{
        return s.userRepo.Delete(ctx, id)
}</span>

// CheckPermission checks if a user has a specific permission.
func (s *Service) CheckPermission(ctx context.Context, userID string, permission domain.Permission) (bool, error) <span class="cov0" title="0">{
        user, err := s.userRepo.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if !user.Enabled </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return domain.HasPermission(user.Role, permission), nil</span>
}

// =============================================================================
// Audit helpers
// =============================================================================

func (s *Service) auditLogin(ctx context.Context, user *domain.User, ipAddress, userAgent string) <span class="cov0" title="0">{
        if s.auditRepo == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">entry := &amp;domain.AuditEntry{
                UserID:    user.ID,
                Username:  user.Username,
                Action:    domain.AuditActionLogin,
                IPAddress: ipAddress,
                UserAgent: userAgent,
                CreatedAt: time.Now(),
        }

        if err := s.auditRepo.Create(ctx, entry); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to audit login", zap.Error(err))
        }</span>
}

func (s *Service) auditFailedLogin(ctx context.Context, username, ipAddress, userAgent, reason string) <span class="cov0" title="0">{
        if s.auditRepo == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">entry := &amp;domain.AuditEntry{
                Username:  username,
                Action:    domain.AuditActionLogin,
                IPAddress: ipAddress,
                UserAgent: userAgent,
                Details:   map[string]interface{}{"success": false, "reason": reason},
                CreatedAt: time.Now(),
        }

        if err := s.auditRepo.Create(ctx, entry); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to audit failed login", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package network provides converters between protobuf and domain types.
package network

import (
        "time"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        networkv1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/network/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// =============================================================================
// VIRTUAL NETWORK CONVERTERS
// =============================================================================

// convertNetworkToProto converts a domain.VirtualNetwork to networkv1.VirtualNetwork.
func convertNetworkToProto(net *domain.VirtualNetwork) *networkv1.VirtualNetwork <span class="cov0" title="0">{
        if net == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;networkv1.VirtualNetwork{
                Id:          net.ID,
                Name:        net.Name,
                ProjectId:   net.ProjectID,
                Description: net.Description,
                Labels:      net.Labels,
                Spec:        convertNetworkSpecToProto(&amp;net.Spec),
                Status:      convertNetworkStatusToProto(&amp;net.Status),
                CreatedAt:   timestamppb.New(net.CreatedAt),
                UpdatedAt:   timestamppb.New(net.UpdatedAt),
        }</span>
}

// convertNetworkSpecToProto converts domain.VirtualNetworkSpec to networkv1.VirtualNetworkSpec.
func convertNetworkSpecToProto(spec *domain.VirtualNetworkSpec) *networkv1.VirtualNetworkSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoSpec := &amp;networkv1.VirtualNetworkSpec{
                Type:                    networkv1.VirtualNetworkSpec_NetworkType(networkv1.VirtualNetworkSpec_NetworkType_value[string(spec.Type)]),
                Mtu:                     spec.MTU,
                DefaultSecurityGroupId:  spec.DefaultSecurityGroupID,
                PortSecurityEnabled:     spec.PortSecurityEnabled,
                IpConfig: &amp;networkv1.IpAddressManagement{
                        Ipv4Subnet:  spec.IPConfig.IPv4Subnet,
                        Ipv4Gateway: spec.IPConfig.IPv4Gateway,
                        Ipv6Subnet:  spec.IPConfig.IPv6Subnet,
                        Ipv6Gateway: spec.IPConfig.IPv6Gateway,
                        ReservedIps: spec.IPConfig.ReservedIPs,
                        Dhcp: &amp;networkv1.DhcpConfig{
                                Enabled:      spec.IPConfig.DHCP.Enabled,
                                LeaseTimeSec: spec.IPConfig.DHCP.LeaseTimeSec,
                                DnsServers:   spec.IPConfig.DHCP.DNSServers,
                                NtpServers:   spec.IPConfig.DHCP.NTPServers,
                                DomainName:   spec.IPConfig.DHCP.DomainName,
                        },
                },
                Dns: &amp;networkv1.DnsConfig{
                        Nameservers:   spec.DNS.Nameservers,
                        SearchDomains: spec.DNS.SearchDomains,
                },
        }

        // Convert allocation pools
        for _, pool := range spec.IPConfig.AllocationPools </span><span class="cov0" title="0">{
                protoSpec.IpConfig.AllocationPools = append(protoSpec.IpConfig.AllocationPools, &amp;networkv1.IpRange{
                        Start: pool.Start,
                        End:   pool.End,
                })
        }</span>

        // Convert router config
        <span class="cov0" title="0">if spec.Router != nil </span><span class="cov0" title="0">{
                protoSpec.Router = &amp;networkv1.RouterConfig{
                        Enabled:                  spec.Router.Enabled,
                        ExternalGatewayNetworkId: spec.Router.ExternalGatewayNetworkID,
                        EnableSnat:               spec.Router.EnableSNAT,
                }
                for _, route := range spec.Router.Routes </span><span class="cov0" title="0">{
                        protoSpec.Router.Routes = append(protoSpec.Router.Routes, &amp;networkv1.StaticRoute{
                                Destination: route.Destination,
                                NextHop:     route.NextHop,
                        })
                }</span>
        }

        <span class="cov0" title="0">return protoSpec</span>
}

// convertNetworkStatusToProto converts domain.VirtualNetworkStatus to networkv1.VirtualNetworkStatus.
func convertNetworkStatusToProto(status *domain.VirtualNetworkStatus) *networkv1.VirtualNetworkStatus <span class="cov0" title="0">{
        if status == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;networkv1.VirtualNetworkStatus{
                Phase:            networkv1.VirtualNetworkStatus_Phase(networkv1.VirtualNetworkStatus_Phase_value[string(status.Phase)]),
                OvnLogicalSwitch: status.OVNLogicalSwitch,
                OvnLogicalRouter: status.OVNLogicalRouter,
                PortCount:        status.PortCount,
                IpStatus: &amp;networkv1.IpAllocationStatus{
                        Ipv4Total:     status.IPAllocationStatus.IPv4Total,
                        Ipv4Allocated: status.IPAllocationStatus.IPv4Allocated,
                        Ipv4Available: status.IPAllocationStatus.IPv4Available,
                        Ipv6Allocated: status.IPAllocationStatus.IPv6Allocated,
                },
                ErrorMessage: status.ErrorMessage,
        }</span>
}

// convertCreateNetworkRequestToDomain converts a CreateNetworkRequest to domain.VirtualNetwork.
func convertCreateNetworkRequestToDomain(req *networkv1.CreateNetworkRequest) *domain.VirtualNetwork <span class="cov0" title="0">{
        net := &amp;domain.VirtualNetwork{
                Name:        req.Name,
                ProjectID:   req.ProjectId,
                Description: req.Description,
                Labels:      req.Labels,
                Status: domain.VirtualNetworkStatus{
                        Phase: domain.NetworkPhasePending,
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if req.Spec != nil </span><span class="cov0" title="0">{
                net.Spec = *convertNetworkSpecFromProto(req.Spec)
        }</span>

        <span class="cov0" title="0">return net</span>
}

// convertNetworkSpecFromProto converts networkv1.VirtualNetworkSpec to domain.VirtualNetworkSpec.
func convertNetworkSpecFromProto(spec *networkv1.VirtualNetworkSpec) *domain.VirtualNetworkSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">domainSpec := &amp;domain.VirtualNetworkSpec{
                Type:                   domain.NetworkType(spec.Type.String()),
                MTU:                    spec.Mtu,
                DefaultSecurityGroupID: spec.DefaultSecurityGroupId,
                PortSecurityEnabled:    spec.PortSecurityEnabled,
        }

        if spec.IpConfig != nil </span><span class="cov0" title="0">{
                domainSpec.IPConfig = domain.IPAddressConfig{
                        IPv4Subnet:  spec.IpConfig.Ipv4Subnet,
                        IPv4Gateway: spec.IpConfig.Ipv4Gateway,
                        IPv6Subnet:  spec.IpConfig.Ipv6Subnet,
                        IPv6Gateway: spec.IpConfig.Ipv6Gateway,
                        ReservedIPs: spec.IpConfig.ReservedIps,
                }
                if spec.IpConfig.Dhcp != nil </span><span class="cov0" title="0">{
                        domainSpec.IPConfig.DHCP = domain.DHCPConfig{
                                Enabled:      spec.IpConfig.Dhcp.Enabled,
                                LeaseTimeSec: spec.IpConfig.Dhcp.LeaseTimeSec,
                                DNSServers:   spec.IpConfig.Dhcp.DnsServers,
                                NTPServers:   spec.IpConfig.Dhcp.NtpServers,
                                DomainName:   spec.IpConfig.Dhcp.DomainName,
                        }
                }</span>
                <span class="cov0" title="0">for _, pool := range spec.IpConfig.AllocationPools </span><span class="cov0" title="0">{
                        domainSpec.IPConfig.AllocationPools = append(domainSpec.IPConfig.AllocationPools, domain.IPRange{
                                Start: pool.Start,
                                End:   pool.End,
                        })
                }</span>
        }

        <span class="cov0" title="0">if spec.Dns != nil </span><span class="cov0" title="0">{
                domainSpec.DNS = domain.DNSConfig{
                        Nameservers:   spec.Dns.Nameservers,
                        SearchDomains: spec.Dns.SearchDomains,
                }
        }</span>

        <span class="cov0" title="0">if spec.Router != nil </span><span class="cov0" title="0">{
                domainSpec.Router = &amp;domain.RouterConfig{
                        Enabled:                  spec.Router.Enabled,
                        ExternalGatewayNetworkID: spec.Router.ExternalGatewayNetworkId,
                        EnableSNAT:               spec.Router.EnableSnat,
                }
                for _, route := range spec.Router.Routes </span><span class="cov0" title="0">{
                        domainSpec.Router.Routes = append(domainSpec.Router.Routes, domain.StaticRoute{
                                Destination: route.Destination,
                                NextHop:     route.NextHop,
                        })
                }</span>
        }

        <span class="cov0" title="0">return domainSpec</span>
}

// convertNetworkFilterFromProto converts list request to NetworkFilter.
func convertNetworkFilterFromProto(req *networkv1.ListNetworksRequest) NetworkFilter <span class="cov0" title="0">{
        return NetworkFilter{
                ProjectID:   req.ProjectId,
                NetworkType: domain.NetworkType(req.Type.String()),
                Labels:      req.Labels,
        }
}</span>

// convertNetworksToProtos converts a slice of domain networks to proto networks.
func convertNetworksToProtos(networks []*domain.VirtualNetwork) []*networkv1.VirtualNetwork <span class="cov0" title="0">{
        if networks == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]*networkv1.VirtualNetwork, len(networks))
        for i, net := range networks </span><span class="cov0" title="0">{
                result[i] = convertNetworkToProto(net)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// =============================================================================
// SECURITY GROUP CONVERTERS
// =============================================================================

// convertSecurityGroupToProto converts domain.SecurityGroup to networkv1.SecurityGroup.
func convertSecurityGroupToProto(sg *domain.SecurityGroup) *networkv1.SecurityGroup <span class="cov0" title="0">{
        if sg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoSG := &amp;networkv1.SecurityGroup{
                Id:          sg.ID,
                Name:        sg.Name,
                Description: sg.Description,
                ProjectId:   sg.ProjectID,
                Labels:      sg.Labels,
                Stateful:    sg.Stateful,
                CreatedAt:   timestamppb.New(sg.CreatedAt),
                UpdatedAt:   timestamppb.New(sg.UpdatedAt),
        }

        for _, rule := range sg.Rules </span><span class="cov0" title="0">{
                protoSG.Rules = append(protoSG.Rules, convertRuleToProto(&amp;rule))
        }</span>

        <span class="cov0" title="0">return protoSG</span>
}

// convertRuleToProto converts domain.SecurityGroupRule to networkv1.SecurityGroupRule.
func convertRuleToProto(rule *domain.SecurityGroupRule) *networkv1.SecurityGroupRule <span class="cov0" title="0">{
        if rule == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;networkv1.SecurityGroupRule{
                Id:                    rule.ID,
                Direction:             networkv1.SecurityGroupRule_Direction(networkv1.SecurityGroupRule_Direction_value[string(rule.Direction)]),
                Protocol:              rule.Protocol,
                PortMin:               rule.PortMin,
                PortMax:               rule.PortMax,
                IcmpType:              rule.ICMPType,
                IcmpCode:              rule.ICMPCode,
                RemoteIpPrefix:        rule.RemoteIPPrefix,
                RemoteSecurityGroupId: rule.RemoteSecurityGroupID,
                Action:                networkv1.SecurityGroupRule_Action(networkv1.SecurityGroupRule_Action_value[string(rule.Action)]),
                Priority:              rule.Priority,
                Description:           rule.Description,
        }</span>
}

// convertCreateSecurityGroupRequestToDomain converts a CreateSecurityGroupRequest.
func convertCreateSecurityGroupRequestToDomain(req *networkv1.CreateSecurityGroupRequest) *domain.SecurityGroup <span class="cov0" title="0">{
        sg := &amp;domain.SecurityGroup{
                Name:        req.Name,
                Description: req.Description,
                ProjectID:   req.ProjectId,
                Labels:      req.Labels,
                Stateful:    req.Stateful,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        for _, rule := range req.Rules </span><span class="cov0" title="0">{
                sg.Rules = append(sg.Rules, *convertRuleFromProto(rule))
        }</span>

        <span class="cov0" title="0">return sg</span>
}

// convertRuleFromProto converts networkv1.SecurityGroupRule to domain.SecurityGroupRule.
func convertRuleFromProto(rule *networkv1.SecurityGroupRule) *domain.SecurityGroupRule <span class="cov0" title="0">{
        if rule == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;domain.SecurityGroupRule{
                ID:                    rule.Id,
                Direction:             domain.RuleDirection(rule.Direction.String()),
                Protocol:              rule.Protocol,
                PortMin:               rule.PortMin,
                PortMax:               rule.PortMax,
                ICMPType:              rule.IcmpType,
                ICMPCode:              rule.IcmpCode,
                RemoteIPPrefix:        rule.RemoteIpPrefix,
                RemoteSecurityGroupID: rule.RemoteSecurityGroupId,
                Action:                domain.RuleAction(rule.Action.String()),
                Priority:              rule.Priority,
                Description:           rule.Description,
        }</span>
}

// convertSecurityGroupsToProtos converts a slice of domain security groups to proto.
func convertSecurityGroupsToProtos(sgs []*domain.SecurityGroup) []*networkv1.SecurityGroup <span class="cov0" title="0">{
        if sgs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]*networkv1.SecurityGroup, len(sgs))
        for i, sg := range sgs </span><span class="cov0" title="0">{
                result[i] = convertSecurityGroupToProto(sg)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package network implements the VirtualNetworkService.
package network

import (
        "context"
        "fmt"
        "time"

        "connectrpc.com/connect"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        networkv1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/network/v1"
)

// NetworkService implements the networkv1connect.VirtualNetworkServiceHandler interface.
type NetworkService struct {
        repo   NetworkRepository
        logger *zap.Logger
}

// NewNetworkService creates a new NetworkService.
func NewNetworkService(repo NetworkRepository, logger *zap.Logger) *NetworkService <span class="cov0" title="0">{
        return &amp;NetworkService{
                repo:   repo,
                logger: logger,
        }
}</span>

// CreateNetwork creates a new virtual network.
func (s *NetworkService) CreateNetwork(
        ctx context.Context,
        req *connect.Request[networkv1.CreateNetworkRequest],
) (*connect.Response[networkv1.VirtualNetwork], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "CreateNetwork"),
                zap.String("network_name", req.Msg.Name),
        )
        logger.Info("Creating virtual network")

        // Validate request
        if req.Msg.Name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("name is required"))
        }</span>
        <span class="cov0" title="0">if req.Msg.Spec == nil || req.Msg.Spec.IpConfig == nil || req.Msg.Spec.IpConfig.Ipv4Subnet == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("ipv4_subnet is required"))
        }</span>

        // Convert to domain model
        <span class="cov0" title="0">network := convertCreateNetworkRequestToDomain(req.Msg)
        if network.Spec.MTU == 0 </span><span class="cov0" title="0">{
                network.Spec.MTU = 1500 // Default MTU
        }</span>

        // Create in repository
        <span class="cov0" title="0">createdNetwork, err := s.repo.Create(ctx, network)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create network", zap.Error(err))
                if err == domain.ErrAlreadyExists </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeAlreadyExists, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Simulate network becoming ready (in real implementation, OVN integration)
        <span class="cov0" title="0">createdNetwork.Status.Phase = domain.NetworkPhaseReady
        createdNetwork.Status.OVNLogicalSwitch = fmt.Sprintf("ls-%s", createdNetwork.ID[:8])
        createdNetwork.Status.IPAllocationStatus = domain.IPAllocationStatus{
                IPv4Total:     254, // Assuming /24 subnet
                IPv4Available: 254,
        }
        if err := s.repo.UpdateStatus(ctx, createdNetwork.ID, createdNetwork.Status); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to update network status", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Virtual network created successfully", zap.String("network_id", createdNetwork.ID))
        return connect.NewResponse(convertNetworkToProto(createdNetwork)), nil</span>
}

// GetNetwork retrieves a virtual network by ID.
func (s *NetworkService) GetNetwork(
        ctx context.Context,
        req *connect.Request[networkv1.GetNetworkRequest],
) (*connect.Response[networkv1.VirtualNetwork], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetNetwork"),
                zap.String("network_id", req.Msg.Id),
        )
        logger.Debug("Getting virtual network")

        network, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(convertNetworkToProto(network)), nil</span>
}

// ListNetworks returns all virtual networks matching the filter.
func (s *NetworkService) ListNetworks(
        ctx context.Context,
        req *connect.Request[networkv1.ListNetworksRequest],
) (*connect.Response[networkv1.ListNetworksResponse], error) <span class="cov0" title="0">{
        logger := s.logger.With(zap.String("method", "ListNetworks"))
        logger.Debug("Listing virtual networks")

        filter := convertNetworkFilterFromProto(req.Msg)
        limit := int(req.Msg.PageSize)
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">networks, total, err := s.repo.List(ctx, filter, limit, 0)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list networks", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;networkv1.ListNetworksResponse{
                Networks:   convertNetworksToProtos(networks),
                TotalCount: int32(total),
        }), nil</span>
}

// UpdateNetwork updates a virtual network configuration.
func (s *NetworkService) UpdateNetwork(
        ctx context.Context,
        req *connect.Request[networkv1.UpdateNetworkRequest],
) (*connect.Response[networkv1.VirtualNetwork], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "UpdateNetwork"),
                zap.String("network_id", req.Msg.Id),
        )
        logger.Info("Updating virtual network")

        network, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Apply updates
        <span class="cov0" title="0">if req.Msg.Description != "" </span><span class="cov0" title="0">{
                network.Description = req.Msg.Description
        }</span>
        <span class="cov0" title="0">if req.Msg.Labels != nil </span><span class="cov0" title="0">{
                network.Labels = req.Msg.Labels
        }</span>
        <span class="cov0" title="0">if req.Msg.Spec != nil </span><span class="cov0" title="0">{
                network.Spec = *convertNetworkSpecFromProto(req.Msg.Spec)
        }</span>
        <span class="cov0" title="0">network.UpdatedAt = time.Now()

        updatedNetwork, err := s.repo.Update(ctx, network)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update network", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Virtual network updated successfully", zap.String("network_id", updatedNetwork.ID))
        return connect.NewResponse(convertNetworkToProto(updatedNetwork)), nil</span>
}

// DeleteNetwork removes a virtual network.
func (s *NetworkService) DeleteNetwork(
        ctx context.Context,
        req *connect.Request[networkv1.DeleteNetworkRequest],
) (*connect.Response[emptypb.Empty], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "DeleteNetwork"),
                zap.String("network_id", req.Msg.Id),
        )
        logger.Info("Deleting virtual network")

        // Check if network has ports (would need PortRepository for this)
        network, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">if network.Status.PortCount &gt; 0 &amp;&amp; !req.Msg.Force </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeFailedPrecondition,
                        fmt.Errorf("network has %d ports, use force=true to delete", network.Status.PortCount))
        }</span>

        <span class="cov0" title="0">if err := s.repo.Delete(ctx, req.Msg.Id); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete network", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Virtual network deleted successfully", zap.String("network_id", req.Msg.Id))
        return connect.NewResponse(&amp;emptypb.Empty{}), nil</span>
}

// GetNetworkTopology returns the network topology graph.
func (s *NetworkService) GetNetworkTopology(
        ctx context.Context,
        req *connect.Request[networkv1.GetNetworkTopologyRequest],
) (*connect.Response[networkv1.NetworkTopology], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetNetworkTopology"),
                zap.String("project_id", req.Msg.ProjectId),
        )
        logger.Debug("Getting network topology")

        // Get all networks for the project
        filter := NetworkFilter{ProjectID: req.Msg.ProjectId}
        networks, _, err := s.repo.List(ctx, filter, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Build topology graph
        <span class="cov0" title="0">var nodes []*networkv1.NetworkNode
        var edges []*networkv1.NetworkEdge

        for _, net := range networks </span><span class="cov0" title="0">{
                nodes = append(nodes, &amp;networkv1.NetworkNode{
                        Id:   net.ID,
                        Type: "network",
                        Name: net.Name,
                        Properties: map[string]string{
                                "subnet": net.Spec.IPConfig.IPv4Subnet,
                                "type":   string(net.Spec.Type),
                        },
                })

                // If network has router, add router node and edge
                if net.Spec.Router != nil &amp;&amp; net.Spec.Router.Enabled </span><span class="cov0" title="0">{
                        routerID := fmt.Sprintf("router-%s", net.ID[:8])
                        nodes = append(nodes, &amp;networkv1.NetworkNode{
                                Id:   routerID,
                                Type: "router",
                                Name: fmt.Sprintf("Router for %s", net.Name),
                        })
                        edges = append(edges, &amp;networkv1.NetworkEdge{
                                SourceId: net.ID,
                                TargetId: routerID,
                                Type:     "route",
                        })
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;networkv1.NetworkTopology{
                Nodes: nodes,
                Edges: edges,
        }), nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package network implements the SecurityGroupService.
package network

import (
        "context"
        "fmt"
        "time"

        "connectrpc.com/connect"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        networkv1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/network/v1"
)

// SecurityGroupService implements the networkv1connect.SecurityGroupServiceHandler interface.
type SecurityGroupService struct {
        repo   SecurityGroupRepository
        logger *zap.Logger
}

// NewSecurityGroupService creates a new SecurityGroupService.
func NewSecurityGroupService(repo SecurityGroupRepository, logger *zap.Logger) *SecurityGroupService <span class="cov0" title="0">{
        return &amp;SecurityGroupService{
                repo:   repo,
                logger: logger,
        }
}</span>

// CreateSecurityGroup creates a new security group.
func (s *SecurityGroupService) CreateSecurityGroup(
        ctx context.Context,
        req *connect.Request[networkv1.CreateSecurityGroupRequest],
) (*connect.Response[networkv1.SecurityGroup], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "CreateSecurityGroup"),
                zap.String("sg_name", req.Msg.Name),
        )
        logger.Info("Creating security group")

        if req.Msg.Name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("name is required"))
        }</span>

        <span class="cov0" title="0">sg := convertCreateSecurityGroupRequestToDomain(req.Msg)

        // Assign IDs to rules
        for i := range sg.Rules </span><span class="cov0" title="0">{
                if sg.Rules[i].ID == "" </span><span class="cov0" title="0">{
                        sg.Rules[i].ID = uuid.NewString()
                }</span>
        }

        <span class="cov0" title="0">createdSG, err := s.repo.Create(ctx, sg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create security group", zap.Error(err))
                if err == domain.ErrAlreadyExists </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeAlreadyExists, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">logger.Info("Security group created successfully", zap.String("sg_id", createdSG.ID))
        return connect.NewResponse(convertSecurityGroupToProto(createdSG)), nil</span>
}

// GetSecurityGroup retrieves a security group by ID.
func (s *SecurityGroupService) GetSecurityGroup(
        ctx context.Context,
        req *connect.Request[networkv1.GetSecurityGroupRequest],
) (*connect.Response[networkv1.SecurityGroup], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetSecurityGroup"),
                zap.String("sg_id", req.Msg.Id),
        )
        logger.Debug("Getting security group")

        sg, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(convertSecurityGroupToProto(sg)), nil</span>
}

// ListSecurityGroups returns all security groups.
func (s *SecurityGroupService) ListSecurityGroups(
        ctx context.Context,
        req *connect.Request[networkv1.ListSecurityGroupsRequest],
) (*connect.Response[networkv1.ListSecurityGroupsResponse], error) <span class="cov0" title="0">{
        logger := s.logger.With(zap.String("method", "ListSecurityGroups"))
        logger.Debug("Listing security groups")

        limit := int(req.Msg.PageSize)
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">sgs, total, err := s.repo.List(ctx, req.Msg.ProjectId, limit, 0)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list security groups", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;networkv1.ListSecurityGroupsResponse{
                SecurityGroups: convertSecurityGroupsToProtos(sgs),
                TotalCount:     int32(total),
        }), nil</span>
}

// UpdateSecurityGroup updates a security group.
func (s *SecurityGroupService) UpdateSecurityGroup(
        ctx context.Context,
        req *connect.Request[networkv1.UpdateSecurityGroupRequest],
) (*connect.Response[networkv1.SecurityGroup], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "UpdateSecurityGroup"),
                zap.String("sg_id", req.Msg.Id),
        )
        logger.Info("Updating security group")

        sg, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">if req.Msg.Description != "" </span><span class="cov0" title="0">{
                sg.Description = req.Msg.Description
        }</span>
        <span class="cov0" title="0">if req.Msg.Labels != nil </span><span class="cov0" title="0">{
                sg.Labels = req.Msg.Labels
        }</span>
        <span class="cov0" title="0">sg.UpdatedAt = time.Now()

        updatedSG, err := s.repo.Update(ctx, sg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update security group", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Security group updated successfully", zap.String("sg_id", updatedSG.ID))
        return connect.NewResponse(convertSecurityGroupToProto(updatedSG)), nil</span>
}

// DeleteSecurityGroup removes a security group.
func (s *SecurityGroupService) DeleteSecurityGroup(
        ctx context.Context,
        req *connect.Request[networkv1.DeleteSecurityGroupRequest],
) (*connect.Response[emptypb.Empty], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "DeleteSecurityGroup"),
                zap.String("sg_id", req.Msg.Id),
        )
        logger.Info("Deleting security group")

        // TODO: Check if security group is in use by any ports

        if err := s.repo.Delete(ctx, req.Msg.Id); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete security group", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">logger.Info("Security group deleted successfully", zap.String("sg_id", req.Msg.Id))
        return connect.NewResponse(&amp;emptypb.Empty{}), nil</span>
}

// AddRule adds a firewall rule to a security group.
func (s *SecurityGroupService) AddRule(
        ctx context.Context,
        req *connect.Request[networkv1.AddRuleRequest],
) (*connect.Response[networkv1.SecurityGroup], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "AddRule"),
                zap.String("sg_id", req.Msg.SecurityGroupId),
        )
        logger.Info("Adding rule to security group")

        sg, err := s.repo.Get(ctx, req.Msg.SecurityGroupId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Convert and add rule
        <span class="cov0" title="0">rule := convertRuleFromProto(req.Msg.Rule)
        if rule.ID == "" </span><span class="cov0" title="0">{
                rule.ID = uuid.NewString()
        }</span>
        <span class="cov0" title="0">sg.Rules = append(sg.Rules, *rule)
        sg.UpdatedAt = time.Now()

        updatedSG, err := s.repo.Update(ctx, sg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add rule", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Rule added successfully", zap.String("rule_id", rule.ID))
        return connect.NewResponse(convertSecurityGroupToProto(updatedSG)), nil</span>
}

// RemoveRule removes a firewall rule from a security group.
func (s *SecurityGroupService) RemoveRule(
        ctx context.Context,
        req *connect.Request[networkv1.RemoveRuleRequest],
) (*connect.Response[networkv1.SecurityGroup], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "RemoveRule"),
                zap.String("sg_id", req.Msg.SecurityGroupId),
                zap.String("rule_id", req.Msg.RuleId),
        )
        logger.Info("Removing rule from security group")

        sg, err := s.repo.Get(ctx, req.Msg.SecurityGroupId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Find and remove rule
        <span class="cov0" title="0">var newRules []domain.SecurityGroupRule
        found := false
        for _, rule := range sg.Rules </span><span class="cov0" title="0">{
                if rule.ID == req.Msg.RuleId </span><span class="cov0" title="0">{
                        found = true
                        continue</span>
                }
                <span class="cov0" title="0">newRules = append(newRules, rule)</span>
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("rule %s not found", req.Msg.RuleId))
        }</span>

        <span class="cov0" title="0">sg.Rules = newRules
        sg.UpdatedAt = time.Now()

        updatedSG, err := s.repo.Update(ctx, sg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove rule", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Rule removed successfully", zap.String("rule_id", req.Msg.RuleId))
        return connect.NewResponse(convertSecurityGroupToProto(updatedSG)), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package storage provides converters between protobuf and domain types.
package storage

import (
        "time"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        storagev1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/storage/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// =============================================================================
// STORAGE POOL CONVERTERS
// =============================================================================

// convertPoolToProto converts a domain.StoragePool to a storagev1.StoragePool.
func convertPoolToProto(pool *domain.StoragePool) *storagev1.StoragePool <span class="cov0" title="0">{
        if pool == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;storagev1.StoragePool{
                Id:          pool.ID,
                Name:        pool.Name,
                ProjectId:   pool.ProjectID,
                Description: pool.Description,
                Labels:      pool.Labels,
                Spec:        convertPoolSpecToProto(&amp;pool.Spec),
                Status:      convertPoolStatusToProto(&amp;pool.Status),
                CreatedAt:   timestamppb.New(pool.CreatedAt),
                UpdatedAt:   timestamppb.New(pool.UpdatedAt),
        }</span>
}

// convertPoolSpecToProto converts domain.StoragePoolSpec to storagev1.StoragePoolSpec.
func convertPoolSpecToProto(spec *domain.StoragePoolSpec) *storagev1.StoragePoolSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoSpec := &amp;storagev1.StoragePoolSpec{
                Defaults: &amp;storagev1.VolumeDefaults{
                        Filesystem: spec.Defaults.Filesystem,
                        BlockSize:  spec.Defaults.BlockSize,
                },
                Qos: &amp;storagev1.StorageQos{
                        MaxIops:              spec.QoS.MaxIOPS,
                        MaxThroughputBytes:   spec.QoS.MaxThroughputBytes,
                        BurstIops:            spec.QoS.BurstIOPS,
                        BurstThroughputBytes: spec.QoS.BurstThroughputBytes,
                        BurstDurationSec:     spec.QoS.BurstDurationSec,
                },
                Encryption: &amp;storagev1.EncryptionConfig{
                        Enabled:     spec.Encryption.Enabled,
                        Cipher:      spec.Encryption.Cipher,
                        KmsEndpoint: spec.Encryption.KMSEndpoint,
                        KmsKeyId:    spec.Encryption.KMSKeyID,
                },
                Replication: &amp;storagev1.ReplicationConfig{
                        ReplicaCount:  spec.Replication.ReplicaCount,
                        MinReplicas:   spec.Replication.MinReplicas,
                        FailureDomain: spec.Replication.FailureDomain,
                },
        }

        // Convert backend
        protoSpec.Backend = &amp;storagev1.StorageBackend{
                Type: storagev1.StorageBackend_BackendType(storagev1.StorageBackend_BackendType_value[string(spec.Backend.Type)]),
        }

        return protoSpec</span>
}

// convertPoolStatusToProto converts domain.StoragePoolStatus to storagev1.StoragePoolStatus.
func convertPoolStatusToProto(status *domain.StoragePoolStatus) *storagev1.StoragePoolStatus <span class="cov0" title="0">{
        if status == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;storagev1.StoragePoolStatus{
                Phase: storagev1.StoragePoolStatus_Phase(storagev1.StoragePoolStatus_Phase_value[string(status.Phase)]),
                Capacity: &amp;storagev1.StorageCapacity{
                        TotalBytes:       status.Capacity.TotalBytes,
                        UsedBytes:        status.Capacity.UsedBytes,
                        AvailableBytes:   status.Capacity.AvailableBytes,
                        ProvisionedBytes: status.Capacity.ProvisionedBytes,
                },
                Metrics: &amp;storagev1.StorageMetrics{
                        ReadIops:       status.Metrics.ReadIOPS,
                        WriteIops:      status.Metrics.WriteIOPS,
                        ReadBytesSec:   status.Metrics.ReadBytesPerSec,
                        WriteBytesSec:  status.Metrics.WriteBytesPerSec,
                        ReadLatencyUs:  status.Metrics.ReadLatencyUs,
                        WriteLatencyUs: status.Metrics.WriteLatencyUs,
                },
                VolumeCount:  status.VolumeCount,
                ErrorMessage: status.ErrorMessage,
        }</span>
}

// convertCreatePoolRequestToDomain converts a CreatePoolRequest to domain.StoragePool.
func convertCreatePoolRequestToDomain(req *storagev1.CreatePoolRequest) *domain.StoragePool <span class="cov0" title="0">{
        pool := &amp;domain.StoragePool{
                Name:        req.Name,
                ProjectID:   req.ProjectId,
                Description: req.Description,
                Labels:      req.Labels,
                Status: domain.StoragePoolStatus{
                        Phase: domain.StoragePoolPhasePending,
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if req.Spec != nil </span><span class="cov0" title="0">{
                pool.Spec = *convertPoolSpecFromProto(req.Spec)
        }</span>

        <span class="cov0" title="0">return pool</span>
}

// convertPoolSpecFromProto converts storagev1.StoragePoolSpec to domain.StoragePoolSpec.
func convertPoolSpecFromProto(spec *storagev1.StoragePoolSpec) *domain.StoragePoolSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">domainSpec := &amp;domain.StoragePoolSpec{}

        if spec.Backend != nil </span><span class="cov0" title="0">{
                domainSpec.Backend = domain.StorageBackend{
                        Type: domain.BackendType(spec.Backend.Type.String()),
                }
        }</span>

        <span class="cov0" title="0">if spec.Defaults != nil </span><span class="cov0" title="0">{
                domainSpec.Defaults = domain.VolumeDefaults{
                        Filesystem: spec.Defaults.Filesystem,
                        BlockSize:  spec.Defaults.BlockSize,
                }
        }</span>

        <span class="cov0" title="0">if spec.Qos != nil </span><span class="cov0" title="0">{
                domainSpec.QoS = domain.StorageQoS{
                        MaxIOPS:              spec.Qos.MaxIops,
                        MaxThroughputBytes:   spec.Qos.MaxThroughputBytes,
                        BurstIOPS:            spec.Qos.BurstIops,
                        BurstThroughputBytes: spec.Qos.BurstThroughputBytes,
                        BurstDurationSec:     spec.Qos.BurstDurationSec,
                }
        }</span>

        <span class="cov0" title="0">if spec.Encryption != nil </span><span class="cov0" title="0">{
                domainSpec.Encryption = domain.EncryptionConfig{
                        Enabled:     spec.Encryption.Enabled,
                        Cipher:      spec.Encryption.Cipher,
                        KMSEndpoint: spec.Encryption.KmsEndpoint,
                        KMSKeyID:    spec.Encryption.KmsKeyId,
                }
        }</span>

        <span class="cov0" title="0">if spec.Replication != nil </span><span class="cov0" title="0">{
                domainSpec.Replication = domain.ReplicationConfig{
                        ReplicaCount:  spec.Replication.ReplicaCount,
                        MinReplicas:   spec.Replication.MinReplicas,
                        FailureDomain: spec.Replication.FailureDomain,
                }
        }</span>

        <span class="cov0" title="0">return domainSpec</span>
}

// convertPoolFilterFromProto converts list request to PoolFilter.
func convertPoolFilterFromProto(req *storagev1.ListPoolsRequest) PoolFilter <span class="cov0" title="0">{
        filter := PoolFilter{
                ProjectID: req.ProjectId,
                Labels:    req.Labels,
        }
        if req.BackendType != storagev1.StorageBackend_CEPH_RBD </span><span class="cov0" title="0">{
                filter.BackendType = domain.BackendType(req.BackendType.String())
        }</span>
        <span class="cov0" title="0">return filter</span>
}

// convertPoolsToProtos converts a slice of domain pools to proto pools.
func convertPoolsToProtos(pools []*domain.StoragePool) []*storagev1.StoragePool <span class="cov0" title="0">{
        if pools == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]*storagev1.StoragePool, len(pools))
        for i, pool := range pools </span><span class="cov0" title="0">{
                result[i] = convertPoolToProto(pool)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package storage implements the StoragePoolService and VolumeService.
package storage

import (
        "context"
        "fmt"
        "time"

        "connectrpc.com/connect"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        storagev1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/storage/v1"
)

// PoolService implements the storagev1connect.StoragePoolServiceHandler interface.
type PoolService struct {
        repo   PoolRepository
        logger *zap.Logger
}

// NewPoolService creates a new PoolService.
func NewPoolService(repo PoolRepository, logger *zap.Logger) *PoolService <span class="cov0" title="0">{
        return &amp;PoolService{
                repo:   repo,
                logger: logger,
        }
}</span>

// CreatePool creates a new storage pool.
func (s *PoolService) CreatePool(
        ctx context.Context,
        req *connect.Request[storagev1.CreatePoolRequest],
) (*connect.Response[storagev1.StoragePool], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "CreatePool"),
                zap.String("pool_name", req.Msg.Name),
        )
        logger.Info("Creating storage pool")

        // Validate request
        if req.Msg.Name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("name is required"))
        }</span>

        // Convert to domain model
        <span class="cov0" title="0">pool := convertCreatePoolRequestToDomain(req.Msg)
        pool.Status.Phase = domain.StoragePoolPhasePending

        // Create in repository
        createdPool, err := s.repo.Create(ctx, pool)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create storage pool", zap.Error(err))
                if err == domain.ErrAlreadyExists </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeAlreadyExists, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Simulate pool becoming ready (in real implementation, would be async)
        <span class="cov0" title="0">createdPool.Status.Phase = domain.StoragePoolPhaseReady
        createdPool.Status.Capacity = domain.StorageCapacity{
                TotalBytes:     100 * 1024 * 1024 * 1024, // 100 GiB
                AvailableBytes: 100 * 1024 * 1024 * 1024,
        }
        if err := s.repo.UpdateStatus(ctx, createdPool.ID, createdPool.Status); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to update pool status", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Storage pool created successfully", zap.String("pool_id", createdPool.ID))
        return connect.NewResponse(convertPoolToProto(createdPool)), nil</span>
}

// GetPool retrieves a storage pool by ID.
func (s *PoolService) GetPool(
        ctx context.Context,
        req *connect.Request[storagev1.GetPoolRequest],
) (*connect.Response[storagev1.StoragePool], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetPool"),
                zap.String("pool_id", req.Msg.Id),
        )
        logger.Debug("Getting storage pool")

        pool, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get storage pool", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(convertPoolToProto(pool)), nil</span>
}

// ListPools returns all storage pools matching the filter.
func (s *PoolService) ListPools(
        ctx context.Context,
        req *connect.Request[storagev1.ListPoolsRequest],
) (*connect.Response[storagev1.ListPoolsResponse], error) <span class="cov0" title="0">{
        logger := s.logger.With(zap.String("method", "ListPools"))
        logger.Debug("Listing storage pools")

        filter := convertPoolFilterFromProto(req.Msg)
        limit := int(req.Msg.PageSize)
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov0" title="0">offset := 0 // Simple pagination

        pools, total, err := s.repo.List(ctx, filter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list storage pools", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;storagev1.ListPoolsResponse{
                Pools:      convertPoolsToProtos(pools),
                TotalCount: int32(total),
        }), nil</span>
}

// UpdatePool updates a storage pool configuration.
func (s *PoolService) UpdatePool(
        ctx context.Context,
        req *connect.Request[storagev1.UpdatePoolRequest],
) (*connect.Response[storagev1.StoragePool], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "UpdatePool"),
                zap.String("pool_id", req.Msg.Id),
        )
        logger.Info("Updating storage pool")

        // Get existing pool
        pool, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Pool not found for update", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Apply updates
        <span class="cov0" title="0">if req.Msg.Description != "" </span><span class="cov0" title="0">{
                pool.Description = req.Msg.Description
        }</span>
        <span class="cov0" title="0">if req.Msg.Labels != nil </span><span class="cov0" title="0">{
                pool.Labels = req.Msg.Labels
        }</span>
        <span class="cov0" title="0">if req.Msg.Spec != nil </span><span class="cov0" title="0">{
                pool.Spec = *convertPoolSpecFromProto(req.Msg.Spec)
        }</span>
        <span class="cov0" title="0">pool.UpdatedAt = time.Now()

        // Save updates
        updatedPool, err := s.repo.Update(ctx, pool)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update storage pool", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Storage pool updated successfully", zap.String("pool_id", updatedPool.ID))
        return connect.NewResponse(convertPoolToProto(updatedPool)), nil</span>
}

// DeletePool removes a storage pool.
func (s *PoolService) DeletePool(
        ctx context.Context,
        req *connect.Request[storagev1.DeletePoolRequest],
) (*connect.Response[emptypb.Empty], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "DeletePool"),
                zap.String("pool_id", req.Msg.Id),
        )
        logger.Info("Deleting storage pool")

        // Check if pool has volumes (would need VolumeRepository for this)
        // For now, just delete

        if err := s.repo.Delete(ctx, req.Msg.Id); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete storage pool", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">logger.Info("Storage pool deleted successfully", zap.String("pool_id", req.Msg.Id))
        return connect.NewResponse(&amp;emptypb.Empty{}), nil</span>
}

// GetPoolMetrics returns current pool metrics.
func (s *PoolService) GetPoolMetrics(
        ctx context.Context,
        req *connect.Request[storagev1.GetPoolMetricsRequest],
) (*connect.Response[storagev1.PoolMetrics], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetPoolMetrics"),
                zap.String("pool_id", req.Msg.Id),
        )
        logger.Debug("Getting pool metrics")

        pool, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get pool for metrics", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">metrics := &amp;storagev1.PoolMetrics{
                PoolId:               pool.ID,
                TotalBytes:           pool.Status.Capacity.TotalBytes,
                UsedBytes:            pool.Status.Capacity.UsedBytes,
                AvailableBytes:       pool.Status.Capacity.AvailableBytes,
                ProvisionedBytes:     pool.Status.Capacity.ProvisionedBytes,
                ReadIops:             pool.Status.Metrics.ReadIOPS,
                WriteIops:            pool.Status.Metrics.WriteIOPS,
                ReadThroughputBytes:  pool.Status.Metrics.ReadBytesPerSec,
                WriteThroughputBytes: pool.Status.Metrics.WriteBytesPerSec,
                ReadLatencyUs:        pool.Status.Metrics.ReadLatencyUs,
                WriteLatencyUs:       pool.Status.Metrics.WriteLatencyUs,
                VolumeCount:          pool.Status.VolumeCount,
        }

        return connect.NewResponse(metrics), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package storage provides converters between protobuf and domain types.
package storage

import (
        "time"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        storagev1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/storage/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// =============================================================================
// VOLUME CONVERTERS
// =============================================================================

// convertVolumeToProto converts a domain.Volume to a storagev1.Volume.
func convertVolumeToProto(vol *domain.Volume) *storagev1.Volume <span class="cov0" title="0">{
        if vol == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;storagev1.Volume{
                Id:        vol.ID,
                Name:      vol.Name,
                ProjectId: vol.ProjectID,
                PoolId:    vol.PoolID,
                Labels:    vol.Labels,
                Spec:      convertVolumeSpecToProto(&amp;vol.Spec),
                Status:    convertVolumeStatusToProto(&amp;vol.Status),
                CreatedAt: timestamppb.New(vol.CreatedAt),
                UpdatedAt: timestamppb.New(vol.UpdatedAt),
        }</span>
}

// convertVolumeSpecToProto converts domain.VolumeSpec to storagev1.VolumeSpec.
func convertVolumeSpecToProto(spec *domain.VolumeSpec) *storagev1.VolumeSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoSpec := &amp;storagev1.VolumeSpec{
                SizeBytes:    spec.SizeBytes,
                Provisioning: storagev1.VolumeSpec_ProvisioningType(storagev1.VolumeSpec_ProvisioningType_value[string(spec.Provisioning)]),
                AccessMode:   storagev1.VolumeSpec_AccessMode(storagev1.VolumeSpec_AccessMode_value[string(spec.AccessMode)]),
                Qos: &amp;storagev1.VolumeQos{
                        MaxIops:          spec.QoS.MaxIOPS,
                        MinIops:          spec.QoS.MinIOPS,
                        MaxThroughput:    spec.QoS.MaxThroughput,
                        MinThroughput:    spec.QoS.MinThroughput,
                        BurstIops:        spec.QoS.BurstIOPS,
                        BurstThroughput:  spec.QoS.BurstThroughput,
                        BurstDurationSec: spec.QoS.BurstDurationSec,
                },
                Encryption: &amp;storagev1.EncryptionConfig{
                        Enabled:     spec.Encryption.Enabled,
                        Cipher:      spec.Encryption.Cipher,
                        KmsEndpoint: spec.Encryption.KMSEndpoint,
                        KmsKeyId:    spec.Encryption.KMSKeyID,
                },
        }

        return protoSpec</span>
}

// convertVolumeStatusToProto converts domain.VolumeStatus to storagev1.VolumeStatus.
func convertVolumeStatusToProto(status *domain.VolumeStatus) *storagev1.VolumeStatus <span class="cov0" title="0">{
        if status == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;storagev1.VolumeStatus{
                Phase:           storagev1.VolumeStatus_Phase(storagev1.VolumeStatus_Phase_value[string(status.Phase)]),
                AttachedVmId:    status.AttachedVMID,
                DevicePath:      status.DevicePath,
                ActualSizeBytes: status.ActualSizeBytes,
                Usage: &amp;storagev1.VolumeUsage{
                        UsedBytes:        status.Usage.UsedBytes,
                        ReadIops:         status.Usage.ReadIOPS,
                        WriteIops:        status.Usage.WriteIOPS,
                        ReadBytesSec:     status.Usage.ReadBytesPerSec,
                        WriteBytesSec:    status.Usage.WriteBytesPerSec,
                        ReadLatencyUs:    status.Usage.ReadLatencyUs,
                        WriteLatencyUs:   status.Usage.WriteLatencyUs,
                },
                SnapshotCount: status.SnapshotCount,
                ErrorMessage:  status.ErrorMessage,
                BackendId:     status.BackendID,
        }</span>
}

// convertCreateVolumeRequestToDomain converts a CreateVolumeRequest to domain.Volume.
func convertCreateVolumeRequestToDomain(req *storagev1.CreateVolumeRequest) *domain.Volume <span class="cov0" title="0">{
        vol := &amp;domain.Volume{
                Name:      req.Name,
                ProjectID: req.ProjectId,
                PoolID:    req.PoolId,
                Labels:    req.Labels,
                Status: domain.VolumeStatus{
                        Phase: domain.VolumePhasePending,
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if req.Spec != nil </span><span class="cov0" title="0">{
                vol.Spec = *convertVolumeSpecFromProto(req.Spec)
        }</span>

        <span class="cov0" title="0">return vol</span>
}

// convertVolumeSpecFromProto converts storagev1.VolumeSpec to domain.VolumeSpec.
func convertVolumeSpecFromProto(spec *storagev1.VolumeSpec) *domain.VolumeSpec <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">domainSpec := &amp;domain.VolumeSpec{
                SizeBytes:    spec.SizeBytes,
                Provisioning: domain.ProvisioningType(spec.Provisioning.String()),
                AccessMode:   domain.AccessMode(spec.AccessMode.String()),
        }

        if spec.Qos != nil </span><span class="cov0" title="0">{
                domainSpec.QoS = domain.VolumeQoS{
                        MaxIOPS:          spec.Qos.MaxIops,
                        MinIOPS:          spec.Qos.MinIops,
                        MaxThroughput:    spec.Qos.MaxThroughput,
                        MinThroughput:    spec.Qos.MinThroughput,
                        BurstIOPS:        spec.Qos.BurstIops,
                        BurstThroughput:  spec.Qos.BurstThroughput,
                        BurstDurationSec: spec.Qos.BurstDurationSec,
                }
        }</span>

        <span class="cov0" title="0">if spec.Encryption != nil </span><span class="cov0" title="0">{
                domainSpec.Encryption = domain.EncryptionConfig{
                        Enabled:     spec.Encryption.Enabled,
                        Cipher:      spec.Encryption.Cipher,
                        KMSEndpoint: spec.Encryption.KmsEndpoint,
                        KMSKeyID:    spec.Encryption.KmsKeyId,
                }
        }</span>

        // Handle source
        <span class="cov0" title="0">if spec.Source != nil </span><span class="cov0" title="0">{
                switch s := spec.Source.Source.(type) </span>{
                case *storagev1.VolumeSource_Empty:<span class="cov0" title="0">
                        domainSpec.Source = domain.VolumeSource{
                                Type:       "empty",
                                Filesystem: s.Empty.Filesystem,
                        }</span>
                case *storagev1.VolumeSource_Clone:<span class="cov0" title="0">
                        domainSpec.Source = domain.VolumeSource{
                                Type:     "clone",
                                VolumeID: s.Clone.VolumeId,
                        }</span>
                case *storagev1.VolumeSource_Snapshot:<span class="cov0" title="0">
                        domainSpec.Source = domain.VolumeSource{
                                Type:       "snapshot",
                                SnapshotID: s.Snapshot.SnapshotId,
                        }</span>
                case *storagev1.VolumeSource_Image:<span class="cov0" title="0">
                        domainSpec.Source = domain.VolumeSource{
                                Type:    "image",
                                ImageID: s.Image.ImageId,
                        }</span>
                }
        }

        <span class="cov0" title="0">return domainSpec</span>
}

// convertVolumeFilterFromProto converts list request to VolumeFilter.
func convertVolumeFilterFromProto(req *storagev1.ListVolumesRequest) VolumeFilter <span class="cov0" title="0">{
        filter := VolumeFilter{
                ProjectID:    req.ProjectId,
                PoolID:       req.PoolId,
                AttachedVMID: req.AttachedVmId,
                Labels:       req.Labels,
        }
        if req.Phase != storagev1.VolumeStatus_UNKNOWN </span><span class="cov0" title="0">{
                filter.Phase = domain.VolumePhase(req.Phase.String())
        }</span>
        <span class="cov0" title="0">return filter</span>
}

// convertVolumesToProtos converts a slice of domain volumes to proto volumes.
func convertVolumesToProtos(volumes []*domain.Volume) []*storagev1.Volume <span class="cov0" title="0">{
        if volumes == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]*storagev1.Volume, len(volumes))
        for i, vol := range volumes </span><span class="cov0" title="0">{
                result[i] = convertVolumeToProto(vol)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package storage implements the VolumeService.
package storage

import (
        "context"
        "fmt"
        "time"

        "connectrpc.com/connect"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
        storagev1 "github.com/Quantixkvm/Quantixkvm/pkg/api/Quantixkvm/storage/v1"
)

// VolumeService implements the storagev1connect.VolumeServiceHandler interface.
type VolumeService struct {
        repo     VolumeRepository
        poolRepo PoolRepository
        logger   *zap.Logger
}

// NewVolumeService creates a new VolumeService.
func NewVolumeService(repo VolumeRepository, poolRepo PoolRepository, logger *zap.Logger) *VolumeService <span class="cov0" title="0">{
        return &amp;VolumeService{
                repo:     repo,
                poolRepo: poolRepo,
                logger:   logger,
        }
}</span>

// CreateVolume creates a new volume.
func (s *VolumeService) CreateVolume(
        ctx context.Context,
        req *connect.Request[storagev1.CreateVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "CreateVolume"),
                zap.String("volume_name", req.Msg.Name),
                zap.String("pool_id", req.Msg.PoolId),
        )
        logger.Info("Creating volume")

        // Validate request
        if req.Msg.Name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("name is required"))
        }</span>
        <span class="cov0" title="0">if req.Msg.PoolId == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("pool_id is required"))
        }</span>
        <span class="cov0" title="0">if req.Msg.Spec == nil || req.Msg.Spec.SizeBytes &lt; 1024*1024 </span><span class="cov0" title="0">{ // Minimum 1 MiB
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("size must be at least 1 MiB"))
        }</span>

        // Verify pool exists
        <span class="cov0" title="0">_, err := s.poolRepo.Get(ctx, req.Msg.PoolId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("pool not found: %s", req.Msg.PoolId))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Convert to domain model
        <span class="cov0" title="0">vol := convertCreateVolumeRequestToDomain(req.Msg)
        vol.Status.Phase = domain.VolumePhasePending
        vol.Status.ActualSizeBytes = vol.Spec.SizeBytes

        // Create in repository
        createdVol, err := s.repo.Create(ctx, vol)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create volume", zap.Error(err))
                if err == domain.ErrAlreadyExists </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeAlreadyExists, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Simulate volume becoming ready
        <span class="cov0" title="0">createdVol.Status.Phase = domain.VolumePhaseReady
        if err := s.repo.UpdateStatus(ctx, createdVol.ID, createdVol.Status); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to update volume status", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Volume created successfully", zap.String("volume_id", createdVol.ID))
        return connect.NewResponse(convertVolumeToProto(createdVol)), nil</span>
}

// GetVolume retrieves a volume by ID.
func (s *VolumeService) GetVolume(
        ctx context.Context,
        req *connect.Request[storagev1.GetVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetVolume"),
                zap.String("volume_id", req.Msg.Id),
        )
        logger.Debug("Getting volume")

        vol, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get volume", zap.Error(err))
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(convertVolumeToProto(vol)), nil</span>
}

// ListVolumes returns volumes matching the filter.
func (s *VolumeService) ListVolumes(
        ctx context.Context,
        req *connect.Request[storagev1.ListVolumesRequest],
) (*connect.Response[storagev1.ListVolumesResponse], error) <span class="cov0" title="0">{
        logger := s.logger.With(zap.String("method", "ListVolumes"))
        logger.Debug("Listing volumes")

        filter := convertVolumeFilterFromProto(req.Msg)
        limit := int(req.Msg.PageSize)
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">volumes, total, err := s.repo.List(ctx, filter, limit, 0)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list volumes", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;storagev1.ListVolumesResponse{
                Volumes:    convertVolumesToProtos(volumes),
                TotalCount: int32(total),
        }), nil</span>
}

// UpdateVolume updates a volume configuration.
func (s *VolumeService) UpdateVolume(
        ctx context.Context,
        req *connect.Request[storagev1.UpdateVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "UpdateVolume"),
                zap.String("volume_id", req.Msg.Id),
        )
        logger.Info("Updating volume")

        vol, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Apply updates (only labels and QoS can be updated on live volume)
        <span class="cov0" title="0">if req.Msg.Labels != nil </span><span class="cov0" title="0">{
                vol.Labels = req.Msg.Labels
        }</span>
        <span class="cov0" title="0">if req.Msg.Spec != nil &amp;&amp; req.Msg.Spec.Qos != nil </span><span class="cov0" title="0">{
                vol.Spec.QoS = domain.VolumeQoS{
                        MaxIOPS:          req.Msg.Spec.Qos.MaxIops,
                        MinIOPS:          req.Msg.Spec.Qos.MinIops,
                        MaxThroughput:    req.Msg.Spec.Qos.MaxThroughput,
                        MinThroughput:    req.Msg.Spec.Qos.MinThroughput,
                        BurstIOPS:        req.Msg.Spec.Qos.BurstIops,
                        BurstThroughput:  req.Msg.Spec.Qos.BurstThroughput,
                        BurstDurationSec: req.Msg.Spec.Qos.BurstDurationSec,
                }
        }</span>
        <span class="cov0" title="0">vol.UpdatedAt = time.Now()

        updatedVol, err := s.repo.Update(ctx, vol)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update volume", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume updated successfully", zap.String("volume_id", updatedVol.ID))
        return connect.NewResponse(convertVolumeToProto(updatedVol)), nil</span>
}

// DeleteVolume removes a volume.
func (s *VolumeService) DeleteVolume(
        ctx context.Context,
        req *connect.Request[storagev1.DeleteVolumeRequest],
) (*connect.Response[emptypb.Empty], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "DeleteVolume"),
                zap.String("volume_id", req.Msg.Id),
        )
        logger.Info("Deleting volume")

        // Check if attached
        vol, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">if vol.IsAttached() &amp;&amp; !req.Msg.Force </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeFailedPrecondition, 
                        fmt.Errorf("volume is attached to VM %s, use force=true to delete", vol.Status.AttachedVMID))
        }</span>

        <span class="cov0" title="0">if err := s.repo.Delete(ctx, req.Msg.Id); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete volume", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume deleted successfully", zap.String("volume_id", req.Msg.Id))
        return connect.NewResponse(&amp;emptypb.Empty{}), nil</span>
}

// ResizeVolume expands a volume.
func (s *VolumeService) ResizeVolume(
        ctx context.Context,
        req *connect.Request[storagev1.ResizeVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "ResizeVolume"),
                zap.String("volume_id", req.Msg.Id),
                zap.Uint64("new_size", req.Msg.NewSizeBytes),
        )
        logger.Info("Resizing volume")

        vol, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Validate resize (can only expand, not shrink)
        <span class="cov0" title="0">if req.Msg.NewSizeBytes &lt;= vol.Spec.SizeBytes </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, 
                        fmt.Errorf("new size must be larger than current size (%d bytes)", vol.Spec.SizeBytes))
        }</span>

        // Update size
        <span class="cov0" title="0">vol.Spec.SizeBytes = req.Msg.NewSizeBytes
        vol.Status.ActualSizeBytes = req.Msg.NewSizeBytes
        vol.UpdatedAt = time.Now()

        updatedVol, err := s.repo.Update(ctx, vol)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to resize volume", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume resized successfully", zap.String("volume_id", updatedVol.ID))
        return connect.NewResponse(convertVolumeToProto(updatedVol)), nil</span>
}

// AttachVolume attaches a volume to a VM.
func (s *VolumeService) AttachVolume(
        ctx context.Context,
        req *connect.Request[storagev1.AttachVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "AttachVolume"),
                zap.String("volume_id", req.Msg.VolumeId),
                zap.String("vm_id", req.Msg.VmId),
        )
        logger.Info("Attaching volume to VM")

        vol, err := s.repo.Get(ctx, req.Msg.VolumeId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">if vol.IsAttached() </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeFailedPrecondition, 
                        fmt.Errorf("volume already attached to VM %s", vol.Status.AttachedVMID))
        }</span>

        // Update status
        <span class="cov0" title="0">vol.Status.AttachedVMID = req.Msg.VmId
        vol.Status.DevicePath = req.Msg.DevicePath
        if vol.Status.DevicePath == "" </span><span class="cov0" title="0">{
                vol.Status.DevicePath = "/dev/vdb" // Default device path
        }</span>
        <span class="cov0" title="0">vol.Status.Phase = domain.VolumePhaseInUse
        vol.UpdatedAt = time.Now()

        if err := s.repo.UpdateStatus(ctx, vol.ID, vol.Status); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update volume status", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume attached successfully", 
                zap.String("volume_id", vol.ID), 
                zap.String("vm_id", req.Msg.VmId))
        return connect.NewResponse(convertVolumeToProto(vol)), nil</span>
}

// DetachVolume detaches a volume from a VM.
func (s *VolumeService) DetachVolume(
        ctx context.Context,
        req *connect.Request[storagev1.DetachVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "DetachVolume"),
                zap.String("volume_id", req.Msg.VolumeId),
        )
        logger.Info("Detaching volume from VM")

        vol, err := s.repo.Get(ctx, req.Msg.VolumeId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">if !vol.IsAttached() </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("volume is not attached"))
        }</span>

        // Update status
        <span class="cov0" title="0">vol.Status.AttachedVMID = ""
        vol.Status.DevicePath = ""
        vol.Status.Phase = domain.VolumePhaseReady
        vol.UpdatedAt = time.Now()

        if err := s.repo.UpdateStatus(ctx, vol.ID, vol.Status); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update volume status", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume detached successfully", zap.String("volume_id", vol.ID))
        return connect.NewResponse(convertVolumeToProto(vol)), nil</span>
}

// CloneVolume creates a copy of a volume.
func (s *VolumeService) CloneVolume(
        ctx context.Context,
        req *connect.Request[storagev1.CloneVolumeRequest],
) (*connect.Response[storagev1.Volume], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "CloneVolume"),
                zap.String("source_volume_id", req.Msg.SourceVolumeId),
                zap.String("new_name", req.Msg.Name),
        )
        logger.Info("Cloning volume")

        // Get source volume
        sourceVol, err := s.repo.Get(ctx, req.Msg.SourceVolumeId)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Create clone
        <span class="cov0" title="0">clone := &amp;domain.Volume{
                Name:      req.Msg.Name,
                ProjectID: req.Msg.ProjectId,
                PoolID:    sourceVol.PoolID,
                Labels:    sourceVol.Labels,
                Spec:      sourceVol.Spec,
                Status: domain.VolumeStatus{
                        Phase:           domain.VolumePhaseReady,
                        ActualSizeBytes: sourceVol.Status.ActualSizeBytes,
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        clone.Spec.Source = domain.VolumeSource{
                Type:     "clone",
                VolumeID: req.Msg.SourceVolumeId,
        }

        if clone.ProjectID == "" </span><span class="cov0" title="0">{
                clone.ProjectID = sourceVol.ProjectID
        }</span>

        <span class="cov0" title="0">createdClone, err := s.repo.Create(ctx, clone)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create clone", zap.Error(err))
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">logger.Info("Volume cloned successfully", 
                zap.String("source_volume_id", req.Msg.SourceVolumeId),
                zap.String("clone_volume_id", createdClone.ID))
        return connect.NewResponse(convertVolumeToProto(createdClone)), nil</span>
}

// GetVolumeMetrics returns current volume metrics.
func (s *VolumeService) GetVolumeMetrics(
        ctx context.Context,
        req *connect.Request[storagev1.GetVolumeMetricsRequest],
) (*connect.Response[storagev1.VolumeMetrics], error) <span class="cov0" title="0">{
        logger := s.logger.With(
                zap.String("method", "GetVolumeMetrics"),
                zap.String("volume_id", req.Msg.Id),
        )
        logger.Debug("Getting volume metrics")

        vol, err := s.repo.Get(ctx, req.Msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                if err == domain.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">metrics := &amp;storagev1.VolumeMetrics{
                VolumeId:             vol.ID,
                ProvisionedBytes:     vol.Spec.SizeBytes,
                UsedBytes:            vol.Status.Usage.UsedBytes,
                ReadIops:             vol.Status.Usage.ReadIOPS,
                WriteIops:            vol.Status.Usage.WriteIOPS,
                ReadThroughputBytes:  vol.Status.Usage.ReadBytesPerSec,
                WriteThroughputBytes: vol.Status.Usage.WriteBytesPerSec,
                ReadLatencyUs:        vol.Status.Usage.ReadLatencyUs,
                WriteLatencyUs:       vol.Status.Usage.WriteLatencyUs,
        }

        return connect.NewResponse(metrics), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package streaming provides real-time event streaming for VMs and Nodes.
package streaming

import (
        "context"
        "sync"
        "time"

        "go.uber.org/zap"

        "github.com/Quantixkvm/Quantixkvm/internal/domain"
)

// Event represents a real-time event.
type Event struct {
        Type       EventType
        ResourceID string
        Resource   interface{}
        Timestamp  time.Time
}

// EventType represents the type of event.
type EventType string

const (
        EventTypeCreated EventType = "CREATED"
        EventTypeUpdated EventType = "UPDATED"
        EventTypeDeleted EventType = "DELETED"
        EventTypeStarted EventType = "STARTED"
        EventTypeStopped EventType = "STOPPED"
)

// Subscription represents a client subscription to events.
type Subscription struct {
        ID        string
        Filter    SubscriptionFilter
        Events    chan Event
        CreatedAt time.Time
        cancelFn  context.CancelFunc
}

// SubscriptionFilter filters which events a subscription receives.
type SubscriptionFilter struct {
        ResourceType string // "vm", "node", "alert", etc.
        ResourceID   string // Optional: specific resource
        EventTypes   []EventType
        ProjectID    string // For multi-tenant filtering
}

// Service manages real-time event streaming.
type Service struct {
        logger *zap.Logger

        mu            sync.RWMutex
        subscriptions map[string]*Subscription
        nextID        int64
}

// NewService creates a new streaming service.
func NewService(logger *zap.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                logger:        logger.With(zap.String("service", "streaming")),
                subscriptions: make(map[string]*Subscription),
        }
}</span>

// Subscribe creates a new subscription for events.
func (s *Service) Subscribe(ctx context.Context, filter SubscriptionFilter) (*Subscription, error) <span class="cov0" title="0">{
        s.mu.Lock()
        s.nextID++
        id := string(rune(s.nextID))
        subCtx, cancel := context.WithCancel(ctx)

        sub := &amp;Subscription{
                ID:        id,
                Filter:    filter,
                Events:    make(chan Event, 100),
                CreatedAt: time.Now(),
                cancelFn:  cancel,
        }

        s.subscriptions[id] = sub
        s.mu.Unlock()

        s.logger.Info("Client subscribed",
                zap.String("subscription_id", id),
                zap.String("resource_type", filter.ResourceType),
                zap.String("resource_id", filter.ResourceID),
        )

        // Start cleanup goroutine
        go func() </span><span class="cov0" title="0">{
                &lt;-subCtx.Done()
                s.Unsubscribe(id)
        }</span>()

        <span class="cov0" title="0">return sub, nil</span>
}

// Unsubscribe removes a subscription.
func (s *Service) Unsubscribe(id string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if sub, exists := s.subscriptions[id]; exists </span><span class="cov0" title="0">{
                close(sub.Events)
                sub.cancelFn()
                delete(s.subscriptions, id)
                s.logger.Info("Client unsubscribed", zap.String("subscription_id", id))
        }</span>
}

// Publish sends an event to all matching subscriptions.
func (s *Service) Publish(event Event) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        event.Timestamp = time.Now()

        for _, sub := range s.subscriptions </span><span class="cov0" title="0">{
                if s.matchesFilter(event, sub.Filter) </span><span class="cov0" title="0">{
                        select </span>{
                        case sub.Events &lt;- event:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                // Channel full, skip (don't block publishers)
                                s.logger.Warn("Subscription channel full, dropping event",
                                        zap.String("subscription_id", sub.ID),
                                )</span>
                        }
                }
        }
}

// matchesFilter checks if an event matches a subscription filter.
func (s *Service) matchesFilter(event Event, filter SubscriptionFilter) bool <span class="cov0" title="0">{
        // Check resource type
        if filter.ResourceType != "" </span><span class="cov0" title="0">{
                resourceType := s.getResourceType(event.Resource)
                if resourceType != filter.ResourceType </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check specific resource ID
        <span class="cov0" title="0">if filter.ResourceID != "" &amp;&amp; event.ResourceID != filter.ResourceID </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check event types
        <span class="cov0" title="0">if len(filter.EventTypes) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, et := range filter.EventTypes </span><span class="cov0" title="0">{
                        if et == event.Type </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check project ID for VMs
        <span class="cov0" title="0">if filter.ProjectID != "" </span><span class="cov0" title="0">{
                if vm, ok := event.Resource.(*domain.VirtualMachine); ok </span><span class="cov0" title="0">{
                        if vm.ProjectID != filter.ProjectID </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return true</span>
}

// getResourceType returns the type of a resource.
func (s *Service) getResourceType(resource interface{}) string <span class="cov0" title="0">{
        switch resource.(type) </span>{
        case *domain.VirtualMachine:<span class="cov0" title="0">
                return "vm"</span>
        case *domain.Node:<span class="cov0" title="0">
                return "node"</span>
        case *domain.Alert:<span class="cov0" title="0">
                return "alert"</span>
        case *domain.DRSRecommendation:<span class="cov0" title="0">
                return "drs"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// PublishVMEvent publishes a VM-related event.
func (s *Service) PublishVMEvent(eventType EventType, vm *domain.VirtualMachine) <span class="cov0" title="0">{
        s.Publish(Event{
                Type:       eventType,
                ResourceID: vm.ID,
                Resource:   vm,
        })
}</span>

// PublishNodeEvent publishes a node-related event.
func (s *Service) PublishNodeEvent(eventType EventType, node *domain.Node) <span class="cov0" title="0">{
        s.Publish(Event{
                Type:       eventType,
                ResourceID: node.ID,
                Resource:   node,
        })
}</span>

// PublishAlertEvent publishes an alert-related event.
func (s *Service) PublishAlertEvent(eventType EventType, alert *domain.Alert) <span class="cov0" title="0">{
        s.Publish(Event{
                Type:       eventType,
                ResourceID: alert.ID,
                Resource:   alert,
        })
}</span>

// GetSubscriptionCount returns the number of active subscriptions.
func (s *Service) GetSubscriptionCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.subscriptions)
}</span>

// =============================================================================
// VM Watcher - Implements streaming for WatchVM RPC
// =============================================================================

// VMWatcher provides streaming updates for VMs.
type VMWatcher struct {
        streaming *Service
        vmRepo    VMRepository
        logger    *zap.Logger
}

// VMRepository defines the interface for VM data access.
type VMRepository interface {
        Get(ctx context.Context, id string) (*domain.VirtualMachine, error)
}

// NewVMWatcher creates a new VM watcher.
func NewVMWatcher(streaming *Service, vmRepo VMRepository, logger *zap.Logger) *VMWatcher <span class="cov0" title="0">{
        return &amp;VMWatcher{
                streaming: streaming,
                vmRepo:    vmRepo,
                logger:    logger,
        }
}</span>

// WatchVM streams updates for a specific VM.
func (w *VMWatcher) WatchVM(ctx context.Context, vmID string) (&lt;-chan *domain.VirtualMachine, error) <span class="cov0" title="0">{
        // Get initial state
        vm, err := w.vmRepo.Get(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Subscribe to events
        <span class="cov0" title="0">sub, err := w.streaming.Subscribe(ctx, SubscriptionFilter{
                ResourceType: "vm",
                ResourceID:   vmID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create output channel
        <span class="cov0" title="0">vmChan := make(chan *domain.VirtualMachine, 10)

        // Send initial state
        vmChan &lt;- vm

        // Forward events
        go func() </span><span class="cov0" title="0">{
                defer close(vmChan)

                for event := range sub.Events </span><span class="cov0" title="0">{
                        if vm, ok := event.Resource.(*domain.VirtualMachine); ok </span><span class="cov0" title="0">{
                                select </span>{
                                case vmChan &lt;- vm:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return vmChan, nil</span>
}

// WatchVMs streams updates for all VMs matching a filter.
func (w *VMWatcher) WatchVMs(ctx context.Context, projectID string) (&lt;-chan *domain.VirtualMachine, error) <span class="cov0" title="0">{
        // Subscribe to events
        sub, err := w.streaming.Subscribe(ctx, SubscriptionFilter{
                ResourceType: "vm",
                ProjectID:    projectID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create output channel
        <span class="cov0" title="0">vmChan := make(chan *domain.VirtualMachine, 100)

        // Forward events
        go func() </span><span class="cov0" title="0">{
                defer close(vmChan)

                for event := range sub.Events </span><span class="cov0" title="0">{
                        if vm, ok := event.Resource.(*domain.VirtualMachine); ok </span><span class="cov0" title="0">{
                                select </span>{
                                case vmChan &lt;- vm:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return vmChan, nil</span>
}

// =============================================================================
// Node Watcher - Implements streaming for WatchNode RPC
// =============================================================================

// NodeWatcher provides streaming updates for nodes.
type NodeWatcher struct {
        streaming *Service
        nodeRepo  NodeRepository
        logger    *zap.Logger
}

// NodeRepository defines the interface for node data access.
type NodeRepository interface {
        Get(ctx context.Context, id string) (*domain.Node, error)
}

// NewNodeWatcher creates a new node watcher.
func NewNodeWatcher(streaming *Service, nodeRepo NodeRepository, logger *zap.Logger) *NodeWatcher <span class="cov0" title="0">{
        return &amp;NodeWatcher{
                streaming: streaming,
                nodeRepo:  nodeRepo,
                logger:    logger,
        }
}</span>

// WatchNode streams updates for a specific node.
func (w *NodeWatcher) WatchNode(ctx context.Context, nodeID string) (&lt;-chan *domain.Node, error) <span class="cov0" title="0">{
        // Get initial state
        node, err := w.nodeRepo.Get(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Subscribe to events
        <span class="cov0" title="0">sub, err := w.streaming.Subscribe(ctx, SubscriptionFilter{
                ResourceType: "node",
                ResourceID:   nodeID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create output channel
        <span class="cov0" title="0">nodeChan := make(chan *domain.Node, 10)

        // Send initial state
        nodeChan &lt;- node

        // Forward events
        go func() </span><span class="cov0" title="0">{
                defer close(nodeChan)

                for event := range sub.Events </span><span class="cov0" title="0">{
                        if node, ok := event.Resource.(*domain.Node); ok </span><span class="cov0" title="0">{
                                select </span>{
                                case nodeChan &lt;- node:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return nodeChan, nil</span>
}

// WatchNodes streams updates for all nodes.
func (w *NodeWatcher) WatchNodes(ctx context.Context) (&lt;-chan *domain.Node, error) <span class="cov0" title="0">{
        // Subscribe to events
        sub, err := w.streaming.Subscribe(ctx, SubscriptionFilter{
                ResourceType: "node",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create output channel
        <span class="cov0" title="0">nodeChan := make(chan *domain.Node, 100)

        // Forward events
        go func() </span><span class="cov0" title="0">{
                defer close(nodeChan)

                for event := range sub.Events </span><span class="cov0" title="0">{
                        if node, ok := event.Resource.(*domain.Node); ok </span><span class="cov0" title="0">{
                                select </span>{
                                case nodeChan &lt;- node:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return nodeChan, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
