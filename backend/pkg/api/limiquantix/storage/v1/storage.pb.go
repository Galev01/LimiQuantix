// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: limiquantix/storage/v1/storage.proto

package storagev1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Backend type
type StorageBackend_BackendType int32

const (
	StorageBackend_CEPH_RBD    StorageBackend_BackendType = 0 // Ceph RADOS Block Device
	StorageBackend_CEPH_CEPHFS StorageBackend_BackendType = 1 // Ceph Filesystem
	StorageBackend_LOCAL_LVM   StorageBackend_BackendType = 2 // Local LVM volume group
	StorageBackend_LOCAL_DIR   StorageBackend_BackendType = 3 // Local directory (for dev/test)
	StorageBackend_NFS         StorageBackend_BackendType = 4 // NFS share
	StorageBackend_ISCSI       StorageBackend_BackendType = 5 // iSCSI target
)

// Enum value maps for StorageBackend_BackendType.
var (
	StorageBackend_BackendType_name = map[int32]string{
		0: "CEPH_RBD",
		1: "CEPH_CEPHFS",
		2: "LOCAL_LVM",
		3: "LOCAL_DIR",
		4: "NFS",
		5: "ISCSI",
	}
	StorageBackend_BackendType_value = map[string]int32{
		"CEPH_RBD":    0,
		"CEPH_CEPHFS": 1,
		"LOCAL_LVM":   2,
		"LOCAL_DIR":   3,
		"NFS":         4,
		"ISCSI":       5,
	}
)

func (x StorageBackend_BackendType) Enum() *StorageBackend_BackendType {
	p := new(StorageBackend_BackendType)
	*p = x
	return p
}

func (x StorageBackend_BackendType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageBackend_BackendType) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[0].Descriptor()
}

func (StorageBackend_BackendType) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[0]
}

func (x StorageBackend_BackendType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageBackend_BackendType.Descriptor instead.
func (StorageBackend_BackendType) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{2, 0}
}

// Default provisioning type
type VolumeDefaults_ProvisioningType int32

const (
	VolumeDefaults_THIN  VolumeDefaults_ProvisioningType = 0 // Allocate on demand
	VolumeDefaults_THICK VolumeDefaults_ProvisioningType = 1 // Pre-allocate space
)

// Enum value maps for VolumeDefaults_ProvisioningType.
var (
	VolumeDefaults_ProvisioningType_name = map[int32]string{
		0: "THIN",
		1: "THICK",
	}
	VolumeDefaults_ProvisioningType_value = map[string]int32{
		"THIN":  0,
		"THICK": 1,
	}
)

func (x VolumeDefaults_ProvisioningType) Enum() *VolumeDefaults_ProvisioningType {
	p := new(VolumeDefaults_ProvisioningType)
	*p = x
	return p
}

func (x VolumeDefaults_ProvisioningType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeDefaults_ProvisioningType) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[1].Descriptor()
}

func (VolumeDefaults_ProvisioningType) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[1]
}

func (x VolumeDefaults_ProvisioningType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeDefaults_ProvisioningType.Descriptor instead.
func (VolumeDefaults_ProvisioningType) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{8, 0}
}

// Key management
type EncryptionConfig_KeyManagement int32

const (
	EncryptionConfig_INTERNAL     EncryptionConfig_KeyManagement = 0 // limiquantix managed keys
	EncryptionConfig_EXTERNAL_KMS EncryptionConfig_KeyManagement = 1 // External Key Management Service
)

// Enum value maps for EncryptionConfig_KeyManagement.
var (
	EncryptionConfig_KeyManagement_name = map[int32]string{
		0: "INTERNAL",
		1: "EXTERNAL_KMS",
	}
	EncryptionConfig_KeyManagement_value = map[string]int32{
		"INTERNAL":     0,
		"EXTERNAL_KMS": 1,
	}
)

func (x EncryptionConfig_KeyManagement) Enum() *EncryptionConfig_KeyManagement {
	p := new(EncryptionConfig_KeyManagement)
	*p = x
	return p
}

func (x EncryptionConfig_KeyManagement) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionConfig_KeyManagement) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[2].Descriptor()
}

func (EncryptionConfig_KeyManagement) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[2]
}

func (x EncryptionConfig_KeyManagement) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionConfig_KeyManagement.Descriptor instead.
func (EncryptionConfig_KeyManagement) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{10, 0}
}

// Policy for moving data between tiers
type TieringConfig_TieringPolicy int32

const (
	TieringConfig_LRU       TieringConfig_TieringPolicy = 0 // Least Recently Used
	TieringConfig_WRITEBACK TieringConfig_TieringPolicy = 1 // Write to hot, migrate to cold
)

// Enum value maps for TieringConfig_TieringPolicy.
var (
	TieringConfig_TieringPolicy_name = map[int32]string{
		0: "LRU",
		1: "WRITEBACK",
	}
	TieringConfig_TieringPolicy_value = map[string]int32{
		"LRU":       0,
		"WRITEBACK": 1,
	}
)

func (x TieringConfig_TieringPolicy) Enum() *TieringConfig_TieringPolicy {
	p := new(TieringConfig_TieringPolicy)
	*p = x
	return p
}

func (x TieringConfig_TieringPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TieringConfig_TieringPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[3].Descriptor()
}

func (TieringConfig_TieringPolicy) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[3]
}

func (x TieringConfig_TieringPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TieringConfig_TieringPolicy.Descriptor instead.
func (TieringConfig_TieringPolicy) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{13, 0}
}

// Current phase
type StoragePoolStatus_Phase int32

const (
	StoragePoolStatus_UNKNOWN  StoragePoolStatus_Phase = 0
	StoragePoolStatus_PENDING  StoragePoolStatus_Phase = 1 // Pool is being created
	StoragePoolStatus_READY    StoragePoolStatus_Phase = 2 // Pool is healthy
	StoragePoolStatus_DEGRADED StoragePoolStatus_Phase = 3 // Pool is working but not optimal
	StoragePoolStatus_ERROR    StoragePoolStatus_Phase = 4 // Pool has errors
	StoragePoolStatus_DELETING StoragePoolStatus_Phase = 5 // Pool is being deleted
)

// Enum value maps for StoragePoolStatus_Phase.
var (
	StoragePoolStatus_Phase_name = map[int32]string{
		0: "UNKNOWN",
		1: "PENDING",
		2: "READY",
		3: "DEGRADED",
		4: "ERROR",
		5: "DELETING",
	}
	StoragePoolStatus_Phase_value = map[string]int32{
		"UNKNOWN":  0,
		"PENDING":  1,
		"READY":    2,
		"DEGRADED": 3,
		"ERROR":    4,
		"DELETING": 5,
	}
)

func (x StoragePoolStatus_Phase) Enum() *StoragePoolStatus_Phase {
	p := new(StoragePoolStatus_Phase)
	*p = x
	return p
}

func (x StoragePoolStatus_Phase) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StoragePoolStatus_Phase) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[4].Descriptor()
}

func (StoragePoolStatus_Phase) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[4]
}

func (x StoragePoolStatus_Phase) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StoragePoolStatus_Phase.Descriptor instead.
func (StoragePoolStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{14, 0}
}

type StorageHealth_Status int32

const (
	StorageHealth_UNKNOWN StorageHealth_Status = 0
	StorageHealth_HEALTHY StorageHealth_Status = 1
	StorageHealth_WARNING StorageHealth_Status = 2
	StorageHealth_ERROR   StorageHealth_Status = 3
)

// Enum value maps for StorageHealth_Status.
var (
	StorageHealth_Status_name = map[int32]string{
		0: "UNKNOWN",
		1: "HEALTHY",
		2: "WARNING",
		3: "ERROR",
	}
	StorageHealth_Status_value = map[string]int32{
		"UNKNOWN": 0,
		"HEALTHY": 1,
		"WARNING": 2,
		"ERROR":   3,
	}
)

func (x StorageHealth_Status) Enum() *StorageHealth_Status {
	p := new(StorageHealth_Status)
	*p = x
	return p
}

func (x StorageHealth_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageHealth_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[5].Descriptor()
}

func (StorageHealth_Status) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[5]
}

func (x StorageHealth_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageHealth_Status.Descriptor instead.
func (StorageHealth_Status) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{17, 0}
}

// Provisioning type
type VolumeSpec_ProvisioningType int32

const (
	VolumeSpec_THIN        VolumeSpec_ProvisioningType = 0
	VolumeSpec_THICK_LAZY  VolumeSpec_ProvisioningType = 1
	VolumeSpec_THICK_EAGER VolumeSpec_ProvisioningType = 2
)

// Enum value maps for VolumeSpec_ProvisioningType.
var (
	VolumeSpec_ProvisioningType_name = map[int32]string{
		0: "THIN",
		1: "THICK_LAZY",
		2: "THICK_EAGER",
	}
	VolumeSpec_ProvisioningType_value = map[string]int32{
		"THIN":        0,
		"THICK_LAZY":  1,
		"THICK_EAGER": 2,
	}
)

func (x VolumeSpec_ProvisioningType) Enum() *VolumeSpec_ProvisioningType {
	p := new(VolumeSpec_ProvisioningType)
	*p = x
	return p
}

func (x VolumeSpec_ProvisioningType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeSpec_ProvisioningType) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[6].Descriptor()
}

func (VolumeSpec_ProvisioningType) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[6]
}

func (x VolumeSpec_ProvisioningType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeSpec_ProvisioningType.Descriptor instead.
func (VolumeSpec_ProvisioningType) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{20, 0}
}

// Access mode
type VolumeSpec_AccessMode int32

const (
	VolumeSpec_READ_WRITE_ONCE VolumeSpec_AccessMode = 0 // Single VM read-write
	VolumeSpec_READ_ONLY_MANY  VolumeSpec_AccessMode = 1 // Multiple VMs read-only
	VolumeSpec_READ_WRITE_MANY VolumeSpec_AccessMode = 2 // Multiple VMs read-write (requires cluster FS)
)

// Enum value maps for VolumeSpec_AccessMode.
var (
	VolumeSpec_AccessMode_name = map[int32]string{
		0: "READ_WRITE_ONCE",
		1: "READ_ONLY_MANY",
		2: "READ_WRITE_MANY",
	}
	VolumeSpec_AccessMode_value = map[string]int32{
		"READ_WRITE_ONCE": 0,
		"READ_ONLY_MANY":  1,
		"READ_WRITE_MANY": 2,
	}
)

func (x VolumeSpec_AccessMode) Enum() *VolumeSpec_AccessMode {
	p := new(VolumeSpec_AccessMode)
	*p = x
	return p
}

func (x VolumeSpec_AccessMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeSpec_AccessMode) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[7].Descriptor()
}

func (VolumeSpec_AccessMode) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[7]
}

func (x VolumeSpec_AccessMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeSpec_AccessMode.Descriptor instead.
func (VolumeSpec_AccessMode) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{20, 1}
}

// Current phase
type VolumeStatus_Phase int32

const (
	VolumeStatus_UNKNOWN  VolumeStatus_Phase = 0
	VolumeStatus_PENDING  VolumeStatus_Phase = 1 // Volume is being created
	VolumeStatus_CREATING VolumeStatus_Phase = 2 // Volume creation in progress
	VolumeStatus_READY    VolumeStatus_Phase = 3 // Volume is available
	VolumeStatus_IN_USE   VolumeStatus_Phase = 4 // Volume is attached to a VM
	VolumeStatus_DELETING VolumeStatus_Phase = 5 // Volume is being deleted
	VolumeStatus_ERROR    VolumeStatus_Phase = 6 // Volume has errors
	VolumeStatus_RESIZING VolumeStatus_Phase = 7 // Volume is being resized
)

// Enum value maps for VolumeStatus_Phase.
var (
	VolumeStatus_Phase_name = map[int32]string{
		0: "UNKNOWN",
		1: "PENDING",
		2: "CREATING",
		3: "READY",
		4: "IN_USE",
		5: "DELETING",
		6: "ERROR",
		7: "RESIZING",
	}
	VolumeStatus_Phase_value = map[string]int32{
		"UNKNOWN":  0,
		"PENDING":  1,
		"CREATING": 2,
		"READY":    3,
		"IN_USE":   4,
		"DELETING": 5,
		"ERROR":    6,
		"RESIZING": 7,
	}
)

func (x VolumeStatus_Phase) Enum() *VolumeStatus_Phase {
	p := new(VolumeStatus_Phase)
	*p = x
	return p
}

func (x VolumeStatus_Phase) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeStatus_Phase) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[8].Descriptor()
}

func (VolumeStatus_Phase) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[8]
}

func (x VolumeStatus_Phase) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeStatus_Phase.Descriptor instead.
func (VolumeStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{28, 0}
}

type VolumeSnapshotStatus_Phase int32

const (
	VolumeSnapshotStatus_UNKNOWN  VolumeSnapshotStatus_Phase = 0
	VolumeSnapshotStatus_PENDING  VolumeSnapshotStatus_Phase = 1
	VolumeSnapshotStatus_CREATING VolumeSnapshotStatus_Phase = 2
	VolumeSnapshotStatus_READY    VolumeSnapshotStatus_Phase = 3
	VolumeSnapshotStatus_DELETING VolumeSnapshotStatus_Phase = 4
	VolumeSnapshotStatus_ERROR    VolumeSnapshotStatus_Phase = 5
)

// Enum value maps for VolumeSnapshotStatus_Phase.
var (
	VolumeSnapshotStatus_Phase_name = map[int32]string{
		0: "UNKNOWN",
		1: "PENDING",
		2: "CREATING",
		3: "READY",
		4: "DELETING",
		5: "ERROR",
	}
	VolumeSnapshotStatus_Phase_value = map[string]int32{
		"UNKNOWN":  0,
		"PENDING":  1,
		"CREATING": 2,
		"READY":    3,
		"DELETING": 4,
		"ERROR":    5,
	}
)

func (x VolumeSnapshotStatus_Phase) Enum() *VolumeSnapshotStatus_Phase {
	p := new(VolumeSnapshotStatus_Phase)
	*p = x
	return p
}

func (x VolumeSnapshotStatus_Phase) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeSnapshotStatus_Phase) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[9].Descriptor()
}

func (VolumeSnapshotStatus_Phase) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[9]
}

func (x VolumeSnapshotStatus_Phase) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeSnapshotStatus_Phase.Descriptor instead.
func (VolumeSnapshotStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{33, 0}
}

// Image format
type ImageSpec_Format int32

const (
	ImageSpec_RAW   ImageSpec_Format = 0
	ImageSpec_QCOW2 ImageSpec_Format = 1
	ImageSpec_VMDK  ImageSpec_Format = 2
	ImageSpec_VHD   ImageSpec_Format = 3
	ImageSpec_ISO   ImageSpec_Format = 4
)

// Enum value maps for ImageSpec_Format.
var (
	ImageSpec_Format_name = map[int32]string{
		0: "RAW",
		1: "QCOW2",
		2: "VMDK",
		3: "VHD",
		4: "ISO",
	}
	ImageSpec_Format_value = map[string]int32{
		"RAW":   0,
		"QCOW2": 1,
		"VMDK":  2,
		"VHD":   3,
		"ISO":   4,
	}
)

func (x ImageSpec_Format) Enum() *ImageSpec_Format {
	p := new(ImageSpec_Format)
	*p = x
	return p
}

func (x ImageSpec_Format) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageSpec_Format) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[10].Descriptor()
}

func (ImageSpec_Format) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[10]
}

func (x ImageSpec_Format) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageSpec_Format.Descriptor instead.
func (ImageSpec_Format) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{35, 0}
}

// Visibility
type ImageSpec_Visibility int32

const (
	ImageSpec_PRIVATE ImageSpec_Visibility = 0 // Only owner can use
	ImageSpec_PROJECT ImageSpec_Visibility = 1 // Project members can use
	ImageSpec_PUBLIC  ImageSpec_Visibility = 2 // Anyone can use
)

// Enum value maps for ImageSpec_Visibility.
var (
	ImageSpec_Visibility_name = map[int32]string{
		0: "PRIVATE",
		1: "PROJECT",
		2: "PUBLIC",
	}
	ImageSpec_Visibility_value = map[string]int32{
		"PRIVATE": 0,
		"PROJECT": 1,
		"PUBLIC":  2,
	}
)

func (x ImageSpec_Visibility) Enum() *ImageSpec_Visibility {
	p := new(ImageSpec_Visibility)
	*p = x
	return p
}

func (x ImageSpec_Visibility) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageSpec_Visibility) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[11].Descriptor()
}

func (ImageSpec_Visibility) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[11]
}

func (x ImageSpec_Visibility) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageSpec_Visibility.Descriptor instead.
func (ImageSpec_Visibility) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{35, 1}
}

// OS family
type OsInfo_OsFamily int32

const (
	OsInfo_UNKNOWN OsInfo_OsFamily = 0
	OsInfo_LINUX   OsInfo_OsFamily = 1
	OsInfo_WINDOWS OsInfo_OsFamily = 2
	OsInfo_BSD     OsInfo_OsFamily = 3
	OsInfo_OTHER   OsInfo_OsFamily = 4
)

// Enum value maps for OsInfo_OsFamily.
var (
	OsInfo_OsFamily_name = map[int32]string{
		0: "UNKNOWN",
		1: "LINUX",
		2: "WINDOWS",
		3: "BSD",
		4: "OTHER",
	}
	OsInfo_OsFamily_value = map[string]int32{
		"UNKNOWN": 0,
		"LINUX":   1,
		"WINDOWS": 2,
		"BSD":     3,
		"OTHER":   4,
	}
)

func (x OsInfo_OsFamily) Enum() *OsInfo_OsFamily {
	p := new(OsInfo_OsFamily)
	*p = x
	return p
}

func (x OsInfo_OsFamily) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OsInfo_OsFamily) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[12].Descriptor()
}

func (OsInfo_OsFamily) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[12]
}

func (x OsInfo_OsFamily) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OsInfo_OsFamily.Descriptor instead.
func (OsInfo_OsFamily) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{37, 0}
}

type ImageStatus_Phase int32

const (
	ImageStatus_UNKNOWN     ImageStatus_Phase = 0
	ImageStatus_PENDING     ImageStatus_Phase = 1
	ImageStatus_DOWNLOADING ImageStatus_Phase = 2
	ImageStatus_CONVERTING  ImageStatus_Phase = 3
	ImageStatus_READY       ImageStatus_Phase = 4
	ImageStatus_ERROR       ImageStatus_Phase = 5
	ImageStatus_DELETING    ImageStatus_Phase = 6
)

// Enum value maps for ImageStatus_Phase.
var (
	ImageStatus_Phase_name = map[int32]string{
		0: "UNKNOWN",
		1: "PENDING",
		2: "DOWNLOADING",
		3: "CONVERTING",
		4: "READY",
		5: "ERROR",
		6: "DELETING",
	}
	ImageStatus_Phase_value = map[string]int32{
		"UNKNOWN":     0,
		"PENDING":     1,
		"DOWNLOADING": 2,
		"CONVERTING":  3,
		"READY":       4,
		"ERROR":       5,
		"DELETING":    6,
	}
)

func (x ImageStatus_Phase) Enum() *ImageStatus_Phase {
	p := new(ImageStatus_Phase)
	*p = x
	return p
}

func (x ImageStatus_Phase) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageStatus_Phase) Descriptor() protoreflect.EnumDescriptor {
	return file_limiquantix_storage_v1_storage_proto_enumTypes[13].Descriptor()
}

func (ImageStatus_Phase) Type() protoreflect.EnumType {
	return &file_limiquantix_storage_v1_storage_proto_enumTypes[13]
}

func (x ImageStatus_Phase) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageStatus_Phase.Descriptor instead.
func (ImageStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{39, 0}
}

// StoragePool represents a logical pool of storage resources.
// This abstracts Ceph pools, local LVM volume groups, or NFS shares.
type StoragePool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Immutable unique identifier (UUIDv4)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// User-friendly name (e.g., "fast-nvme", "archive-hdd")
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Project isolation (empty = cluster-wide)
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Description
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Labels for organization
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Pool specification
	Spec *StoragePoolSpec `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec,omitempty"`
	// Current status
	Status *StoragePoolStatus `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// Audit trail
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoragePool) Reset() {
	*x = StoragePool{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoragePool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoragePool) ProtoMessage() {}

func (x *StoragePool) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoragePool.ProtoReflect.Descriptor instead.
func (*StoragePool) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{0}
}

func (x *StoragePool) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *StoragePool) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StoragePool) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *StoragePool) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *StoragePool) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *StoragePool) GetSpec() *StoragePoolSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *StoragePool) GetStatus() *StoragePoolStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *StoragePool) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *StoragePool) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type StoragePoolSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of storage backend
	Backend *StorageBackend `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	// Default settings for volumes in this pool
	Defaults *VolumeDefaults `protobuf:"bytes,2,opt,name=defaults,proto3" json:"defaults,omitempty"`
	// Quality of Service settings
	Qos *StorageQos `protobuf:"bytes,3,opt,name=qos,proto3" json:"qos,omitempty"`
	// Encryption settings
	Encryption *EncryptionConfig `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// Replication settings (for distributed storage)
	Replication *ReplicationConfig `protobuf:"bytes,5,opt,name=replication,proto3" json:"replication,omitempty"`
	// Tiering configuration
	Tiering       *TieringConfig `protobuf:"bytes,6,opt,name=tiering,proto3" json:"tiering,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoragePoolSpec) Reset() {
	*x = StoragePoolSpec{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoragePoolSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoragePoolSpec) ProtoMessage() {}

func (x *StoragePoolSpec) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoragePoolSpec.ProtoReflect.Descriptor instead.
func (*StoragePoolSpec) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{1}
}

func (x *StoragePoolSpec) GetBackend() *StorageBackend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *StoragePoolSpec) GetDefaults() *VolumeDefaults {
	if x != nil {
		return x.Defaults
	}
	return nil
}

func (x *StoragePoolSpec) GetQos() *StorageQos {
	if x != nil {
		return x.Qos
	}
	return nil
}

func (x *StoragePoolSpec) GetEncryption() *EncryptionConfig {
	if x != nil {
		return x.Encryption
	}
	return nil
}

func (x *StoragePoolSpec) GetReplication() *ReplicationConfig {
	if x != nil {
		return x.Replication
	}
	return nil
}

func (x *StoragePoolSpec) GetTiering() *TieringConfig {
	if x != nil {
		return x.Tiering
	}
	return nil
}

type StorageBackend struct {
	state protoimpl.MessageState     `protogen:"open.v1"`
	Type  StorageBackend_BackendType `protobuf:"varint,1,opt,name=type,proto3,enum=limiquantix.storage.v1.StorageBackend_BackendType" json:"type,omitempty"`
	// Backend-specific configuration
	//
	// Types that are valid to be assigned to Config:
	//
	//	*StorageBackend_Ceph
	//	*StorageBackend_LocalLvm
	//	*StorageBackend_LocalDir
	//	*StorageBackend_Nfs
	//	*StorageBackend_Iscsi
	Config        isStorageBackend_Config `protobuf_oneof:"config"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageBackend) Reset() {
	*x = StorageBackend{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageBackend) ProtoMessage() {}

func (x *StorageBackend) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageBackend.ProtoReflect.Descriptor instead.
func (*StorageBackend) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{2}
}

func (x *StorageBackend) GetType() StorageBackend_BackendType {
	if x != nil {
		return x.Type
	}
	return StorageBackend_CEPH_RBD
}

func (x *StorageBackend) GetConfig() isStorageBackend_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *StorageBackend) GetCeph() *CephConfig {
	if x != nil {
		if x, ok := x.Config.(*StorageBackend_Ceph); ok {
			return x.Ceph
		}
	}
	return nil
}

func (x *StorageBackend) GetLocalLvm() *LocalLvmConfig {
	if x != nil {
		if x, ok := x.Config.(*StorageBackend_LocalLvm); ok {
			return x.LocalLvm
		}
	}
	return nil
}

func (x *StorageBackend) GetLocalDir() *LocalDirConfig {
	if x != nil {
		if x, ok := x.Config.(*StorageBackend_LocalDir); ok {
			return x.LocalDir
		}
	}
	return nil
}

func (x *StorageBackend) GetNfs() *NfsConfig {
	if x != nil {
		if x, ok := x.Config.(*StorageBackend_Nfs); ok {
			return x.Nfs
		}
	}
	return nil
}

func (x *StorageBackend) GetIscsi() *IscsiConfig {
	if x != nil {
		if x, ok := x.Config.(*StorageBackend_Iscsi); ok {
			return x.Iscsi
		}
	}
	return nil
}

type isStorageBackend_Config interface {
	isStorageBackend_Config()
}

type StorageBackend_Ceph struct {
	Ceph *CephConfig `protobuf:"bytes,2,opt,name=ceph,proto3,oneof"`
}

type StorageBackend_LocalLvm struct {
	LocalLvm *LocalLvmConfig `protobuf:"bytes,3,opt,name=local_lvm,json=localLvm,proto3,oneof"`
}

type StorageBackend_LocalDir struct {
	LocalDir *LocalDirConfig `protobuf:"bytes,4,opt,name=local_dir,json=localDir,proto3,oneof"`
}

type StorageBackend_Nfs struct {
	Nfs *NfsConfig `protobuf:"bytes,5,opt,name=nfs,proto3,oneof"`
}

type StorageBackend_Iscsi struct {
	Iscsi *IscsiConfig `protobuf:"bytes,6,opt,name=iscsi,proto3,oneof"`
}

func (*StorageBackend_Ceph) isStorageBackend_Config() {}

func (*StorageBackend_LocalLvm) isStorageBackend_Config() {}

func (*StorageBackend_LocalDir) isStorageBackend_Config() {}

func (*StorageBackend_Nfs) isStorageBackend_Config() {}

func (*StorageBackend_Iscsi) isStorageBackend_Config() {}

type CephConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ceph cluster ID
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Ceph pool name
	PoolName string `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
	// Monitor addresses
	Monitors []string `protobuf:"bytes,3,rep,name=monitors,proto3" json:"monitors,omitempty"`
	// Authentication
	User        string `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
	KeyringPath string `protobuf:"bytes,5,opt,name=keyring_path,json=keyringPath,proto3" json:"keyring_path,omitempty"`
	// Namespace within the pool (for multi-tenancy)
	Namespace     string `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CephConfig) Reset() {
	*x = CephConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CephConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CephConfig) ProtoMessage() {}

func (x *CephConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CephConfig.ProtoReflect.Descriptor instead.
func (*CephConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{3}
}

func (x *CephConfig) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *CephConfig) GetPoolName() string {
	if x != nil {
		return x.PoolName
	}
	return ""
}

func (x *CephConfig) GetMonitors() []string {
	if x != nil {
		return x.Monitors
	}
	return nil
}

func (x *CephConfig) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *CephConfig) GetKeyringPath() string {
	if x != nil {
		return x.KeyringPath
	}
	return ""
}

func (x *CephConfig) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

type LocalLvmConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Volume group name
	VolumeGroup string `protobuf:"bytes,1,opt,name=volume_group,json=volumeGroup,proto3" json:"volume_group,omitempty"`
	// Thin pool name (optional, for thin provisioning)
	ThinPool string `protobuf:"bytes,2,opt,name=thin_pool,json=thinPool,proto3" json:"thin_pool,omitempty"`
	// Node ID where this storage exists
	NodeId        string `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LocalLvmConfig) Reset() {
	*x = LocalLvmConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LocalLvmConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalLvmConfig) ProtoMessage() {}

func (x *LocalLvmConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalLvmConfig.ProtoReflect.Descriptor instead.
func (*LocalLvmConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{4}
}

func (x *LocalLvmConfig) GetVolumeGroup() string {
	if x != nil {
		return x.VolumeGroup
	}
	return ""
}

func (x *LocalLvmConfig) GetThinPool() string {
	if x != nil {
		return x.ThinPool
	}
	return ""
}

func (x *LocalLvmConfig) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type LocalDirConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Directory path
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Node ID where this storage exists
	NodeId        string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LocalDirConfig) Reset() {
	*x = LocalDirConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LocalDirConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalDirConfig) ProtoMessage() {}

func (x *LocalDirConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalDirConfig.ProtoReflect.Descriptor instead.
func (*LocalDirConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{5}
}

func (x *LocalDirConfig) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *LocalDirConfig) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type NfsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NFS server address
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Export path
	ExportPath string `protobuf:"bytes,2,opt,name=export_path,json=exportPath,proto3" json:"export_path,omitempty"`
	// NFS version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"` // "3", "4", "4.1", "4.2"
	// Mount options
	Options       string `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NfsConfig) Reset() {
	*x = NfsConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NfsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NfsConfig) ProtoMessage() {}

func (x *NfsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NfsConfig.ProtoReflect.Descriptor instead.
func (*NfsConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{6}
}

func (x *NfsConfig) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *NfsConfig) GetExportPath() string {
	if x != nil {
		return x.ExportPath
	}
	return ""
}

func (x *NfsConfig) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *NfsConfig) GetOptions() string {
	if x != nil {
		return x.Options
	}
	return ""
}

type IscsiConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// iSCSI target portal
	Portal string `protobuf:"bytes,1,opt,name=portal,proto3" json:"portal,omitempty"`
	// Target IQN
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// CHAP authentication
	ChapUser      string `protobuf:"bytes,3,opt,name=chap_user,json=chapUser,proto3" json:"chap_user,omitempty"`
	ChapPassword  string `protobuf:"bytes,4,opt,name=chap_password,json=chapPassword,proto3" json:"chap_password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IscsiConfig) Reset() {
	*x = IscsiConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IscsiConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IscsiConfig) ProtoMessage() {}

func (x *IscsiConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IscsiConfig.ProtoReflect.Descriptor instead.
func (*IscsiConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{7}
}

func (x *IscsiConfig) GetPortal() string {
	if x != nil {
		return x.Portal
	}
	return ""
}

func (x *IscsiConfig) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *IscsiConfig) GetChapUser() string {
	if x != nil {
		return x.ChapUser
	}
	return ""
}

func (x *IscsiConfig) GetChapPassword() string {
	if x != nil {
		return x.ChapPassword
	}
	return ""
}

type VolumeDefaults struct {
	state        protoimpl.MessageState          `protogen:"open.v1"`
	Provisioning VolumeDefaults_ProvisioningType `protobuf:"varint,1,opt,name=provisioning,proto3,enum=limiquantix.storage.v1.VolumeDefaults_ProvisioningType" json:"provisioning,omitempty"`
	// Default filesystem (for formatted volumes)
	Filesystem string `protobuf:"bytes,2,opt,name=filesystem,proto3" json:"filesystem,omitempty"` // "ext4", "xfs", "raw"
	// Default block size
	BlockSize     uint32 `protobuf:"varint,3,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeDefaults) Reset() {
	*x = VolumeDefaults{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeDefaults) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeDefaults) ProtoMessage() {}

func (x *VolumeDefaults) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeDefaults.ProtoReflect.Descriptor instead.
func (*VolumeDefaults) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{8}
}

func (x *VolumeDefaults) GetProvisioning() VolumeDefaults_ProvisioningType {
	if x != nil {
		return x.Provisioning
	}
	return VolumeDefaults_THIN
}

func (x *VolumeDefaults) GetFilesystem() string {
	if x != nil {
		return x.Filesystem
	}
	return ""
}

func (x *VolumeDefaults) GetBlockSize() uint32 {
	if x != nil {
		return x.BlockSize
	}
	return 0
}

type StorageQos struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum IOPS for the entire pool
	MaxIops uint64 `protobuf:"varint,1,opt,name=max_iops,json=maxIops,proto3" json:"max_iops,omitempty"`
	// Maximum throughput in bytes/sec
	MaxThroughputBytes uint64 `protobuf:"varint,2,opt,name=max_throughput_bytes,json=maxThroughputBytes,proto3" json:"max_throughput_bytes,omitempty"`
	// Burst settings
	BurstIops            uint64 `protobuf:"varint,3,opt,name=burst_iops,json=burstIops,proto3" json:"burst_iops,omitempty"`
	BurstThroughputBytes uint64 `protobuf:"varint,4,opt,name=burst_throughput_bytes,json=burstThroughputBytes,proto3" json:"burst_throughput_bytes,omitempty"`
	BurstDurationSec     uint32 `protobuf:"varint,5,opt,name=burst_duration_sec,json=burstDurationSec,proto3" json:"burst_duration_sec,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *StorageQos) Reset() {
	*x = StorageQos{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageQos) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageQos) ProtoMessage() {}

func (x *StorageQos) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageQos.ProtoReflect.Descriptor instead.
func (*StorageQos) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{9}
}

func (x *StorageQos) GetMaxIops() uint64 {
	if x != nil {
		return x.MaxIops
	}
	return 0
}

func (x *StorageQos) GetMaxThroughputBytes() uint64 {
	if x != nil {
		return x.MaxThroughputBytes
	}
	return 0
}

func (x *StorageQos) GetBurstIops() uint64 {
	if x != nil {
		return x.BurstIops
	}
	return 0
}

func (x *StorageQos) GetBurstThroughputBytes() uint64 {
	if x != nil {
		return x.BurstThroughputBytes
	}
	return 0
}

func (x *StorageQos) GetBurstDurationSec() uint32 {
	if x != nil {
		return x.BurstDurationSec
	}
	return 0
}

type EncryptionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable at-rest encryption
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Encryption cipher
	Cipher        string                         `protobuf:"bytes,2,opt,name=cipher,proto3" json:"cipher,omitempty"` // e.g., "aes-xts-plain64"
	KeyManagement EncryptionConfig_KeyManagement `protobuf:"varint,3,opt,name=key_management,json=keyManagement,proto3,enum=limiquantix.storage.v1.EncryptionConfig_KeyManagement" json:"key_management,omitempty"`
	// KMS configuration (if external)
	KmsEndpoint   string `protobuf:"bytes,4,opt,name=kms_endpoint,json=kmsEndpoint,proto3" json:"kms_endpoint,omitempty"`
	KmsKeyId      string `protobuf:"bytes,5,opt,name=kms_key_id,json=kmsKeyId,proto3" json:"kms_key_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptionConfig) Reset() {
	*x = EncryptionConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionConfig) ProtoMessage() {}

func (x *EncryptionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionConfig.ProtoReflect.Descriptor instead.
func (*EncryptionConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{10}
}

func (x *EncryptionConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *EncryptionConfig) GetCipher() string {
	if x != nil {
		return x.Cipher
	}
	return ""
}

func (x *EncryptionConfig) GetKeyManagement() EncryptionConfig_KeyManagement {
	if x != nil {
		return x.KeyManagement
	}
	return EncryptionConfig_INTERNAL
}

func (x *EncryptionConfig) GetKmsEndpoint() string {
	if x != nil {
		return x.KmsEndpoint
	}
	return ""
}

func (x *EncryptionConfig) GetKmsKeyId() string {
	if x != nil {
		return x.KmsKeyId
	}
	return ""
}

type ReplicationConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of replicas (for Ceph)
	ReplicaCount uint32 `protobuf:"varint,1,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// Minimum replicas before write is acknowledged
	MinReplicas uint32 `protobuf:"varint,2,opt,name=min_replicas,json=minReplicas,proto3" json:"min_replicas,omitempty"`
	// Erasure coding (alternative to replication)
	ErasureCoding *ErasureCodingConfig `protobuf:"bytes,3,opt,name=erasure_coding,json=erasureCoding,proto3" json:"erasure_coding,omitempty"`
	// Failure domain (rack, host, osd)
	FailureDomain string `protobuf:"bytes,4,opt,name=failure_domain,json=failureDomain,proto3" json:"failure_domain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationConfig) Reset() {
	*x = ReplicationConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationConfig) ProtoMessage() {}

func (x *ReplicationConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationConfig.ProtoReflect.Descriptor instead.
func (*ReplicationConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{11}
}

func (x *ReplicationConfig) GetReplicaCount() uint32 {
	if x != nil {
		return x.ReplicaCount
	}
	return 0
}

func (x *ReplicationConfig) GetMinReplicas() uint32 {
	if x != nil {
		return x.MinReplicas
	}
	return 0
}

func (x *ReplicationConfig) GetErasureCoding() *ErasureCodingConfig {
	if x != nil {
		return x.ErasureCoding
	}
	return nil
}

func (x *ReplicationConfig) GetFailureDomain() string {
	if x != nil {
		return x.FailureDomain
	}
	return ""
}

type ErasureCodingConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	DataChunks    uint32                 `protobuf:"varint,2,opt,name=data_chunks,json=dataChunks,proto3" json:"data_chunks,omitempty"`       // k value
	CodingChunks  uint32                 `protobuf:"varint,3,opt,name=coding_chunks,json=codingChunks,proto3" json:"coding_chunks,omitempty"` // m value
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ErasureCodingConfig) Reset() {
	*x = ErasureCodingConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErasureCodingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErasureCodingConfig) ProtoMessage() {}

func (x *ErasureCodingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErasureCodingConfig.ProtoReflect.Descriptor instead.
func (*ErasureCodingConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{12}
}

func (x *ErasureCodingConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ErasureCodingConfig) GetDataChunks() uint32 {
	if x != nil {
		return x.DataChunks
	}
	return 0
}

func (x *ErasureCodingConfig) GetCodingChunks() uint32 {
	if x != nil {
		return x.CodingChunks
	}
	return 0
}

type TieringConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable automatic tiering
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Hot tier pool (for frequently accessed data)
	HotPoolId string `protobuf:"bytes,2,opt,name=hot_pool_id,json=hotPoolId,proto3" json:"hot_pool_id,omitempty"`
	// Cold tier pool (for infrequently accessed data)
	ColdPoolId string                      `protobuf:"bytes,3,opt,name=cold_pool_id,json=coldPoolId,proto3" json:"cold_pool_id,omitempty"`
	Policy     TieringConfig_TieringPolicy `protobuf:"varint,4,opt,name=policy,proto3,enum=limiquantix.storage.v1.TieringConfig_TieringPolicy" json:"policy,omitempty"`
	// Age threshold in hours for migration to cold tier
	ColdAfterHours uint32 `protobuf:"varint,5,opt,name=cold_after_hours,json=coldAfterHours,proto3" json:"cold_after_hours,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TieringConfig) Reset() {
	*x = TieringConfig{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TieringConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TieringConfig) ProtoMessage() {}

func (x *TieringConfig) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TieringConfig.ProtoReflect.Descriptor instead.
func (*TieringConfig) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{13}
}

func (x *TieringConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *TieringConfig) GetHotPoolId() string {
	if x != nil {
		return x.HotPoolId
	}
	return ""
}

func (x *TieringConfig) GetColdPoolId() string {
	if x != nil {
		return x.ColdPoolId
	}
	return ""
}

func (x *TieringConfig) GetPolicy() TieringConfig_TieringPolicy {
	if x != nil {
		return x.Policy
	}
	return TieringConfig_LRU
}

func (x *TieringConfig) GetColdAfterHours() uint32 {
	if x != nil {
		return x.ColdAfterHours
	}
	return 0
}

type StoragePoolStatus struct {
	state protoimpl.MessageState  `protogen:"open.v1"`
	Phase StoragePoolStatus_Phase `protobuf:"varint,1,opt,name=phase,proto3,enum=limiquantix.storage.v1.StoragePoolStatus_Phase" json:"phase,omitempty"`
	// Capacity information
	Capacity *StorageCapacity `protobuf:"bytes,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Performance metrics
	Metrics *StorageMetrics `protobuf:"bytes,3,opt,name=metrics,proto3" json:"metrics,omitempty"`
	// Health information
	Health *StorageHealth `protobuf:"bytes,4,opt,name=health,proto3" json:"health,omitempty"`
	// Number of volumes in this pool
	VolumeCount uint32 `protobuf:"varint,5,opt,name=volume_count,json=volumeCount,proto3" json:"volume_count,omitempty"`
	// Error message if not ready
	ErrorMessage  string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoragePoolStatus) Reset() {
	*x = StoragePoolStatus{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoragePoolStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoragePoolStatus) ProtoMessage() {}

func (x *StoragePoolStatus) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoragePoolStatus.ProtoReflect.Descriptor instead.
func (*StoragePoolStatus) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{14}
}

func (x *StoragePoolStatus) GetPhase() StoragePoolStatus_Phase {
	if x != nil {
		return x.Phase
	}
	return StoragePoolStatus_UNKNOWN
}

func (x *StoragePoolStatus) GetCapacity() *StorageCapacity {
	if x != nil {
		return x.Capacity
	}
	return nil
}

func (x *StoragePoolStatus) GetMetrics() *StorageMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

func (x *StoragePoolStatus) GetHealth() *StorageHealth {
	if x != nil {
		return x.Health
	}
	return nil
}

func (x *StoragePoolStatus) GetVolumeCount() uint32 {
	if x != nil {
		return x.VolumeCount
	}
	return 0
}

func (x *StoragePoolStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type StorageCapacity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total raw capacity in bytes
	TotalBytes uint64 `protobuf:"varint,1,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Used capacity
	UsedBytes uint64 `protobuf:"varint,2,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
	// Available capacity
	AvailableBytes uint64 `protobuf:"varint,3,opt,name=available_bytes,json=availableBytes,proto3" json:"available_bytes,omitempty"`
	// Provisioned capacity (may exceed physical for thin provisioning)
	ProvisionedBytes uint64 `protobuf:"varint,4,opt,name=provisioned_bytes,json=provisionedBytes,proto3" json:"provisioned_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StorageCapacity) Reset() {
	*x = StorageCapacity{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageCapacity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageCapacity) ProtoMessage() {}

func (x *StorageCapacity) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageCapacity.ProtoReflect.Descriptor instead.
func (*StorageCapacity) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{15}
}

func (x *StorageCapacity) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *StorageCapacity) GetUsedBytes() uint64 {
	if x != nil {
		return x.UsedBytes
	}
	return 0
}

func (x *StorageCapacity) GetAvailableBytes() uint64 {
	if x != nil {
		return x.AvailableBytes
	}
	return 0
}

func (x *StorageCapacity) GetProvisionedBytes() uint64 {
	if x != nil {
		return x.ProvisionedBytes
	}
	return 0
}

type StorageMetrics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current IOPS
	ReadIops  uint64 `protobuf:"varint,1,opt,name=read_iops,json=readIops,proto3" json:"read_iops,omitempty"`
	WriteIops uint64 `protobuf:"varint,2,opt,name=write_iops,json=writeIops,proto3" json:"write_iops,omitempty"`
	// Current throughput
	ReadBytesSec  uint64 `protobuf:"varint,3,opt,name=read_bytes_sec,json=readBytesSec,proto3" json:"read_bytes_sec,omitempty"`
	WriteBytesSec uint64 `protobuf:"varint,4,opt,name=write_bytes_sec,json=writeBytesSec,proto3" json:"write_bytes_sec,omitempty"`
	// Latency in microseconds
	ReadLatencyUs  uint64 `protobuf:"varint,5,opt,name=read_latency_us,json=readLatencyUs,proto3" json:"read_latency_us,omitempty"`
	WriteLatencyUs uint64 `protobuf:"varint,6,opt,name=write_latency_us,json=writeLatencyUs,proto3" json:"write_latency_us,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StorageMetrics) Reset() {
	*x = StorageMetrics{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageMetrics) ProtoMessage() {}

func (x *StorageMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageMetrics.ProtoReflect.Descriptor instead.
func (*StorageMetrics) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{16}
}

func (x *StorageMetrics) GetReadIops() uint64 {
	if x != nil {
		return x.ReadIops
	}
	return 0
}

func (x *StorageMetrics) GetWriteIops() uint64 {
	if x != nil {
		return x.WriteIops
	}
	return 0
}

func (x *StorageMetrics) GetReadBytesSec() uint64 {
	if x != nil {
		return x.ReadBytesSec
	}
	return 0
}

func (x *StorageMetrics) GetWriteBytesSec() uint64 {
	if x != nil {
		return x.WriteBytesSec
	}
	return 0
}

func (x *StorageMetrics) GetReadLatencyUs() uint64 {
	if x != nil {
		return x.ReadLatencyUs
	}
	return 0
}

func (x *StorageMetrics) GetWriteLatencyUs() uint64 {
	if x != nil {
		return x.WriteLatencyUs
	}
	return 0
}

type StorageHealth struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Status StorageHealth_Status   `protobuf:"varint,1,opt,name=status,proto3,enum=limiquantix.storage.v1.StorageHealth_Status" json:"status,omitempty"`
	// Health checks
	Checks        []*HealthCheck `protobuf:"bytes,2,rep,name=checks,proto3" json:"checks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageHealth) Reset() {
	*x = StorageHealth{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageHealth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageHealth) ProtoMessage() {}

func (x *StorageHealth) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageHealth.ProtoReflect.Descriptor instead.
func (*StorageHealth) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{17}
}

func (x *StorageHealth) GetStatus() StorageHealth_Status {
	if x != nil {
		return x.Status
	}
	return StorageHealth_UNKNOWN
}

func (x *StorageHealth) GetChecks() []*HealthCheck {
	if x != nil {
		return x.Checks
	}
	return nil
}

type HealthCheck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Passed        bool                   `protobuf:"varint,2,opt,name=passed,proto3" json:"passed,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheck) Reset() {
	*x = HealthCheck{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck) ProtoMessage() {}

func (x *HealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{18}
}

func (x *HealthCheck) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HealthCheck) GetPassed() bool {
	if x != nil {
		return x.Passed
	}
	return false
}

func (x *HealthCheck) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Volume represents a virtual disk that can be attached to VMs.
type Volume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Immutable unique identifier (UUIDv4)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// User-friendly name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Project isolation
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Parent storage pool
	PoolId string `protobuf:"bytes,4,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// Labels for organization
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume specification
	Spec *VolumeSpec `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec,omitempty"`
	// Current status
	Status *VolumeStatus `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// Audit trail
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Volume) Reset() {
	*x = Volume{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Volume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Volume) ProtoMessage() {}

func (x *Volume) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Volume.ProtoReflect.Descriptor instead.
func (*Volume) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{19}
}

func (x *Volume) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Volume) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Volume) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *Volume) GetPoolId() string {
	if x != nil {
		return x.PoolId
	}
	return ""
}

func (x *Volume) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Volume) GetSpec() *VolumeSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Volume) GetStatus() *VolumeStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *Volume) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Volume) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type VolumeSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Size in bytes
	SizeBytes    uint64                      `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Provisioning VolumeSpec_ProvisioningType `protobuf:"varint,2,opt,name=provisioning,proto3,enum=limiquantix.storage.v1.VolumeSpec_ProvisioningType" json:"provisioning,omitempty"`
	// Source for the volume (clone, snapshot, image)
	Source *VolumeSource `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Quality of Service
	Qos *VolumeQos `protobuf:"bytes,4,opt,name=qos,proto3" json:"qos,omitempty"`
	// Encryption settings (overrides pool defaults)
	Encryption    *EncryptionConfig     `protobuf:"bytes,5,opt,name=encryption,proto3" json:"encryption,omitempty"`
	AccessMode    VolumeSpec_AccessMode `protobuf:"varint,6,opt,name=access_mode,json=accessMode,proto3,enum=limiquantix.storage.v1.VolumeSpec_AccessMode" json:"access_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeSpec) Reset() {
	*x = VolumeSpec{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeSpec) ProtoMessage() {}

func (x *VolumeSpec) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeSpec.ProtoReflect.Descriptor instead.
func (*VolumeSpec) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{20}
}

func (x *VolumeSpec) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *VolumeSpec) GetProvisioning() VolumeSpec_ProvisioningType {
	if x != nil {
		return x.Provisioning
	}
	return VolumeSpec_THIN
}

func (x *VolumeSpec) GetSource() *VolumeSource {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *VolumeSpec) GetQos() *VolumeQos {
	if x != nil {
		return x.Qos
	}
	return nil
}

func (x *VolumeSpec) GetEncryption() *EncryptionConfig {
	if x != nil {
		return x.Encryption
	}
	return nil
}

func (x *VolumeSpec) GetAccessMode() VolumeSpec_AccessMode {
	if x != nil {
		return x.AccessMode
	}
	return VolumeSpec_READ_WRITE_ONCE
}

type VolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*VolumeSource_Empty
	//	*VolumeSource_Clone
	//	*VolumeSource_Snapshot
	//	*VolumeSource_Image
	//	*VolumeSource_Url
	Source        isVolumeSource_Source `protobuf_oneof:"source"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeSource) Reset() {
	*x = VolumeSource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeSource) ProtoMessage() {}

func (x *VolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeSource.ProtoReflect.Descriptor instead.
func (*VolumeSource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{21}
}

func (x *VolumeSource) GetSource() isVolumeSource_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *VolumeSource) GetEmpty() *EmptySource {
	if x != nil {
		if x, ok := x.Source.(*VolumeSource_Empty); ok {
			return x.Empty
		}
	}
	return nil
}

func (x *VolumeSource) GetClone() *CloneSource {
	if x != nil {
		if x, ok := x.Source.(*VolumeSource_Clone); ok {
			return x.Clone
		}
	}
	return nil
}

func (x *VolumeSource) GetSnapshot() *SnapshotSource {
	if x != nil {
		if x, ok := x.Source.(*VolumeSource_Snapshot); ok {
			return x.Snapshot
		}
	}
	return nil
}

func (x *VolumeSource) GetImage() *ImageSource {
	if x != nil {
		if x, ok := x.Source.(*VolumeSource_Image); ok {
			return x.Image
		}
	}
	return nil
}

func (x *VolumeSource) GetUrl() *UrlSource {
	if x != nil {
		if x, ok := x.Source.(*VolumeSource_Url); ok {
			return x.Url
		}
	}
	return nil
}

type isVolumeSource_Source interface {
	isVolumeSource_Source()
}

type VolumeSource_Empty struct {
	// Empty volume (blank disk)
	Empty *EmptySource `protobuf:"bytes,1,opt,name=empty,proto3,oneof"`
}

type VolumeSource_Clone struct {
	// Clone from existing volume
	Clone *CloneSource `protobuf:"bytes,2,opt,name=clone,proto3,oneof"`
}

type VolumeSource_Snapshot struct {
	// Restore from snapshot
	Snapshot *SnapshotSource `protobuf:"bytes,3,opt,name=snapshot,proto3,oneof"`
}

type VolumeSource_Image struct {
	// Import from image
	Image *ImageSource `protobuf:"bytes,4,opt,name=image,proto3,oneof"`
}

type VolumeSource_Url struct {
	// Upload from URL
	Url *UrlSource `protobuf:"bytes,5,opt,name=url,proto3,oneof"`
}

func (*VolumeSource_Empty) isVolumeSource_Source() {}

func (*VolumeSource_Clone) isVolumeSource_Source() {}

func (*VolumeSource_Snapshot) isVolumeSource_Source() {}

func (*VolumeSource_Image) isVolumeSource_Source() {}

func (*VolumeSource_Url) isVolumeSource_Source() {}

type EmptySource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filesystem to format (empty = raw block device)
	Filesystem    string `protobuf:"bytes,1,opt,name=filesystem,proto3" json:"filesystem,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmptySource) Reset() {
	*x = EmptySource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptySource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptySource) ProtoMessage() {}

func (x *EmptySource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptySource.ProtoReflect.Descriptor instead.
func (*EmptySource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{22}
}

func (x *EmptySource) GetFilesystem() string {
	if x != nil {
		return x.Filesystem
	}
	return ""
}

type CloneSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source volume ID
	VolumeId      string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloneSource) Reset() {
	*x = CloneSource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloneSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloneSource) ProtoMessage() {}

func (x *CloneSource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloneSource.ProtoReflect.Descriptor instead.
func (*CloneSource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{23}
}

func (x *CloneSource) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

type SnapshotSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source snapshot ID
	SnapshotId    string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SnapshotSource) Reset() {
	*x = SnapshotSource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapshotSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapshotSource) ProtoMessage() {}

func (x *SnapshotSource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapshotSource.ProtoReflect.Descriptor instead.
func (*SnapshotSource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{24}
}

func (x *SnapshotSource) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

type ImageSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Image ID from image registry
	ImageId       string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImageSource) Reset() {
	*x = ImageSource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImageSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSource) ProtoMessage() {}

func (x *ImageSource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSource.ProtoReflect.Descriptor instead.
func (*ImageSource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{25}
}

func (x *ImageSource) GetImageId() string {
	if x != nil {
		return x.ImageId
	}
	return ""
}

type UrlSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// URL to download image from
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Checksum for verification
	Checksum      string `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	ChecksumType  string `protobuf:"bytes,3,opt,name=checksum_type,json=checksumType,proto3" json:"checksum_type,omitempty"` // "sha256", "md5"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UrlSource) Reset() {
	*x = UrlSource{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UrlSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UrlSource) ProtoMessage() {}

func (x *UrlSource) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UrlSource.ProtoReflect.Descriptor instead.
func (*UrlSource) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{26}
}

func (x *UrlSource) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *UrlSource) GetChecksum() string {
	if x != nil {
		return x.Checksum
	}
	return ""
}

func (x *UrlSource) GetChecksumType() string {
	if x != nil {
		return x.ChecksumType
	}
	return ""
}

type VolumeQos struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IOPS limits
	MaxIops uint64 `protobuf:"varint,1,opt,name=max_iops,json=maxIops,proto3" json:"max_iops,omitempty"`
	MinIops uint64 `protobuf:"varint,2,opt,name=min_iops,json=minIops,proto3" json:"min_iops,omitempty"` // Guaranteed IOPS (reservation)
	// Throughput limits in bytes/sec
	MaxThroughput uint64 `protobuf:"varint,3,opt,name=max_throughput,json=maxThroughput,proto3" json:"max_throughput,omitempty"`
	MinThroughput uint64 `protobuf:"varint,4,opt,name=min_throughput,json=minThroughput,proto3" json:"min_throughput,omitempty"`
	// Burst configuration
	BurstIops        uint64 `protobuf:"varint,5,opt,name=burst_iops,json=burstIops,proto3" json:"burst_iops,omitempty"`
	BurstThroughput  uint64 `protobuf:"varint,6,opt,name=burst_throughput,json=burstThroughput,proto3" json:"burst_throughput,omitempty"`
	BurstDurationSec uint32 `protobuf:"varint,7,opt,name=burst_duration_sec,json=burstDurationSec,proto3" json:"burst_duration_sec,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VolumeQos) Reset() {
	*x = VolumeQos{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeQos) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeQos) ProtoMessage() {}

func (x *VolumeQos) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeQos.ProtoReflect.Descriptor instead.
func (*VolumeQos) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{27}
}

func (x *VolumeQos) GetMaxIops() uint64 {
	if x != nil {
		return x.MaxIops
	}
	return 0
}

func (x *VolumeQos) GetMinIops() uint64 {
	if x != nil {
		return x.MinIops
	}
	return 0
}

func (x *VolumeQos) GetMaxThroughput() uint64 {
	if x != nil {
		return x.MaxThroughput
	}
	return 0
}

func (x *VolumeQos) GetMinThroughput() uint64 {
	if x != nil {
		return x.MinThroughput
	}
	return 0
}

func (x *VolumeQos) GetBurstIops() uint64 {
	if x != nil {
		return x.BurstIops
	}
	return 0
}

func (x *VolumeQos) GetBurstThroughput() uint64 {
	if x != nil {
		return x.BurstThroughput
	}
	return 0
}

func (x *VolumeQos) GetBurstDurationSec() uint32 {
	if x != nil {
		return x.BurstDurationSec
	}
	return 0
}

type VolumeStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Phase VolumeStatus_Phase     `protobuf:"varint,1,opt,name=phase,proto3,enum=limiquantix.storage.v1.VolumeStatus_Phase" json:"phase,omitempty"`
	// If attached, which VM?
	AttachedVmId string `protobuf:"bytes,2,opt,name=attached_vm_id,json=attachedVmId,proto3" json:"attached_vm_id,omitempty"`
	// Device path on the VM
	DevicePath string `protobuf:"bytes,3,opt,name=device_path,json=devicePath,proto3" json:"device_path,omitempty"`
	// Actual size (may differ from spec during resize)
	ActualSizeBytes uint64 `protobuf:"varint,4,opt,name=actual_size_bytes,json=actualSizeBytes,proto3" json:"actual_size_bytes,omitempty"`
	// Usage statistics
	Usage *VolumeUsage `protobuf:"bytes,5,opt,name=usage,proto3" json:"usage,omitempty"`
	// Snapshot count
	SnapshotCount uint32 `protobuf:"varint,6,opt,name=snapshot_count,json=snapshotCount,proto3" json:"snapshot_count,omitempty"`
	// Error message if in error state
	ErrorMessage string `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Backend-specific ID (e.g., Ceph RBD image name)
	BackendId     string `protobuf:"bytes,8,opt,name=backend_id,json=backendId,proto3" json:"backend_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeStatus) Reset() {
	*x = VolumeStatus{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeStatus) ProtoMessage() {}

func (x *VolumeStatus) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeStatus.ProtoReflect.Descriptor instead.
func (*VolumeStatus) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{28}
}

func (x *VolumeStatus) GetPhase() VolumeStatus_Phase {
	if x != nil {
		return x.Phase
	}
	return VolumeStatus_UNKNOWN
}

func (x *VolumeStatus) GetAttachedVmId() string {
	if x != nil {
		return x.AttachedVmId
	}
	return ""
}

func (x *VolumeStatus) GetDevicePath() string {
	if x != nil {
		return x.DevicePath
	}
	return ""
}

func (x *VolumeStatus) GetActualSizeBytes() uint64 {
	if x != nil {
		return x.ActualSizeBytes
	}
	return 0
}

func (x *VolumeStatus) GetUsage() *VolumeUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *VolumeStatus) GetSnapshotCount() uint32 {
	if x != nil {
		return x.SnapshotCount
	}
	return 0
}

func (x *VolumeStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *VolumeStatus) GetBackendId() string {
	if x != nil {
		return x.BackendId
	}
	return ""
}

type VolumeUsage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Actual bytes used (for thin volumes)
	UsedBytes uint64 `protobuf:"varint,1,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
	// Current IO metrics
	ReadIops       uint64 `protobuf:"varint,2,opt,name=read_iops,json=readIops,proto3" json:"read_iops,omitempty"`
	WriteIops      uint64 `protobuf:"varint,3,opt,name=write_iops,json=writeIops,proto3" json:"write_iops,omitempty"`
	ReadBytesSec   uint64 `protobuf:"varint,4,opt,name=read_bytes_sec,json=readBytesSec,proto3" json:"read_bytes_sec,omitempty"`
	WriteBytesSec  uint64 `protobuf:"varint,5,opt,name=write_bytes_sec,json=writeBytesSec,proto3" json:"write_bytes_sec,omitempty"`
	ReadLatencyUs  uint64 `protobuf:"varint,6,opt,name=read_latency_us,json=readLatencyUs,proto3" json:"read_latency_us,omitempty"`
	WriteLatencyUs uint64 `protobuf:"varint,7,opt,name=write_latency_us,json=writeLatencyUs,proto3" json:"write_latency_us,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VolumeUsage) Reset() {
	*x = VolumeUsage{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeUsage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeUsage) ProtoMessage() {}

func (x *VolumeUsage) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeUsage.ProtoReflect.Descriptor instead.
func (*VolumeUsage) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{29}
}

func (x *VolumeUsage) GetUsedBytes() uint64 {
	if x != nil {
		return x.UsedBytes
	}
	return 0
}

func (x *VolumeUsage) GetReadIops() uint64 {
	if x != nil {
		return x.ReadIops
	}
	return 0
}

func (x *VolumeUsage) GetWriteIops() uint64 {
	if x != nil {
		return x.WriteIops
	}
	return 0
}

func (x *VolumeUsage) GetReadBytesSec() uint64 {
	if x != nil {
		return x.ReadBytesSec
	}
	return 0
}

func (x *VolumeUsage) GetWriteBytesSec() uint64 {
	if x != nil {
		return x.WriteBytesSec
	}
	return 0
}

func (x *VolumeUsage) GetReadLatencyUs() uint64 {
	if x != nil {
		return x.ReadLatencyUs
	}
	return 0
}

func (x *VolumeUsage) GetWriteLatencyUs() uint64 {
	if x != nil {
		return x.WriteLatencyUs
	}
	return 0
}

type VolumeSnapshot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Immutable unique identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Snapshot name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Source volume
	VolumeId string `protobuf:"bytes,4,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Labels
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Snapshot specification
	Spec *VolumeSnapshotSpec `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec,omitempty"`
	// Current status
	Status        *VolumeSnapshotStatus  `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeSnapshot) Reset() {
	*x = VolumeSnapshot{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeSnapshot) ProtoMessage() {}

func (x *VolumeSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeSnapshot.ProtoReflect.Descriptor instead.
func (*VolumeSnapshot) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{30}
}

func (x *VolumeSnapshot) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VolumeSnapshot) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VolumeSnapshot) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *VolumeSnapshot) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *VolumeSnapshot) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *VolumeSnapshot) GetSpec() *VolumeSnapshotSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *VolumeSnapshot) GetStatus() *VolumeSnapshotStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *VolumeSnapshot) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

type VolumeSnapshotSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Retention policy
	Retention     *RetentionPolicy `protobuf:"bytes,1,opt,name=retention,proto3" json:"retention,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeSnapshotSpec) Reset() {
	*x = VolumeSnapshotSpec{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeSnapshotSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeSnapshotSpec) ProtoMessage() {}

func (x *VolumeSnapshotSpec) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeSnapshotSpec.ProtoReflect.Descriptor instead.
func (*VolumeSnapshotSpec) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{31}
}

func (x *VolumeSnapshotSpec) GetRetention() *RetentionPolicy {
	if x != nil {
		return x.Retention
	}
	return nil
}

type RetentionPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Keep snapshot for this many hours (0 = forever)
	RetainHours uint32 `protobuf:"varint,1,opt,name=retain_hours,json=retainHours,proto3" json:"retain_hours,omitempty"`
	// Delete after this timestamp
	ExpiresAt     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetentionPolicy) Reset() {
	*x = RetentionPolicy{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetentionPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetentionPolicy) ProtoMessage() {}

func (x *RetentionPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetentionPolicy.ProtoReflect.Descriptor instead.
func (*RetentionPolicy) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{32}
}

func (x *RetentionPolicy) GetRetainHours() uint32 {
	if x != nil {
		return x.RetainHours
	}
	return 0
}

func (x *RetentionPolicy) GetExpiresAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiresAt
	}
	return nil
}

type VolumeSnapshotStatus struct {
	state protoimpl.MessageState     `protogen:"open.v1"`
	Phase VolumeSnapshotStatus_Phase `protobuf:"varint,1,opt,name=phase,proto3,enum=limiquantix.storage.v1.VolumeSnapshotStatus_Phase" json:"phase,omitempty"`
	// Snapshot size
	SizeBytes uint64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Ready to use for restore/clone
	ReadyToUse bool `protobuf:"varint,3,opt,name=ready_to_use,json=readyToUse,proto3" json:"ready_to_use,omitempty"`
	// Error message
	ErrorMessage  string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeSnapshotStatus) Reset() {
	*x = VolumeSnapshotStatus{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeSnapshotStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeSnapshotStatus) ProtoMessage() {}

func (x *VolumeSnapshotStatus) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeSnapshotStatus.ProtoReflect.Descriptor instead.
func (*VolumeSnapshotStatus) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{33}
}

func (x *VolumeSnapshotStatus) GetPhase() VolumeSnapshotStatus_Phase {
	if x != nil {
		return x.Phase
	}
	return VolumeSnapshotStatus_UNKNOWN
}

func (x *VolumeSnapshotStatus) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *VolumeSnapshotStatus) GetReadyToUse() bool {
	if x != nil {
		return x.ReadyToUse
	}
	return false
}

func (x *VolumeSnapshotStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// Image represents a bootable OS image/template.
type Image struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Immutable unique identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Image name (e.g., "ubuntu-22.04-cloudimg")
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Project (empty = public image)
	ProjectId string `protobuf:"bytes,4,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Labels
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Image specification
	Spec *ImageSpec `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec,omitempty"`
	// Current status
	Status        *ImageStatus           `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Image) Reset() {
	*x = Image{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Image) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Image) ProtoMessage() {}

func (x *Image) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Image.ProtoReflect.Descriptor instead.
func (*Image) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{34}
}

func (x *Image) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Image) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Image) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Image) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *Image) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Image) GetSpec() *ImageSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Image) GetStatus() *ImageStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *Image) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Image) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type ImageSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source of the image
	Source *ImageSource `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// OS information
	Os *OsInfo `protobuf:"bytes,2,opt,name=os,proto3" json:"os,omitempty"`
	// Minimum requirements
	Requirements  *ImageRequirements   `protobuf:"bytes,3,opt,name=requirements,proto3" json:"requirements,omitempty"`
	Format        ImageSpec_Format     `protobuf:"varint,4,opt,name=format,proto3,enum=limiquantix.storage.v1.ImageSpec_Format" json:"format,omitempty"`
	Visibility    ImageSpec_Visibility `protobuf:"varint,5,opt,name=visibility,proto3,enum=limiquantix.storage.v1.ImageSpec_Visibility" json:"visibility,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImageSpec) Reset() {
	*x = ImageSpec{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImageSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSpec) ProtoMessage() {}

func (x *ImageSpec) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSpec.ProtoReflect.Descriptor instead.
func (*ImageSpec) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{35}
}

func (x *ImageSpec) GetSource() *ImageSource {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *ImageSpec) GetOs() *OsInfo {
	if x != nil {
		return x.Os
	}
	return nil
}

func (x *ImageSpec) GetRequirements() *ImageRequirements {
	if x != nil {
		return x.Requirements
	}
	return nil
}

func (x *ImageSpec) GetFormat() ImageSpec_Format {
	if x != nil {
		return x.Format
	}
	return ImageSpec_RAW
}

func (x *ImageSpec) GetVisibility() ImageSpec_Visibility {
	if x != nil {
		return x.Visibility
	}
	return ImageSpec_PRIVATE
}

type ImageSourceSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*ImageSourceSpec_FilePath
	//	*ImageSourceSpec_Url
	//	*ImageSourceSpec_VolumeId
	//	*ImageSourceSpec_ContainerImage
	Source isImageSourceSpec_Source `protobuf_oneof:"source"`
	// Checksum verification
	Checksum      string `protobuf:"bytes,5,opt,name=checksum,proto3" json:"checksum,omitempty"`
	ChecksumType  string `protobuf:"bytes,6,opt,name=checksum_type,json=checksumType,proto3" json:"checksum_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImageSourceSpec) Reset() {
	*x = ImageSourceSpec{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImageSourceSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSourceSpec) ProtoMessage() {}

func (x *ImageSourceSpec) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSourceSpec.ProtoReflect.Descriptor instead.
func (*ImageSourceSpec) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{36}
}

func (x *ImageSourceSpec) GetSource() isImageSourceSpec_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *ImageSourceSpec) GetFilePath() string {
	if x != nil {
		if x, ok := x.Source.(*ImageSourceSpec_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

func (x *ImageSourceSpec) GetUrl() string {
	if x != nil {
		if x, ok := x.Source.(*ImageSourceSpec_Url); ok {
			return x.Url
		}
	}
	return ""
}

func (x *ImageSourceSpec) GetVolumeId() string {
	if x != nil {
		if x, ok := x.Source.(*ImageSourceSpec_VolumeId); ok {
			return x.VolumeId
		}
	}
	return ""
}

func (x *ImageSourceSpec) GetContainerImage() string {
	if x != nil {
		if x, ok := x.Source.(*ImageSourceSpec_ContainerImage); ok {
			return x.ContainerImage
		}
	}
	return ""
}

func (x *ImageSourceSpec) GetChecksum() string {
	if x != nil {
		return x.Checksum
	}
	return ""
}

func (x *ImageSourceSpec) GetChecksumType() string {
	if x != nil {
		return x.ChecksumType
	}
	return ""
}

type isImageSourceSpec_Source interface {
	isImageSourceSpec_Source()
}

type ImageSourceSpec_FilePath struct {
	// Upload from local file
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3,oneof"`
}

type ImageSourceSpec_Url struct {
	// Download from URL
	Url string `protobuf:"bytes,2,opt,name=url,proto3,oneof"`
}

type ImageSourceSpec_VolumeId struct {
	// Convert from existing volume
	VolumeId string `protobuf:"bytes,3,opt,name=volume_id,json=volumeId,proto3,oneof"`
}

type ImageSourceSpec_ContainerImage struct {
	// Import from container registry
	ContainerImage string `protobuf:"bytes,4,opt,name=container_image,json=containerImage,proto3,oneof"`
}

func (*ImageSourceSpec_FilePath) isImageSourceSpec_Source() {}

func (*ImageSourceSpec_Url) isImageSourceSpec_Source() {}

func (*ImageSourceSpec_VolumeId) isImageSourceSpec_Source() {}

func (*ImageSourceSpec_ContainerImage) isImageSourceSpec_Source() {}

type OsInfo struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Family OsInfo_OsFamily        `protobuf:"varint,1,opt,name=family,proto3,enum=limiquantix.storage.v1.OsInfo_OsFamily" json:"family,omitempty"`
	// Distribution (e.g., "ubuntu", "centos", "windows-server")
	Distribution string `protobuf:"bytes,2,opt,name=distribution,proto3" json:"distribution,omitempty"`
	// Version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Architecture
	Architecture string `protobuf:"bytes,4,opt,name=architecture,proto3" json:"architecture,omitempty"` // "x86_64", "aarch64"
	// Default username for cloud-init
	DefaultUser   string `protobuf:"bytes,5,opt,name=default_user,json=defaultUser,proto3" json:"default_user,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OsInfo) Reset() {
	*x = OsInfo{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OsInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OsInfo) ProtoMessage() {}

func (x *OsInfo) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OsInfo.ProtoReflect.Descriptor instead.
func (*OsInfo) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{37}
}

func (x *OsInfo) GetFamily() OsInfo_OsFamily {
	if x != nil {
		return x.Family
	}
	return OsInfo_UNKNOWN
}

func (x *OsInfo) GetDistribution() string {
	if x != nil {
		return x.Distribution
	}
	return ""
}

func (x *OsInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *OsInfo) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *OsInfo) GetDefaultUser() string {
	if x != nil {
		return x.DefaultUser
	}
	return ""
}

type ImageRequirements struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum vCPUs
	MinCpu uint32 `protobuf:"varint,1,opt,name=min_cpu,json=minCpu,proto3" json:"min_cpu,omitempty"`
	// Minimum memory in MiB
	MinMemoryMib uint64 `protobuf:"varint,2,opt,name=min_memory_mib,json=minMemoryMib,proto3" json:"min_memory_mib,omitempty"`
	// Minimum disk size in GiB
	MinDiskGib uint64 `protobuf:"varint,3,opt,name=min_disk_gib,json=minDiskGib,proto3" json:"min_disk_gib,omitempty"`
	// Required firmware
	SupportedFirmware []string `protobuf:"bytes,4,rep,name=supported_firmware,json=supportedFirmware,proto3" json:"supported_firmware,omitempty"` // "bios", "uefi"
	// Requires UEFI Secure Boot
	RequiresSecureBoot bool `protobuf:"varint,5,opt,name=requires_secure_boot,json=requiresSecureBoot,proto3" json:"requires_secure_boot,omitempty"`
	// Requires TPM
	RequiresTpm   bool `protobuf:"varint,6,opt,name=requires_tpm,json=requiresTpm,proto3" json:"requires_tpm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImageRequirements) Reset() {
	*x = ImageRequirements{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImageRequirements) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageRequirements) ProtoMessage() {}

func (x *ImageRequirements) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageRequirements.ProtoReflect.Descriptor instead.
func (*ImageRequirements) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{38}
}

func (x *ImageRequirements) GetMinCpu() uint32 {
	if x != nil {
		return x.MinCpu
	}
	return 0
}

func (x *ImageRequirements) GetMinMemoryMib() uint64 {
	if x != nil {
		return x.MinMemoryMib
	}
	return 0
}

func (x *ImageRequirements) GetMinDiskGib() uint64 {
	if x != nil {
		return x.MinDiskGib
	}
	return 0
}

func (x *ImageRequirements) GetSupportedFirmware() []string {
	if x != nil {
		return x.SupportedFirmware
	}
	return nil
}

func (x *ImageRequirements) GetRequiresSecureBoot() bool {
	if x != nil {
		return x.RequiresSecureBoot
	}
	return false
}

func (x *ImageRequirements) GetRequiresTpm() bool {
	if x != nil {
		return x.RequiresTpm
	}
	return false
}

type ImageStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Phase ImageStatus_Phase      `protobuf:"varint,1,opt,name=phase,proto3,enum=limiquantix.storage.v1.ImageStatus_Phase" json:"phase,omitempty"`
	// Size in bytes
	SizeBytes uint64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Virtual size (uncompressed)
	VirtualSizeBytes uint64 `protobuf:"varint,3,opt,name=virtual_size_bytes,json=virtualSizeBytes,proto3" json:"virtual_size_bytes,omitempty"`
	// Download progress (0-100)
	ProgressPercent uint32 `protobuf:"varint,4,opt,name=progress_percent,json=progressPercent,proto3" json:"progress_percent,omitempty"`
	// Checksum of stored image
	Checksum string `protobuf:"bytes,5,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Error message
	ErrorMessage string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Which storage pool holds this image
	StoragePoolId string `protobuf:"bytes,7,opt,name=storage_pool_id,json=storagePoolId,proto3" json:"storage_pool_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImageStatus) Reset() {
	*x = ImageStatus{}
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImageStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageStatus) ProtoMessage() {}

func (x *ImageStatus) ProtoReflect() protoreflect.Message {
	mi := &file_limiquantix_storage_v1_storage_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageStatus.ProtoReflect.Descriptor instead.
func (*ImageStatus) Descriptor() ([]byte, []int) {
	return file_limiquantix_storage_v1_storage_proto_rawDescGZIP(), []int{39}
}

func (x *ImageStatus) GetPhase() ImageStatus_Phase {
	if x != nil {
		return x.Phase
	}
	return ImageStatus_UNKNOWN
}

func (x *ImageStatus) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ImageStatus) GetVirtualSizeBytes() uint64 {
	if x != nil {
		return x.VirtualSizeBytes
	}
	return 0
}

func (x *ImageStatus) GetProgressPercent() uint32 {
	if x != nil {
		return x.ProgressPercent
	}
	return 0
}

func (x *ImageStatus) GetChecksum() string {
	if x != nil {
		return x.Checksum
	}
	return ""
}

func (x *ImageStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *ImageStatus) GetStoragePoolId() string {
	if x != nil {
		return x.StoragePoolId
	}
	return ""
}

var File_limiquantix_storage_v1_storage_proto protoreflect.FileDescriptor

const file_limiquantix_storage_v1_storage_proto_rawDesc = "" +
	"\n" +
	"$limiquantix/storage/v1/storage.proto\x12\x16limiquantix.storage.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xec\x03\n" +
	"\vStoragePool\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12G\n" +
	"\x06labels\x18\x05 \x03(\v2/.limiquantix.storage.v1.StoragePool.LabelsEntryR\x06labels\x12;\n" +
	"\x04spec\x18\x06 \x01(\v2'.limiquantix.storage.v1.StoragePoolSpecR\x04spec\x12A\n" +
	"\x06status\x18\a \x01(\v2).limiquantix.storage.v1.StoragePoolStatusR\x06status\x129\n" +
	"\n" +
	"created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa5\x03\n" +
	"\x0fStoragePoolSpec\x12@\n" +
	"\abackend\x18\x01 \x01(\v2&.limiquantix.storage.v1.StorageBackendR\abackend\x12B\n" +
	"\bdefaults\x18\x02 \x01(\v2&.limiquantix.storage.v1.VolumeDefaultsR\bdefaults\x124\n" +
	"\x03qos\x18\x03 \x01(\v2\".limiquantix.storage.v1.StorageQosR\x03qos\x12H\n" +
	"\n" +
	"encryption\x18\x04 \x01(\v2(.limiquantix.storage.v1.EncryptionConfigR\n" +
	"encryption\x12K\n" +
	"\vreplication\x18\x05 \x01(\v2).limiquantix.storage.v1.ReplicationConfigR\vreplication\x12?\n" +
	"\atiering\x18\x06 \x01(\v2%.limiquantix.storage.v1.TieringConfigR\atiering\"\xfe\x03\n" +
	"\x0eStorageBackend\x12F\n" +
	"\x04type\x18\x01 \x01(\x0e22.limiquantix.storage.v1.StorageBackend.BackendTypeR\x04type\x128\n" +
	"\x04ceph\x18\x02 \x01(\v2\".limiquantix.storage.v1.CephConfigH\x00R\x04ceph\x12E\n" +
	"\tlocal_lvm\x18\x03 \x01(\v2&.limiquantix.storage.v1.LocalLvmConfigH\x00R\blocalLvm\x12E\n" +
	"\tlocal_dir\x18\x04 \x01(\v2&.limiquantix.storage.v1.LocalDirConfigH\x00R\blocalDir\x125\n" +
	"\x03nfs\x18\x05 \x01(\v2!.limiquantix.storage.v1.NfsConfigH\x00R\x03nfs\x12;\n" +
	"\x05iscsi\x18\x06 \x01(\v2#.limiquantix.storage.v1.IscsiConfigH\x00R\x05iscsi\"^\n" +
	"\vBackendType\x12\f\n" +
	"\bCEPH_RBD\x10\x00\x12\x0f\n" +
	"\vCEPH_CEPHFS\x10\x01\x12\r\n" +
	"\tLOCAL_LVM\x10\x02\x12\r\n" +
	"\tLOCAL_DIR\x10\x03\x12\a\n" +
	"\x03NFS\x10\x04\x12\t\n" +
	"\x05ISCSI\x10\x05B\b\n" +
	"\x06config\"\xb9\x01\n" +
	"\n" +
	"CephConfig\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tR\tclusterId\x12\x1b\n" +
	"\tpool_name\x18\x02 \x01(\tR\bpoolName\x12\x1a\n" +
	"\bmonitors\x18\x03 \x03(\tR\bmonitors\x12\x12\n" +
	"\x04user\x18\x04 \x01(\tR\x04user\x12!\n" +
	"\fkeyring_path\x18\x05 \x01(\tR\vkeyringPath\x12\x1c\n" +
	"\tnamespace\x18\x06 \x01(\tR\tnamespace\"i\n" +
	"\x0eLocalLvmConfig\x12!\n" +
	"\fvolume_group\x18\x01 \x01(\tR\vvolumeGroup\x12\x1b\n" +
	"\tthin_pool\x18\x02 \x01(\tR\bthinPool\x12\x17\n" +
	"\anode_id\x18\x03 \x01(\tR\x06nodeId\"=\n" +
	"\x0eLocalDirConfig\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\"x\n" +
	"\tNfsConfig\x12\x16\n" +
	"\x06server\x18\x01 \x01(\tR\x06server\x12\x1f\n" +
	"\vexport_path\x18\x02 \x01(\tR\n" +
	"exportPath\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x18\n" +
	"\aoptions\x18\x04 \x01(\tR\aoptions\"\x7f\n" +
	"\vIscsiConfig\x12\x16\n" +
	"\x06portal\x18\x01 \x01(\tR\x06portal\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12\x1b\n" +
	"\tchap_user\x18\x03 \x01(\tR\bchapUser\x12#\n" +
	"\rchap_password\x18\x04 \x01(\tR\fchapPassword\"\xd5\x01\n" +
	"\x0eVolumeDefaults\x12[\n" +
	"\fprovisioning\x18\x01 \x01(\x0e27.limiquantix.storage.v1.VolumeDefaults.ProvisioningTypeR\fprovisioning\x12\x1e\n" +
	"\n" +
	"filesystem\x18\x02 \x01(\tR\n" +
	"filesystem\x12\x1d\n" +
	"\n" +
	"block_size\x18\x03 \x01(\rR\tblockSize\"'\n" +
	"\x10ProvisioningType\x12\b\n" +
	"\x04THIN\x10\x00\x12\t\n" +
	"\x05THICK\x10\x01\"\xdc\x01\n" +
	"\n" +
	"StorageQos\x12\x19\n" +
	"\bmax_iops\x18\x01 \x01(\x04R\amaxIops\x120\n" +
	"\x14max_throughput_bytes\x18\x02 \x01(\x04R\x12maxThroughputBytes\x12\x1d\n" +
	"\n" +
	"burst_iops\x18\x03 \x01(\x04R\tburstIops\x124\n" +
	"\x16burst_throughput_bytes\x18\x04 \x01(\x04R\x14burstThroughputBytes\x12,\n" +
	"\x12burst_duration_sec\x18\x05 \x01(\rR\x10burstDurationSec\"\x95\x02\n" +
	"\x10EncryptionConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x16\n" +
	"\x06cipher\x18\x02 \x01(\tR\x06cipher\x12]\n" +
	"\x0ekey_management\x18\x03 \x01(\x0e26.limiquantix.storage.v1.EncryptionConfig.KeyManagementR\rkeyManagement\x12!\n" +
	"\fkms_endpoint\x18\x04 \x01(\tR\vkmsEndpoint\x12\x1c\n" +
	"\n" +
	"kms_key_id\x18\x05 \x01(\tR\bkmsKeyId\"/\n" +
	"\rKeyManagement\x12\f\n" +
	"\bINTERNAL\x10\x00\x12\x10\n" +
	"\fEXTERNAL_KMS\x10\x01\"\xd6\x01\n" +
	"\x11ReplicationConfig\x12#\n" +
	"\rreplica_count\x18\x01 \x01(\rR\freplicaCount\x12!\n" +
	"\fmin_replicas\x18\x02 \x01(\rR\vminReplicas\x12R\n" +
	"\x0eerasure_coding\x18\x03 \x01(\v2+.limiquantix.storage.v1.ErasureCodingConfigR\rerasureCoding\x12%\n" +
	"\x0efailure_domain\x18\x04 \x01(\tR\rfailureDomain\"u\n" +
	"\x13ErasureCodingConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1f\n" +
	"\vdata_chunks\x18\x02 \x01(\rR\n" +
	"dataChunks\x12#\n" +
	"\rcoding_chunks\x18\x03 \x01(\rR\fcodingChunks\"\x8b\x02\n" +
	"\rTieringConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1e\n" +
	"\vhot_pool_id\x18\x02 \x01(\tR\thotPoolId\x12 \n" +
	"\fcold_pool_id\x18\x03 \x01(\tR\n" +
	"coldPoolId\x12K\n" +
	"\x06policy\x18\x04 \x01(\x0e23.limiquantix.storage.v1.TieringConfig.TieringPolicyR\x06policy\x12(\n" +
	"\x10cold_after_hours\x18\x05 \x01(\rR\x0ecoldAfterHours\"'\n" +
	"\rTieringPolicy\x12\a\n" +
	"\x03LRU\x10\x00\x12\r\n" +
	"\tWRITEBACK\x10\x01\"\xbd\x03\n" +
	"\x11StoragePoolStatus\x12E\n" +
	"\x05phase\x18\x01 \x01(\x0e2/.limiquantix.storage.v1.StoragePoolStatus.PhaseR\x05phase\x12C\n" +
	"\bcapacity\x18\x02 \x01(\v2'.limiquantix.storage.v1.StorageCapacityR\bcapacity\x12@\n" +
	"\ametrics\x18\x03 \x01(\v2&.limiquantix.storage.v1.StorageMetricsR\ametrics\x12=\n" +
	"\x06health\x18\x04 \x01(\v2%.limiquantix.storage.v1.StorageHealthR\x06health\x12!\n" +
	"\fvolume_count\x18\x05 \x01(\rR\vvolumeCount\x12#\n" +
	"\rerror_message\x18\x06 \x01(\tR\ferrorMessage\"S\n" +
	"\x05Phase\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\t\n" +
	"\x05READY\x10\x02\x12\f\n" +
	"\bDEGRADED\x10\x03\x12\t\n" +
	"\x05ERROR\x10\x04\x12\f\n" +
	"\bDELETING\x10\x05\"\xa7\x01\n" +
	"\x0fStorageCapacity\x12\x1f\n" +
	"\vtotal_bytes\x18\x01 \x01(\x04R\n" +
	"totalBytes\x12\x1d\n" +
	"\n" +
	"used_bytes\x18\x02 \x01(\x04R\tusedBytes\x12'\n" +
	"\x0favailable_bytes\x18\x03 \x01(\x04R\x0eavailableBytes\x12+\n" +
	"\x11provisioned_bytes\x18\x04 \x01(\x04R\x10provisionedBytes\"\xec\x01\n" +
	"\x0eStorageMetrics\x12\x1b\n" +
	"\tread_iops\x18\x01 \x01(\x04R\breadIops\x12\x1d\n" +
	"\n" +
	"write_iops\x18\x02 \x01(\x04R\twriteIops\x12$\n" +
	"\x0eread_bytes_sec\x18\x03 \x01(\x04R\freadBytesSec\x12&\n" +
	"\x0fwrite_bytes_sec\x18\x04 \x01(\x04R\rwriteBytesSec\x12&\n" +
	"\x0fread_latency_us\x18\x05 \x01(\x04R\rreadLatencyUs\x12(\n" +
	"\x10write_latency_us\x18\x06 \x01(\x04R\x0ewriteLatencyUs\"\xce\x01\n" +
	"\rStorageHealth\x12D\n" +
	"\x06status\x18\x01 \x01(\x0e2,.limiquantix.storage.v1.StorageHealth.StatusR\x06status\x12;\n" +
	"\x06checks\x18\x02 \x03(\v2#.limiquantix.storage.v1.HealthCheckR\x06checks\":\n" +
	"\x06Status\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aHEALTHY\x10\x01\x12\v\n" +
	"\aWARNING\x10\x02\x12\t\n" +
	"\x05ERROR\x10\x03\"S\n" +
	"\vHealthCheck\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06passed\x18\x02 \x01(\bR\x06passed\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\xcf\x03\n" +
	"\x06Volume\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"project_id\x18\x03 \x01(\tR\tprojectId\x12\x17\n" +
	"\apool_id\x18\x04 \x01(\tR\x06poolId\x12B\n" +
	"\x06labels\x18\x05 \x03(\v2*.limiquantix.storage.v1.Volume.LabelsEntryR\x06labels\x126\n" +
	"\x04spec\x18\x06 \x01(\v2\".limiquantix.storage.v1.VolumeSpecR\x04spec\x12<\n" +
	"\x06status\x18\a \x01(\v2$.limiquantix.storage.v1.VolumeStatusR\x06status\x129\n" +
	"\n" +
	"created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9c\x04\n" +
	"\n" +
	"VolumeSpec\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x01 \x01(\x04R\tsizeBytes\x12W\n" +
	"\fprovisioning\x18\x02 \x01(\x0e23.limiquantix.storage.v1.VolumeSpec.ProvisioningTypeR\fprovisioning\x12<\n" +
	"\x06source\x18\x03 \x01(\v2$.limiquantix.storage.v1.VolumeSourceR\x06source\x123\n" +
	"\x03qos\x18\x04 \x01(\v2!.limiquantix.storage.v1.VolumeQosR\x03qos\x12H\n" +
	"\n" +
	"encryption\x18\x05 \x01(\v2(.limiquantix.storage.v1.EncryptionConfigR\n" +
	"encryption\x12N\n" +
	"\vaccess_mode\x18\x06 \x01(\x0e2-.limiquantix.storage.v1.VolumeSpec.AccessModeR\n" +
	"accessMode\"=\n" +
	"\x10ProvisioningType\x12\b\n" +
	"\x04THIN\x10\x00\x12\x0e\n" +
	"\n" +
	"THICK_LAZY\x10\x01\x12\x0f\n" +
	"\vTHICK_EAGER\x10\x02\"J\n" +
	"\n" +
	"AccessMode\x12\x13\n" +
	"\x0fREAD_WRITE_ONCE\x10\x00\x12\x12\n" +
	"\x0eREAD_ONLY_MANY\x10\x01\x12\x13\n" +
	"\x0fREAD_WRITE_MANY\x10\x02\"\xcc\x02\n" +
	"\fVolumeSource\x12;\n" +
	"\x05empty\x18\x01 \x01(\v2#.limiquantix.storage.v1.EmptySourceH\x00R\x05empty\x12;\n" +
	"\x05clone\x18\x02 \x01(\v2#.limiquantix.storage.v1.CloneSourceH\x00R\x05clone\x12D\n" +
	"\bsnapshot\x18\x03 \x01(\v2&.limiquantix.storage.v1.SnapshotSourceH\x00R\bsnapshot\x12;\n" +
	"\x05image\x18\x04 \x01(\v2#.limiquantix.storage.v1.ImageSourceH\x00R\x05image\x125\n" +
	"\x03url\x18\x05 \x01(\v2!.limiquantix.storage.v1.UrlSourceH\x00R\x03urlB\b\n" +
	"\x06source\"-\n" +
	"\vEmptySource\x12\x1e\n" +
	"\n" +
	"filesystem\x18\x01 \x01(\tR\n" +
	"filesystem\"*\n" +
	"\vCloneSource\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\"1\n" +
	"\x0eSnapshotSource\x12\x1f\n" +
	"\vsnapshot_id\x18\x01 \x01(\tR\n" +
	"snapshotId\"(\n" +
	"\vImageSource\x12\x19\n" +
	"\bimage_id\x18\x01 \x01(\tR\aimageId\"^\n" +
	"\tUrlSource\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x1a\n" +
	"\bchecksum\x18\x02 \x01(\tR\bchecksum\x12#\n" +
	"\rchecksum_type\x18\x03 \x01(\tR\fchecksumType\"\x87\x02\n" +
	"\tVolumeQos\x12\x19\n" +
	"\bmax_iops\x18\x01 \x01(\x04R\amaxIops\x12\x19\n" +
	"\bmin_iops\x18\x02 \x01(\x04R\aminIops\x12%\n" +
	"\x0emax_throughput\x18\x03 \x01(\x04R\rmaxThroughput\x12%\n" +
	"\x0emin_throughput\x18\x04 \x01(\x04R\rminThroughput\x12\x1d\n" +
	"\n" +
	"burst_iops\x18\x05 \x01(\x04R\tburstIops\x12)\n" +
	"\x10burst_throughput\x18\x06 \x01(\x04R\x0fburstThroughput\x12,\n" +
	"\x12burst_duration_sec\x18\a \x01(\rR\x10burstDurationSec\"\xd8\x03\n" +
	"\fVolumeStatus\x12@\n" +
	"\x05phase\x18\x01 \x01(\x0e2*.limiquantix.storage.v1.VolumeStatus.PhaseR\x05phase\x12$\n" +
	"\x0eattached_vm_id\x18\x02 \x01(\tR\fattachedVmId\x12\x1f\n" +
	"\vdevice_path\x18\x03 \x01(\tR\n" +
	"devicePath\x12*\n" +
	"\x11actual_size_bytes\x18\x04 \x01(\x04R\x0factualSizeBytes\x129\n" +
	"\x05usage\x18\x05 \x01(\v2#.limiquantix.storage.v1.VolumeUsageR\x05usage\x12%\n" +
	"\x0esnapshot_count\x18\x06 \x01(\rR\rsnapshotCount\x12#\n" +
	"\rerror_message\x18\a \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"backend_id\x18\b \x01(\tR\tbackendId\"m\n" +
	"\x05Phase\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bCREATING\x10\x02\x12\t\n" +
	"\x05READY\x10\x03\x12\n" +
	"\n" +
	"\x06IN_USE\x10\x04\x12\f\n" +
	"\bDELETING\x10\x05\x12\t\n" +
	"\x05ERROR\x10\x06\x12\f\n" +
	"\bRESIZING\x10\a\"\x88\x02\n" +
	"\vVolumeUsage\x12\x1d\n" +
	"\n" +
	"used_bytes\x18\x01 \x01(\x04R\tusedBytes\x12\x1b\n" +
	"\tread_iops\x18\x02 \x01(\x04R\breadIops\x12\x1d\n" +
	"\n" +
	"write_iops\x18\x03 \x01(\x04R\twriteIops\x12$\n" +
	"\x0eread_bytes_sec\x18\x04 \x01(\x04R\freadBytesSec\x12&\n" +
	"\x0fwrite_bytes_sec\x18\x05 \x01(\x04R\rwriteBytesSec\x12&\n" +
	"\x0fread_latency_us\x18\x06 \x01(\x04R\rreadLatencyUs\x12(\n" +
	"\x10write_latency_us\x18\a \x01(\x04R\x0ewriteLatencyUs\"\xbb\x03\n" +
	"\x0eVolumeSnapshot\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x1b\n" +
	"\tvolume_id\x18\x04 \x01(\tR\bvolumeId\x12J\n" +
	"\x06labels\x18\x05 \x03(\v22.limiquantix.storage.v1.VolumeSnapshot.LabelsEntryR\x06labels\x12>\n" +
	"\x04spec\x18\x06 \x01(\v2*.limiquantix.storage.v1.VolumeSnapshotSpecR\x04spec\x12D\n" +
	"\x06status\x18\a \x01(\v2,.limiquantix.storage.v1.VolumeSnapshotStatusR\x06status\x129\n" +
	"\n" +
	"created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"[\n" +
	"\x12VolumeSnapshotSpec\x12E\n" +
	"\tretention\x18\x01 \x01(\v2'.limiquantix.storage.v1.RetentionPolicyR\tretention\"o\n" +
	"\x0fRetentionPolicy\x12!\n" +
	"\fretain_hours\x18\x01 \x01(\rR\vretainHours\x129\n" +
	"\n" +
	"expires_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\"\x9b\x02\n" +
	"\x14VolumeSnapshotStatus\x12H\n" +
	"\x05phase\x18\x01 \x01(\x0e22.limiquantix.storage.v1.VolumeSnapshotStatus.PhaseR\x05phase\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\x04R\tsizeBytes\x12 \n" +
	"\fready_to_use\x18\x03 \x01(\bR\n" +
	"readyToUse\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"S\n" +
	"\x05Phase\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bCREATING\x10\x02\x12\t\n" +
	"\x05READY\x10\x03\x12\f\n" +
	"\bDELETING\x10\x04\x12\t\n" +
	"\x05ERROR\x10\x05\"\xd4\x03\n" +
	"\x05Image\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x1d\n" +
	"\n" +
	"project_id\x18\x04 \x01(\tR\tprojectId\x12A\n" +
	"\x06labels\x18\x05 \x03(\v2).limiquantix.storage.v1.Image.LabelsEntryR\x06labels\x125\n" +
	"\x04spec\x18\x06 \x01(\v2!.limiquantix.storage.v1.ImageSpecR\x04spec\x12;\n" +
	"\x06status\x18\a \x01(\v2#.limiquantix.storage.v1.ImageStatusR\x06status\x129\n" +
	"\n" +
	"created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc5\x03\n" +
	"\tImageSpec\x12;\n" +
	"\x06source\x18\x01 \x01(\v2#.limiquantix.storage.v1.ImageSourceR\x06source\x12.\n" +
	"\x02os\x18\x02 \x01(\v2\x1e.limiquantix.storage.v1.OsInfoR\x02os\x12M\n" +
	"\frequirements\x18\x03 \x01(\v2).limiquantix.storage.v1.ImageRequirementsR\frequirements\x12@\n" +
	"\x06format\x18\x04 \x01(\x0e2(.limiquantix.storage.v1.ImageSpec.FormatR\x06format\x12L\n" +
	"\n" +
	"visibility\x18\x05 \x01(\x0e2,.limiquantix.storage.v1.ImageSpec.VisibilityR\n" +
	"visibility\"8\n" +
	"\x06Format\x12\a\n" +
	"\x03RAW\x10\x00\x12\t\n" +
	"\x05QCOW2\x10\x01\x12\b\n" +
	"\x04VMDK\x10\x02\x12\a\n" +
	"\x03VHD\x10\x03\x12\a\n" +
	"\x03ISO\x10\x04\"2\n" +
	"\n" +
	"Visibility\x12\v\n" +
	"\aPRIVATE\x10\x00\x12\v\n" +
	"\aPROJECT\x10\x01\x12\n" +
	"\n" +
	"\x06PUBLIC\x10\x02\"\xd9\x01\n" +
	"\x0fImageSourceSpec\x12\x1d\n" +
	"\tfile_path\x18\x01 \x01(\tH\x00R\bfilePath\x12\x12\n" +
	"\x03url\x18\x02 \x01(\tH\x00R\x03url\x12\x1d\n" +
	"\tvolume_id\x18\x03 \x01(\tH\x00R\bvolumeId\x12)\n" +
	"\x0fcontainer_image\x18\x04 \x01(\tH\x00R\x0econtainerImage\x12\x1a\n" +
	"\bchecksum\x18\x05 \x01(\tR\bchecksum\x12#\n" +
	"\rchecksum_type\x18\x06 \x01(\tR\fchecksumTypeB\b\n" +
	"\x06source\"\x93\x02\n" +
	"\x06OsInfo\x12?\n" +
	"\x06family\x18\x01 \x01(\x0e2'.limiquantix.storage.v1.OsInfo.OsFamilyR\x06family\x12\"\n" +
	"\fdistribution\x18\x02 \x01(\tR\fdistribution\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\"\n" +
	"\farchitecture\x18\x04 \x01(\tR\farchitecture\x12!\n" +
	"\fdefault_user\x18\x05 \x01(\tR\vdefaultUser\"C\n" +
	"\bOsFamily\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\t\n" +
	"\x05LINUX\x10\x01\x12\v\n" +
	"\aWINDOWS\x10\x02\x12\a\n" +
	"\x03BSD\x10\x03\x12\t\n" +
	"\x05OTHER\x10\x04\"\xf8\x01\n" +
	"\x11ImageRequirements\x12\x17\n" +
	"\amin_cpu\x18\x01 \x01(\rR\x06minCpu\x12$\n" +
	"\x0emin_memory_mib\x18\x02 \x01(\x04R\fminMemoryMib\x12 \n" +
	"\fmin_disk_gib\x18\x03 \x01(\x04R\n" +
	"minDiskGib\x12-\n" +
	"\x12supported_firmware\x18\x04 \x03(\tR\x11supportedFirmware\x120\n" +
	"\x14requires_secure_boot\x18\x05 \x01(\bR\x12requiresSecureBoot\x12!\n" +
	"\frequires_tpm\x18\x06 \x01(\bR\vrequiresTpm\"\x97\x03\n" +
	"\vImageStatus\x12?\n" +
	"\x05phase\x18\x01 \x01(\x0e2).limiquantix.storage.v1.ImageStatus.PhaseR\x05phase\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\x04R\tsizeBytes\x12,\n" +
	"\x12virtual_size_bytes\x18\x03 \x01(\x04R\x10virtualSizeBytes\x12)\n" +
	"\x10progress_percent\x18\x04 \x01(\rR\x0fprogressPercent\x12\x1a\n" +
	"\bchecksum\x18\x05 \x01(\tR\bchecksum\x12#\n" +
	"\rerror_message\x18\x06 \x01(\tR\ferrorMessage\x12&\n" +
	"\x0fstorage_pool_id\x18\a \x01(\tR\rstoragePoolId\"f\n" +
	"\x05Phase\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\x0f\n" +
	"\vDOWNLOADING\x10\x02\x12\x0e\n" +
	"\n" +
	"CONVERTING\x10\x03\x12\t\n" +
	"\x05READY\x10\x04\x12\t\n" +
	"\x05ERROR\x10\x05\x12\f\n" +
	"\bDELETING\x10\x06B\xf1\x01\n" +
	"\x1acom.limiquantix.storage.v1B\fStorageProtoP\x01ZKgithub.com/limiquantix/limiquantix/pkg/api/limiquantix/storage/v1;storagev1\xa2\x02\x03LSX\xaa\x02\x16limiquantix.Storage.V1\xca\x02\x16limiquantix\\Storage\\V1\xe2\x02\"limiquantix\\Storage\\V1\\GPBMetadata\xea\x02\x18limiquantix::Storage::V1b\x06proto3"

var (
	file_limiquantix_storage_v1_storage_proto_rawDescOnce sync.Once
	file_limiquantix_storage_v1_storage_proto_rawDescData []byte
)

func file_limiquantix_storage_v1_storage_proto_rawDescGZIP() []byte {
	file_limiquantix_storage_v1_storage_proto_rawDescOnce.Do(func() {
		file_limiquantix_storage_v1_storage_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_limiquantix_storage_v1_storage_proto_rawDesc), len(file_limiquantix_storage_v1_storage_proto_rawDesc)))
	})
	return file_limiquantix_storage_v1_storage_proto_rawDescData
}

var file_limiquantix_storage_v1_storage_proto_enumTypes = make([]protoimpl.EnumInfo, 14)
var file_limiquantix_storage_v1_storage_proto_msgTypes = make([]protoimpl.MessageInfo, 44)
var file_limiquantix_storage_v1_storage_proto_goTypes = []any{
	(StorageBackend_BackendType)(0),      // 0: limiquantix.storage.v1.StorageBackend.BackendType
	(VolumeDefaults_ProvisioningType)(0), // 1: limiquantix.storage.v1.VolumeDefaults.ProvisioningType
	(EncryptionConfig_KeyManagement)(0),  // 2: limiquantix.storage.v1.EncryptionConfig.KeyManagement
	(TieringConfig_TieringPolicy)(0),     // 3: limiquantix.storage.v1.TieringConfig.TieringPolicy
	(StoragePoolStatus_Phase)(0),         // 4: limiquantix.storage.v1.StoragePoolStatus.Phase
	(StorageHealth_Status)(0),            // 5: limiquantix.storage.v1.StorageHealth.Status
	(VolumeSpec_ProvisioningType)(0),     // 6: limiquantix.storage.v1.VolumeSpec.ProvisioningType
	(VolumeSpec_AccessMode)(0),           // 7: limiquantix.storage.v1.VolumeSpec.AccessMode
	(VolumeStatus_Phase)(0),              // 8: limiquantix.storage.v1.VolumeStatus.Phase
	(VolumeSnapshotStatus_Phase)(0),      // 9: limiquantix.storage.v1.VolumeSnapshotStatus.Phase
	(ImageSpec_Format)(0),                // 10: limiquantix.storage.v1.ImageSpec.Format
	(ImageSpec_Visibility)(0),            // 11: limiquantix.storage.v1.ImageSpec.Visibility
	(OsInfo_OsFamily)(0),                 // 12: limiquantix.storage.v1.OsInfo.OsFamily
	(ImageStatus_Phase)(0),               // 13: limiquantix.storage.v1.ImageStatus.Phase
	(*StoragePool)(nil),                  // 14: limiquantix.storage.v1.StoragePool
	(*StoragePoolSpec)(nil),              // 15: limiquantix.storage.v1.StoragePoolSpec
	(*StorageBackend)(nil),               // 16: limiquantix.storage.v1.StorageBackend
	(*CephConfig)(nil),                   // 17: limiquantix.storage.v1.CephConfig
	(*LocalLvmConfig)(nil),               // 18: limiquantix.storage.v1.LocalLvmConfig
	(*LocalDirConfig)(nil),               // 19: limiquantix.storage.v1.LocalDirConfig
	(*NfsConfig)(nil),                    // 20: limiquantix.storage.v1.NfsConfig
	(*IscsiConfig)(nil),                  // 21: limiquantix.storage.v1.IscsiConfig
	(*VolumeDefaults)(nil),               // 22: limiquantix.storage.v1.VolumeDefaults
	(*StorageQos)(nil),                   // 23: limiquantix.storage.v1.StorageQos
	(*EncryptionConfig)(nil),             // 24: limiquantix.storage.v1.EncryptionConfig
	(*ReplicationConfig)(nil),            // 25: limiquantix.storage.v1.ReplicationConfig
	(*ErasureCodingConfig)(nil),          // 26: limiquantix.storage.v1.ErasureCodingConfig
	(*TieringConfig)(nil),                // 27: limiquantix.storage.v1.TieringConfig
	(*StoragePoolStatus)(nil),            // 28: limiquantix.storage.v1.StoragePoolStatus
	(*StorageCapacity)(nil),              // 29: limiquantix.storage.v1.StorageCapacity
	(*StorageMetrics)(nil),               // 30: limiquantix.storage.v1.StorageMetrics
	(*StorageHealth)(nil),                // 31: limiquantix.storage.v1.StorageHealth
	(*HealthCheck)(nil),                  // 32: limiquantix.storage.v1.HealthCheck
	(*Volume)(nil),                       // 33: limiquantix.storage.v1.Volume
	(*VolumeSpec)(nil),                   // 34: limiquantix.storage.v1.VolumeSpec
	(*VolumeSource)(nil),                 // 35: limiquantix.storage.v1.VolumeSource
	(*EmptySource)(nil),                  // 36: limiquantix.storage.v1.EmptySource
	(*CloneSource)(nil),                  // 37: limiquantix.storage.v1.CloneSource
	(*SnapshotSource)(nil),               // 38: limiquantix.storage.v1.SnapshotSource
	(*ImageSource)(nil),                  // 39: limiquantix.storage.v1.ImageSource
	(*UrlSource)(nil),                    // 40: limiquantix.storage.v1.UrlSource
	(*VolumeQos)(nil),                    // 41: limiquantix.storage.v1.VolumeQos
	(*VolumeStatus)(nil),                 // 42: limiquantix.storage.v1.VolumeStatus
	(*VolumeUsage)(nil),                  // 43: limiquantix.storage.v1.VolumeUsage
	(*VolumeSnapshot)(nil),               // 44: limiquantix.storage.v1.VolumeSnapshot
	(*VolumeSnapshotSpec)(nil),           // 45: limiquantix.storage.v1.VolumeSnapshotSpec
	(*RetentionPolicy)(nil),              // 46: limiquantix.storage.v1.RetentionPolicy
	(*VolumeSnapshotStatus)(nil),         // 47: limiquantix.storage.v1.VolumeSnapshotStatus
	(*Image)(nil),                        // 48: limiquantix.storage.v1.Image
	(*ImageSpec)(nil),                    // 49: limiquantix.storage.v1.ImageSpec
	(*ImageSourceSpec)(nil),              // 50: limiquantix.storage.v1.ImageSourceSpec
	(*OsInfo)(nil),                       // 51: limiquantix.storage.v1.OsInfo
	(*ImageRequirements)(nil),            // 52: limiquantix.storage.v1.ImageRequirements
	(*ImageStatus)(nil),                  // 53: limiquantix.storage.v1.ImageStatus
	nil,                                  // 54: limiquantix.storage.v1.StoragePool.LabelsEntry
	nil,                                  // 55: limiquantix.storage.v1.Volume.LabelsEntry
	nil,                                  // 56: limiquantix.storage.v1.VolumeSnapshot.LabelsEntry
	nil,                                  // 57: limiquantix.storage.v1.Image.LabelsEntry
	(*timestamppb.Timestamp)(nil),        // 58: google.protobuf.Timestamp
}
var file_limiquantix_storage_v1_storage_proto_depIdxs = []int32{
	54, // 0: limiquantix.storage.v1.StoragePool.labels:type_name -> limiquantix.storage.v1.StoragePool.LabelsEntry
	15, // 1: limiquantix.storage.v1.StoragePool.spec:type_name -> limiquantix.storage.v1.StoragePoolSpec
	28, // 2: limiquantix.storage.v1.StoragePool.status:type_name -> limiquantix.storage.v1.StoragePoolStatus
	58, // 3: limiquantix.storage.v1.StoragePool.created_at:type_name -> google.protobuf.Timestamp
	58, // 4: limiquantix.storage.v1.StoragePool.updated_at:type_name -> google.protobuf.Timestamp
	16, // 5: limiquantix.storage.v1.StoragePoolSpec.backend:type_name -> limiquantix.storage.v1.StorageBackend
	22, // 6: limiquantix.storage.v1.StoragePoolSpec.defaults:type_name -> limiquantix.storage.v1.VolumeDefaults
	23, // 7: limiquantix.storage.v1.StoragePoolSpec.qos:type_name -> limiquantix.storage.v1.StorageQos
	24, // 8: limiquantix.storage.v1.StoragePoolSpec.encryption:type_name -> limiquantix.storage.v1.EncryptionConfig
	25, // 9: limiquantix.storage.v1.StoragePoolSpec.replication:type_name -> limiquantix.storage.v1.ReplicationConfig
	27, // 10: limiquantix.storage.v1.StoragePoolSpec.tiering:type_name -> limiquantix.storage.v1.TieringConfig
	0,  // 11: limiquantix.storage.v1.StorageBackend.type:type_name -> limiquantix.storage.v1.StorageBackend.BackendType
	17, // 12: limiquantix.storage.v1.StorageBackend.ceph:type_name -> limiquantix.storage.v1.CephConfig
	18, // 13: limiquantix.storage.v1.StorageBackend.local_lvm:type_name -> limiquantix.storage.v1.LocalLvmConfig
	19, // 14: limiquantix.storage.v1.StorageBackend.local_dir:type_name -> limiquantix.storage.v1.LocalDirConfig
	20, // 15: limiquantix.storage.v1.StorageBackend.nfs:type_name -> limiquantix.storage.v1.NfsConfig
	21, // 16: limiquantix.storage.v1.StorageBackend.iscsi:type_name -> limiquantix.storage.v1.IscsiConfig
	1,  // 17: limiquantix.storage.v1.VolumeDefaults.provisioning:type_name -> limiquantix.storage.v1.VolumeDefaults.ProvisioningType
	2,  // 18: limiquantix.storage.v1.EncryptionConfig.key_management:type_name -> limiquantix.storage.v1.EncryptionConfig.KeyManagement
	26, // 19: limiquantix.storage.v1.ReplicationConfig.erasure_coding:type_name -> limiquantix.storage.v1.ErasureCodingConfig
	3,  // 20: limiquantix.storage.v1.TieringConfig.policy:type_name -> limiquantix.storage.v1.TieringConfig.TieringPolicy
	4,  // 21: limiquantix.storage.v1.StoragePoolStatus.phase:type_name -> limiquantix.storage.v1.StoragePoolStatus.Phase
	29, // 22: limiquantix.storage.v1.StoragePoolStatus.capacity:type_name -> limiquantix.storage.v1.StorageCapacity
	30, // 23: limiquantix.storage.v1.StoragePoolStatus.metrics:type_name -> limiquantix.storage.v1.StorageMetrics
	31, // 24: limiquantix.storage.v1.StoragePoolStatus.health:type_name -> limiquantix.storage.v1.StorageHealth
	5,  // 25: limiquantix.storage.v1.StorageHealth.status:type_name -> limiquantix.storage.v1.StorageHealth.Status
	32, // 26: limiquantix.storage.v1.StorageHealth.checks:type_name -> limiquantix.storage.v1.HealthCheck
	55, // 27: limiquantix.storage.v1.Volume.labels:type_name -> limiquantix.storage.v1.Volume.LabelsEntry
	34, // 28: limiquantix.storage.v1.Volume.spec:type_name -> limiquantix.storage.v1.VolumeSpec
	42, // 29: limiquantix.storage.v1.Volume.status:type_name -> limiquantix.storage.v1.VolumeStatus
	58, // 30: limiquantix.storage.v1.Volume.created_at:type_name -> google.protobuf.Timestamp
	58, // 31: limiquantix.storage.v1.Volume.updated_at:type_name -> google.protobuf.Timestamp
	6,  // 32: limiquantix.storage.v1.VolumeSpec.provisioning:type_name -> limiquantix.storage.v1.VolumeSpec.ProvisioningType
	35, // 33: limiquantix.storage.v1.VolumeSpec.source:type_name -> limiquantix.storage.v1.VolumeSource
	41, // 34: limiquantix.storage.v1.VolumeSpec.qos:type_name -> limiquantix.storage.v1.VolumeQos
	24, // 35: limiquantix.storage.v1.VolumeSpec.encryption:type_name -> limiquantix.storage.v1.EncryptionConfig
	7,  // 36: limiquantix.storage.v1.VolumeSpec.access_mode:type_name -> limiquantix.storage.v1.VolumeSpec.AccessMode
	36, // 37: limiquantix.storage.v1.VolumeSource.empty:type_name -> limiquantix.storage.v1.EmptySource
	37, // 38: limiquantix.storage.v1.VolumeSource.clone:type_name -> limiquantix.storage.v1.CloneSource
	38, // 39: limiquantix.storage.v1.VolumeSource.snapshot:type_name -> limiquantix.storage.v1.SnapshotSource
	39, // 40: limiquantix.storage.v1.VolumeSource.image:type_name -> limiquantix.storage.v1.ImageSource
	40, // 41: limiquantix.storage.v1.VolumeSource.url:type_name -> limiquantix.storage.v1.UrlSource
	8,  // 42: limiquantix.storage.v1.VolumeStatus.phase:type_name -> limiquantix.storage.v1.VolumeStatus.Phase
	43, // 43: limiquantix.storage.v1.VolumeStatus.usage:type_name -> limiquantix.storage.v1.VolumeUsage
	56, // 44: limiquantix.storage.v1.VolumeSnapshot.labels:type_name -> limiquantix.storage.v1.VolumeSnapshot.LabelsEntry
	45, // 45: limiquantix.storage.v1.VolumeSnapshot.spec:type_name -> limiquantix.storage.v1.VolumeSnapshotSpec
	47, // 46: limiquantix.storage.v1.VolumeSnapshot.status:type_name -> limiquantix.storage.v1.VolumeSnapshotStatus
	58, // 47: limiquantix.storage.v1.VolumeSnapshot.created_at:type_name -> google.protobuf.Timestamp
	46, // 48: limiquantix.storage.v1.VolumeSnapshotSpec.retention:type_name -> limiquantix.storage.v1.RetentionPolicy
	58, // 49: limiquantix.storage.v1.RetentionPolicy.expires_at:type_name -> google.protobuf.Timestamp
	9,  // 50: limiquantix.storage.v1.VolumeSnapshotStatus.phase:type_name -> limiquantix.storage.v1.VolumeSnapshotStatus.Phase
	57, // 51: limiquantix.storage.v1.Image.labels:type_name -> limiquantix.storage.v1.Image.LabelsEntry
	49, // 52: limiquantix.storage.v1.Image.spec:type_name -> limiquantix.storage.v1.ImageSpec
	53, // 53: limiquantix.storage.v1.Image.status:type_name -> limiquantix.storage.v1.ImageStatus
	58, // 54: limiquantix.storage.v1.Image.created_at:type_name -> google.protobuf.Timestamp
	58, // 55: limiquantix.storage.v1.Image.updated_at:type_name -> google.protobuf.Timestamp
	39, // 56: limiquantix.storage.v1.ImageSpec.source:type_name -> limiquantix.storage.v1.ImageSource
	51, // 57: limiquantix.storage.v1.ImageSpec.os:type_name -> limiquantix.storage.v1.OsInfo
	52, // 58: limiquantix.storage.v1.ImageSpec.requirements:type_name -> limiquantix.storage.v1.ImageRequirements
	10, // 59: limiquantix.storage.v1.ImageSpec.format:type_name -> limiquantix.storage.v1.ImageSpec.Format
	11, // 60: limiquantix.storage.v1.ImageSpec.visibility:type_name -> limiquantix.storage.v1.ImageSpec.Visibility
	12, // 61: limiquantix.storage.v1.OsInfo.family:type_name -> limiquantix.storage.v1.OsInfo.OsFamily
	13, // 62: limiquantix.storage.v1.ImageStatus.phase:type_name -> limiquantix.storage.v1.ImageStatus.Phase
	63, // [63:63] is the sub-list for method output_type
	63, // [63:63] is the sub-list for method input_type
	63, // [63:63] is the sub-list for extension type_name
	63, // [63:63] is the sub-list for extension extendee
	0,  // [0:63] is the sub-list for field type_name
}

func init() { file_limiquantix_storage_v1_storage_proto_init() }
func file_limiquantix_storage_v1_storage_proto_init() {
	if File_limiquantix_storage_v1_storage_proto != nil {
		return
	}
	file_limiquantix_storage_v1_storage_proto_msgTypes[2].OneofWrappers = []any{
		(*StorageBackend_Ceph)(nil),
		(*StorageBackend_LocalLvm)(nil),
		(*StorageBackend_LocalDir)(nil),
		(*StorageBackend_Nfs)(nil),
		(*StorageBackend_Iscsi)(nil),
	}
	file_limiquantix_storage_v1_storage_proto_msgTypes[21].OneofWrappers = []any{
		(*VolumeSource_Empty)(nil),
		(*VolumeSource_Clone)(nil),
		(*VolumeSource_Snapshot)(nil),
		(*VolumeSource_Image)(nil),
		(*VolumeSource_Url)(nil),
	}
	file_limiquantix_storage_v1_storage_proto_msgTypes[36].OneofWrappers = []any{
		(*ImageSourceSpec_FilePath)(nil),
		(*ImageSourceSpec_Url)(nil),
		(*ImageSourceSpec_VolumeId)(nil),
		(*ImageSourceSpec_ContainerImage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_limiquantix_storage_v1_storage_proto_rawDesc), len(file_limiquantix_storage_v1_storage_proto_rawDesc)),
			NumEnums:      14,
			NumMessages:   44,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_limiquantix_storage_v1_storage_proto_goTypes,
		DependencyIndexes: file_limiquantix_storage_v1_storage_proto_depIdxs,
		EnumInfos:         file_limiquantix_storage_v1_storage_proto_enumTypes,
		MessageInfos:      file_limiquantix_storage_v1_storage_proto_msgTypes,
	}.Build()
	File_limiquantix_storage_v1_storage_proto = out.File
	file_limiquantix_storage_v1_storage_proto_goTypes = nil
	file_limiquantix_storage_v1_storage_proto_depIdxs = nil
}
