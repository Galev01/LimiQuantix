// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: Quantixkvm/node/v1/node_daemon.proto

package nodev1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NodeDaemonService_HealthCheck_FullMethodName      = "/Quantixkvm.node.v1.NodeDaemonService/HealthCheck"
	NodeDaemonService_GetNodeInfo_FullMethodName      = "/Quantixkvm.node.v1.NodeDaemonService/GetNodeInfo"
	NodeDaemonService_CreateVM_FullMethodName         = "/Quantixkvm.node.v1.NodeDaemonService/CreateVM"
	NodeDaemonService_StartVM_FullMethodName          = "/Quantixkvm.node.v1.NodeDaemonService/StartVM"
	NodeDaemonService_StopVM_FullMethodName           = "/Quantixkvm.node.v1.NodeDaemonService/StopVM"
	NodeDaemonService_ForceStopVM_FullMethodName      = "/Quantixkvm.node.v1.NodeDaemonService/ForceStopVM"
	NodeDaemonService_RebootVM_FullMethodName         = "/Quantixkvm.node.v1.NodeDaemonService/RebootVM"
	NodeDaemonService_PauseVM_FullMethodName          = "/Quantixkvm.node.v1.NodeDaemonService/PauseVM"
	NodeDaemonService_ResumeVM_FullMethodName         = "/Quantixkvm.node.v1.NodeDaemonService/ResumeVM"
	NodeDaemonService_DeleteVM_FullMethodName         = "/Quantixkvm.node.v1.NodeDaemonService/DeleteVM"
	NodeDaemonService_GetVMStatus_FullMethodName      = "/Quantixkvm.node.v1.NodeDaemonService/GetVMStatus"
	NodeDaemonService_ListVMs_FullMethodName          = "/Quantixkvm.node.v1.NodeDaemonService/ListVMs"
	NodeDaemonService_GetConsole_FullMethodName       = "/Quantixkvm.node.v1.NodeDaemonService/GetConsole"
	NodeDaemonService_CreateSnapshot_FullMethodName   = "/Quantixkvm.node.v1.NodeDaemonService/CreateSnapshot"
	NodeDaemonService_RevertSnapshot_FullMethodName   = "/Quantixkvm.node.v1.NodeDaemonService/RevertSnapshot"
	NodeDaemonService_DeleteSnapshot_FullMethodName   = "/Quantixkvm.node.v1.NodeDaemonService/DeleteSnapshot"
	NodeDaemonService_ListSnapshots_FullMethodName    = "/Quantixkvm.node.v1.NodeDaemonService/ListSnapshots"
	NodeDaemonService_AttachDisk_FullMethodName       = "/Quantixkvm.node.v1.NodeDaemonService/AttachDisk"
	NodeDaemonService_DetachDisk_FullMethodName       = "/Quantixkvm.node.v1.NodeDaemonService/DetachDisk"
	NodeDaemonService_AttachNIC_FullMethodName        = "/Quantixkvm.node.v1.NodeDaemonService/AttachNIC"
	NodeDaemonService_DetachNIC_FullMethodName        = "/Quantixkvm.node.v1.NodeDaemonService/DetachNIC"
	NodeDaemonService_PrepareMigration_FullMethodName = "/Quantixkvm.node.v1.NodeDaemonService/PrepareMigration"
	NodeDaemonService_ReceiveMigration_FullMethodName = "/Quantixkvm.node.v1.NodeDaemonService/ReceiveMigration"
	NodeDaemonService_MigrateVM_FullMethodName        = "/Quantixkvm.node.v1.NodeDaemonService/MigrateVM"
	NodeDaemonService_StreamMetrics_FullMethodName    = "/Quantixkvm.node.v1.NodeDaemonService/StreamMetrics"
	NodeDaemonService_StreamEvents_FullMethodName     = "/Quantixkvm.node.v1.NodeDaemonService/StreamEvents"
)

// NodeDaemonServiceClient is the client API for NodeDaemonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeDaemonServiceClient interface {
	// Health check endpoint
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Get node information and capabilities
	GetNodeInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	// Create a new VM (does not start it)
	CreateVM(ctx context.Context, in *CreateVMOnNodeRequest, opts ...grpc.CallOption) (*CreateVMOnNodeResponse, error)
	// Start a VM
	StartVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Stop a VM gracefully (with timeout)
	StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Force stop a VM (power off)
	ForceStopVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Reboot a VM
	RebootVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Pause a VM (freeze execution)
	PauseVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Resume a paused VM
	ResumeVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete a VM (must be stopped first)
	DeleteVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get status of a specific VM
	GetVMStatus(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*VMStatusResponse, error)
	// List all VMs on this node
	ListVMs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListVMsOnNodeResponse, error)
	// Get console connection information (VNC/SPICE)
	GetConsole(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*ConsoleInfoResponse, error)
	// Create a snapshot
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error)
	// Revert to a snapshot
	RevertSnapshot(ctx context.Context, in *RevertSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete a snapshot
	DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List all snapshots for a VM
	ListSnapshots(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error)
	// Attach a disk to a running VM
	AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detach a disk from a running VM
	DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Attach a network interface to a running VM
	AttachNIC(ctx context.Context, in *AttachNICRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detach a network interface from a running VM
	DetachNIC(ctx context.Context, in *DetachNICRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Prepare this node to receive a migrating VM
	PrepareMigration(ctx context.Context, in *PrepareMigrationRequest, opts ...grpc.CallOption) (*MigrationToken, error)
	// Receive a migrating VM
	ReceiveMigration(ctx context.Context, in *MigrationToken, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Migrate a VM to another node (streaming progress)
	MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MigrationProgress], error)
	// Stream node and VM metrics
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeMetrics], error)
	// Stream node events (VM started, stopped, crashed, etc.)
	StreamEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeEvent], error)
}

type nodeDaemonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeDaemonServiceClient(cc grpc.ClientConnInterface) NodeDaemonServiceClient {
	return &nodeDaemonServiceClient{cc}
}

func (c *nodeDaemonServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) GetNodeInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_GetNodeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) CreateVM(ctx context.Context, in *CreateVMOnNodeRequest, opts ...grpc.CallOption) (*CreateVMOnNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVMOnNodeResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_CreateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) StartVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_StartVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_StopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) ForceStopVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_ForceStopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) RebootVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_RebootVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) PauseVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_PauseVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) ResumeVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_ResumeVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) DeleteVM(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_DeleteVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) GetVMStatus(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*VMStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMStatusResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_GetVMStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) ListVMs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListVMsOnNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsOnNodeResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) GetConsole(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*ConsoleInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsoleInfoResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_GetConsole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SnapshotResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_CreateSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) RevertSnapshot(ctx context.Context, in *RevertSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_RevertSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_DeleteSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) ListSnapshots(ctx context.Context, in *VMIdRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSnapshotsResponse)
	err := c.cc.Invoke(ctx, NodeDaemonService_ListSnapshots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_AttachDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_DetachDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) AttachNIC(ctx context.Context, in *AttachNICRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_AttachNIC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) DetachNIC(ctx context.Context, in *DetachNICRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_DetachNIC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) PrepareMigration(ctx context.Context, in *PrepareMigrationRequest, opts ...grpc.CallOption) (*MigrationToken, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrationToken)
	err := c.cc.Invoke(ctx, NodeDaemonService_PrepareMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) ReceiveMigration(ctx context.Context, in *MigrationToken, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeDaemonService_ReceiveMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeDaemonServiceClient) MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MigrationProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NodeDaemonService_ServiceDesc.Streams[0], NodeDaemonService_MigrateVM_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MigrateVMRequest, MigrationProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_MigrateVMClient = grpc.ServerStreamingClient[MigrationProgress]

func (c *nodeDaemonServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeMetrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NodeDaemonService_ServiceDesc.Streams[1], NodeDaemonService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, NodeMetrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_StreamMetricsClient = grpc.ServerStreamingClient[NodeMetrics]

func (c *nodeDaemonServiceClient) StreamEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NodeDaemonService_ServiceDesc.Streams[2], NodeDaemonService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, NodeEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_StreamEventsClient = grpc.ServerStreamingClient[NodeEvent]

// NodeDaemonServiceServer is the server API for NodeDaemonService service.
// All implementations should embed UnimplementedNodeDaemonServiceServer
// for forward compatibility.
type NodeDaemonServiceServer interface {
	// Health check endpoint
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Get node information and capabilities
	GetNodeInfo(context.Context, *emptypb.Empty) (*NodeInfoResponse, error)
	// Create a new VM (does not start it)
	CreateVM(context.Context, *CreateVMOnNodeRequest) (*CreateVMOnNodeResponse, error)
	// Start a VM
	StartVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Stop a VM gracefully (with timeout)
	StopVM(context.Context, *StopVMRequest) (*emptypb.Empty, error)
	// Force stop a VM (power off)
	ForceStopVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Reboot a VM
	RebootVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Pause a VM (freeze execution)
	PauseVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Resume a paused VM
	ResumeVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Delete a VM (must be stopped first)
	DeleteVM(context.Context, *VMIdRequest) (*emptypb.Empty, error)
	// Get status of a specific VM
	GetVMStatus(context.Context, *VMIdRequest) (*VMStatusResponse, error)
	// List all VMs on this node
	ListVMs(context.Context, *emptypb.Empty) (*ListVMsOnNodeResponse, error)
	// Get console connection information (VNC/SPICE)
	GetConsole(context.Context, *VMIdRequest) (*ConsoleInfoResponse, error)
	// Create a snapshot
	CreateSnapshot(context.Context, *CreateSnapshotRequest) (*SnapshotResponse, error)
	// Revert to a snapshot
	RevertSnapshot(context.Context, *RevertSnapshotRequest) (*emptypb.Empty, error)
	// Delete a snapshot
	DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error)
	// List all snapshots for a VM
	ListSnapshots(context.Context, *VMIdRequest) (*ListSnapshotsResponse, error)
	// Attach a disk to a running VM
	AttachDisk(context.Context, *AttachDiskRequest) (*emptypb.Empty, error)
	// Detach a disk from a running VM
	DetachDisk(context.Context, *DetachDiskRequest) (*emptypb.Empty, error)
	// Attach a network interface to a running VM
	AttachNIC(context.Context, *AttachNICRequest) (*emptypb.Empty, error)
	// Detach a network interface from a running VM
	DetachNIC(context.Context, *DetachNICRequest) (*emptypb.Empty, error)
	// Prepare this node to receive a migrating VM
	PrepareMigration(context.Context, *PrepareMigrationRequest) (*MigrationToken, error)
	// Receive a migrating VM
	ReceiveMigration(context.Context, *MigrationToken) (*emptypb.Empty, error)
	// Migrate a VM to another node (streaming progress)
	MigrateVM(*MigrateVMRequest, grpc.ServerStreamingServer[MigrationProgress]) error
	// Stream node and VM metrics
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[NodeMetrics]) error
	// Stream node events (VM started, stopped, crashed, etc.)
	StreamEvents(*emptypb.Empty, grpc.ServerStreamingServer[NodeEvent]) error
}

// UnimplementedNodeDaemonServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeDaemonServiceServer struct{}

func (UnimplementedNodeDaemonServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedNodeDaemonServiceServer) GetNodeInfo(context.Context, *emptypb.Empty) (*NodeInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedNodeDaemonServiceServer) CreateVM(context.Context, *CreateVMOnNodeRequest) (*CreateVMOnNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) StartVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) StopVM(context.Context, *StopVMRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method StopVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) ForceStopVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ForceStopVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) RebootVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RebootVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) PauseVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) ResumeVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) DeleteVM(context.Context, *VMIdRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) GetVMStatus(context.Context, *VMIdRequest) (*VMStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVMStatus not implemented")
}
func (UnimplementedNodeDaemonServiceServer) ListVMs(context.Context, *emptypb.Empty) (*ListVMsOnNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedNodeDaemonServiceServer) GetConsole(context.Context, *VMIdRequest) (*ConsoleInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConsole not implemented")
}
func (UnimplementedNodeDaemonServiceServer) CreateSnapshot(context.Context, *CreateSnapshotRequest) (*SnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedNodeDaemonServiceServer) RevertSnapshot(context.Context, *RevertSnapshotRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RevertSnapshot not implemented")
}
func (UnimplementedNodeDaemonServiceServer) DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSnapshot not implemented")
}
func (UnimplementedNodeDaemonServiceServer) ListSnapshots(context.Context, *VMIdRequest) (*ListSnapshotsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSnapshots not implemented")
}
func (UnimplementedNodeDaemonServiceServer) AttachDisk(context.Context, *AttachDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachDisk not implemented")
}
func (UnimplementedNodeDaemonServiceServer) DetachDisk(context.Context, *DetachDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachDisk not implemented")
}
func (UnimplementedNodeDaemonServiceServer) AttachNIC(context.Context, *AttachNICRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachNIC not implemented")
}
func (UnimplementedNodeDaemonServiceServer) DetachNIC(context.Context, *DetachNICRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachNIC not implemented")
}
func (UnimplementedNodeDaemonServiceServer) PrepareMigration(context.Context, *PrepareMigrationRequest) (*MigrationToken, error) {
	return nil, status.Error(codes.Unimplemented, "method PrepareMigration not implemented")
}
func (UnimplementedNodeDaemonServiceServer) ReceiveMigration(context.Context, *MigrationToken) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReceiveMigration not implemented")
}
func (UnimplementedNodeDaemonServiceServer) MigrateVM(*MigrateVMRequest, grpc.ServerStreamingServer[MigrationProgress]) error {
	return status.Error(codes.Unimplemented, "method MigrateVM not implemented")
}
func (UnimplementedNodeDaemonServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[NodeMetrics]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedNodeDaemonServiceServer) StreamEvents(*emptypb.Empty, grpc.ServerStreamingServer[NodeEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedNodeDaemonServiceServer) testEmbeddedByValue() {}

// UnsafeNodeDaemonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeDaemonServiceServer will
// result in compilation errors.
type UnsafeNodeDaemonServiceServer interface {
	mustEmbedUnimplementedNodeDaemonServiceServer()
}

func RegisterNodeDaemonServiceServer(s grpc.ServiceRegistrar, srv NodeDaemonServiceServer) {
	// If the following call panics, it indicates UnimplementedNodeDaemonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeDaemonService_ServiceDesc, srv)
}

func _NodeDaemonService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_GetNodeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).GetNodeInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_CreateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMOnNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).CreateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_CreateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).CreateVM(ctx, req.(*CreateVMOnNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).StartVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_StartVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).StartVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_StopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).StopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_StopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).StopVM(ctx, req.(*StopVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_ForceStopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).ForceStopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_ForceStopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).ForceStopVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_RebootVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).RebootVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_RebootVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).RebootVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_PauseVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).PauseVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_PauseVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).PauseVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_ResumeVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).ResumeVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_ResumeVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).ResumeVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_DeleteVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).DeleteVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_DeleteVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).DeleteVM(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_GetVMStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).GetVMStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_GetVMStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).GetVMStatus(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).ListVMs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_GetConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).GetConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_GetConsole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).GetConsole(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_CreateSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_RevertSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevertSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).RevertSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_RevertSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).RevertSnapshot(ctx, req.(*RevertSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_DeleteSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).DeleteSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_DeleteSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).DeleteSnapshot(ctx, req.(*DeleteSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_ListSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).ListSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_ListSnapshots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).ListSnapshots(ctx, req.(*VMIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_AttachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).AttachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_AttachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).AttachDisk(ctx, req.(*AttachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_DetachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).DetachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_DetachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).DetachDisk(ctx, req.(*DetachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_AttachNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNICRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).AttachNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_AttachNIC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).AttachNIC(ctx, req.(*AttachNICRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_DetachNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNICRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).DetachNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_DetachNIC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).DetachNIC(ctx, req.(*DetachNICRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_PrepareMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).PrepareMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_PrepareMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).PrepareMigration(ctx, req.(*PrepareMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_ReceiveMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrationToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeDaemonServiceServer).ReceiveMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeDaemonService_ReceiveMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeDaemonServiceServer).ReceiveMigration(ctx, req.(*MigrationToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeDaemonService_MigrateVM_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MigrateVMRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeDaemonServiceServer).MigrateVM(m, &grpc.GenericServerStream[MigrateVMRequest, MigrationProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_MigrateVMServer = grpc.ServerStreamingServer[MigrationProgress]

func _NodeDaemonService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeDaemonServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, NodeMetrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_StreamMetricsServer = grpc.ServerStreamingServer[NodeMetrics]

func _NodeDaemonService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeDaemonServiceServer).StreamEvents(m, &grpc.GenericServerStream[emptypb.Empty, NodeEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeDaemonService_StreamEventsServer = grpc.ServerStreamingServer[NodeEvent]

// NodeDaemonService_ServiceDesc is the grpc.ServiceDesc for NodeDaemonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeDaemonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Quantixkvm.node.v1.NodeDaemonService",
	HandlerType: (*NodeDaemonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _NodeDaemonService_HealthCheck_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _NodeDaemonService_GetNodeInfo_Handler,
		},
		{
			MethodName: "CreateVM",
			Handler:    _NodeDaemonService_CreateVM_Handler,
		},
		{
			MethodName: "StartVM",
			Handler:    _NodeDaemonService_StartVM_Handler,
		},
		{
			MethodName: "StopVM",
			Handler:    _NodeDaemonService_StopVM_Handler,
		},
		{
			MethodName: "ForceStopVM",
			Handler:    _NodeDaemonService_ForceStopVM_Handler,
		},
		{
			MethodName: "RebootVM",
			Handler:    _NodeDaemonService_RebootVM_Handler,
		},
		{
			MethodName: "PauseVM",
			Handler:    _NodeDaemonService_PauseVM_Handler,
		},
		{
			MethodName: "ResumeVM",
			Handler:    _NodeDaemonService_ResumeVM_Handler,
		},
		{
			MethodName: "DeleteVM",
			Handler:    _NodeDaemonService_DeleteVM_Handler,
		},
		{
			MethodName: "GetVMStatus",
			Handler:    _NodeDaemonService_GetVMStatus_Handler,
		},
		{
			MethodName: "ListVMs",
			Handler:    _NodeDaemonService_ListVMs_Handler,
		},
		{
			MethodName: "GetConsole",
			Handler:    _NodeDaemonService_GetConsole_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _NodeDaemonService_CreateSnapshot_Handler,
		},
		{
			MethodName: "RevertSnapshot",
			Handler:    _NodeDaemonService_RevertSnapshot_Handler,
		},
		{
			MethodName: "DeleteSnapshot",
			Handler:    _NodeDaemonService_DeleteSnapshot_Handler,
		},
		{
			MethodName: "ListSnapshots",
			Handler:    _NodeDaemonService_ListSnapshots_Handler,
		},
		{
			MethodName: "AttachDisk",
			Handler:    _NodeDaemonService_AttachDisk_Handler,
		},
		{
			MethodName: "DetachDisk",
			Handler:    _NodeDaemonService_DetachDisk_Handler,
		},
		{
			MethodName: "AttachNIC",
			Handler:    _NodeDaemonService_AttachNIC_Handler,
		},
		{
			MethodName: "DetachNIC",
			Handler:    _NodeDaemonService_DetachNIC_Handler,
		},
		{
			MethodName: "PrepareMigration",
			Handler:    _NodeDaemonService_PrepareMigration_Handler,
		},
		{
			MethodName: "ReceiveMigration",
			Handler:    _NodeDaemonService_ReceiveMigration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MigrateVM",
			Handler:       _NodeDaemonService_MigrateVM_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMetrics",
			Handler:       _NodeDaemonService_StreamMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamEvents",
			Handler:       _NodeDaemonService_StreamEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "Quantixkvm/node/v1/node_daemon.proto",
}
