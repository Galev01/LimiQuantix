// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: limiquantix/compute/v1/vm_service.proto

package computev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VMService_CreateVM_FullMethodName          = "/limiquantix.compute.v1.VMService/CreateVM"
	VMService_GetVM_FullMethodName             = "/limiquantix.compute.v1.VMService/GetVM"
	VMService_ListVMs_FullMethodName           = "/limiquantix.compute.v1.VMService/ListVMs"
	VMService_UpdateVM_FullMethodName          = "/limiquantix.compute.v1.VMService/UpdateVM"
	VMService_DeleteVM_FullMethodName          = "/limiquantix.compute.v1.VMService/DeleteVM"
	VMService_StartVM_FullMethodName           = "/limiquantix.compute.v1.VMService/StartVM"
	VMService_StopVM_FullMethodName            = "/limiquantix.compute.v1.VMService/StopVM"
	VMService_RebootVM_FullMethodName          = "/limiquantix.compute.v1.VMService/RebootVM"
	VMService_PauseVM_FullMethodName           = "/limiquantix.compute.v1.VMService/PauseVM"
	VMService_ResumeVM_FullMethodName          = "/limiquantix.compute.v1.VMService/ResumeVM"
	VMService_SuspendVM_FullMethodName         = "/limiquantix.compute.v1.VMService/SuspendVM"
	VMService_CreateSnapshot_FullMethodName    = "/limiquantix.compute.v1.VMService/CreateSnapshot"
	VMService_ListSnapshots_FullMethodName     = "/limiquantix.compute.v1.VMService/ListSnapshots"
	VMService_RevertToSnapshot_FullMethodName  = "/limiquantix.compute.v1.VMService/RevertToSnapshot"
	VMService_DeleteSnapshot_FullMethodName    = "/limiquantix.compute.v1.VMService/DeleteSnapshot"
	VMService_MigrateVM_FullMethodName         = "/limiquantix.compute.v1.VMService/MigrateVM"
	VMService_GetConsole_FullMethodName        = "/limiquantix.compute.v1.VMService/GetConsole"
	VMService_CloneVM_FullMethodName           = "/limiquantix.compute.v1.VMService/CloneVM"
	VMService_ConvertToTemplate_FullMethodName = "/limiquantix.compute.v1.VMService/ConvertToTemplate"
	VMService_AttachDisk_FullMethodName        = "/limiquantix.compute.v1.VMService/AttachDisk"
	VMService_DetachDisk_FullMethodName        = "/limiquantix.compute.v1.VMService/DetachDisk"
	VMService_ResizeDisk_FullMethodName        = "/limiquantix.compute.v1.VMService/ResizeDisk"
	VMService_AttachNIC_FullMethodName         = "/limiquantix.compute.v1.VMService/AttachNIC"
	VMService_DetachNIC_FullMethodName         = "/limiquantix.compute.v1.VMService/DetachNIC"
	VMService_ListVMEvents_FullMethodName      = "/limiquantix.compute.v1.VMService/ListVMEvents"
	VMService_WatchVM_FullMethodName           = "/limiquantix.compute.v1.VMService/WatchVM"
	VMService_StreamMetrics_FullMethodName     = "/limiquantix.compute.v1.VMService/StreamMetrics"
	VMService_WatchVMs_FullMethodName          = "/limiquantix.compute.v1.VMService/WatchVMs"
	VMService_PingAgent_FullMethodName         = "/limiquantix.compute.v1.VMService/PingAgent"
	VMService_ExecuteScript_FullMethodName     = "/limiquantix.compute.v1.VMService/ExecuteScript"
	VMService_ReadGuestFile_FullMethodName     = "/limiquantix.compute.v1.VMService/ReadGuestFile"
	VMService_WriteGuestFile_FullMethodName    = "/limiquantix.compute.v1.VMService/WriteGuestFile"
	VMService_GuestShutdown_FullMethodName     = "/limiquantix.compute.v1.VMService/GuestShutdown"
)

// VMServiceClient is the client API for VMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VMService provides CRUD operations and lifecycle management for Virtual Machines.
type VMServiceClient interface {
	// CreateVM creates a new virtual machine.
	// The VM will be in STOPPED state after creation unless start_on_create is true.
	CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// GetVM retrieves a virtual machine by ID.
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ListVMs returns a paginated list of virtual machines.
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	// UpdateVM updates a virtual machine's specification.
	// Some changes require the VM to be stopped (e.g., CPU/memory changes).
	UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DeleteVM permanently deletes a virtual machine.
	// The VM must be stopped first. Use force=true to stop and delete.
	DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// StartVM powers on a virtual machine.
	StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// StopVM powers off a virtual machine.
	// Use force=true for hard power off (like pulling the power cord).
	StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// RebootVM restarts a virtual machine.
	RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// PauseVM suspends VM execution (freezes in place).
	PauseVM(ctx context.Context, in *PauseVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ResumeVM resumes a paused virtual machine.
	ResumeVM(ctx context.Context, in *ResumeVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// SuspendVM saves VM state to disk and stops (hibernate).
	SuspendVM(ctx context.Context, in *SuspendVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// CreateSnapshot creates a point-in-time snapshot.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error)
	// ListSnapshots returns all snapshots for a VM.
	ListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error)
	// RevertToSnapshot reverts the VM to a previous snapshot.
	RevertToSnapshot(ctx context.Context, in *RevertToSnapshotRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DeleteSnapshot removes a snapshot.
	DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// MigrateVM live-migrates a VM to another node.
	MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (*MigrateVMResponse, error)
	// GetConsole returns connection info for VNC/SPICE console.
	GetConsole(ctx context.Context, in *GetConsoleRequest, opts ...grpc.CallOption) (*ConsoleInfo, error)
	// CloneVM creates a copy of a virtual machine.
	CloneVM(ctx context.Context, in *CloneVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ConvertToTemplate marks a VM as a template.
	ConvertToTemplate(ctx context.Context, in *ConvertToTemplateRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// AttachDisk attaches a new disk to a VM (hot-plug if running).
	AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DetachDisk removes a disk from a VM (hot-unplug if running).
	DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ResizeDisk expands a disk attached to a VM.
	ResizeDisk(ctx context.Context, in *ResizeDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// AttachNIC attaches a new network interface to a VM (hot-plug if running).
	AttachNIC(ctx context.Context, in *AttachNICRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DetachNIC removes a network interface from a VM (hot-unplug if running).
	DetachNIC(ctx context.Context, in *DetachNICRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ListVMEvents returns events for a VM.
	ListVMEvents(ctx context.Context, in *ListVMEventsRequest, opts ...grpc.CallOption) (*ListVMEventsResponse, error)
	// WatchVM streams real-time updates for a VM.
	WatchVM(ctx context.Context, in *WatchVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VirtualMachine], error)
	// StreamMetrics streams real-time performance metrics.
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResourceUsage], error)
	// WatchVMs streams updates for all VMs (for Host UI dashboard).
	WatchVMs(ctx context.Context, in *WatchVMsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VMUpdate], error)
	// PingAgent checks if the guest agent is available and responding.
	PingAgent(ctx context.Context, in *PingAgentRequest, opts ...grpc.CallOption) (*PingAgentResponse, error)
	// ExecuteScript runs a command inside the VM via the guest agent.
	ExecuteScript(ctx context.Context, in *ExecuteScriptRequest, opts ...grpc.CallOption) (*ExecuteScriptResponse, error)
	// ReadGuestFile reads a file from inside the VM.
	ReadGuestFile(ctx context.Context, in *ReadGuestFileRequest, opts ...grpc.CallOption) (*ReadGuestFileResponse, error)
	// WriteGuestFile writes a file to the VM.
	WriteGuestFile(ctx context.Context, in *WriteGuestFileRequest, opts ...grpc.CallOption) (*WriteGuestFileResponse, error)
	// GuestShutdown requests the guest agent to gracefully shutdown/reboot.
	GuestShutdown(ctx context.Context, in *GuestShutdownRequest, opts ...grpc.CallOption) (*GuestShutdownResponse, error)
}

type vMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVMServiceClient(cc grpc.ClientConnInterface) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_CreateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_GetVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_UpdateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeleteVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_StartVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_StopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_RebootVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) PauseVM(ctx context.Context, in *PauseVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_PauseVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResumeVM(ctx context.Context, in *ResumeVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_ResumeVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) SuspendVM(ctx context.Context, in *SuspendVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_SuspendVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Snapshot)
	err := c.cc.Invoke(ctx, VMService_CreateSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSnapshotsResponse)
	err := c.cc.Invoke(ctx, VMService_ListSnapshots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) RevertToSnapshot(ctx context.Context, in *RevertToSnapshotRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_RevertToSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeleteSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (*MigrateVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateVMResponse)
	err := c.cc.Invoke(ctx, VMService_MigrateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetConsole(ctx context.Context, in *GetConsoleRequest, opts ...grpc.CallOption) (*ConsoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsoleInfo)
	err := c.cc.Invoke(ctx, VMService_GetConsole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CloneVM(ctx context.Context, in *CloneVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_CloneVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ConvertToTemplate(ctx context.Context, in *ConvertToTemplateRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_ConvertToTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_AttachDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_DetachDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResizeDisk(ctx context.Context, in *ResizeDiskRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_ResizeDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachNIC(ctx context.Context, in *AttachNICRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_AttachNIC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachNIC(ctx context.Context, in *DetachNICRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_DetachNIC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMEvents(ctx context.Context, in *ListVMEventsRequest, opts ...grpc.CallOption) (*ListVMEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMEventsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) WatchVM(ctx context.Context, in *WatchVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VirtualMachine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[0], VMService_WatchVM_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchVMRequest, VirtualMachine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMClient = grpc.ServerStreamingClient[VirtualMachine]

func (c *vMServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResourceUsage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[1], VMService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, ResourceUsage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_StreamMetricsClient = grpc.ServerStreamingClient[ResourceUsage]

func (c *vMServiceClient) WatchVMs(ctx context.Context, in *WatchVMsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VMUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[2], VMService_WatchVMs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchVMsRequest, VMUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMsClient = grpc.ServerStreamingClient[VMUpdate]

func (c *vMServiceClient) PingAgent(ctx context.Context, in *PingAgentRequest, opts ...grpc.CallOption) (*PingAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingAgentResponse)
	err := c.cc.Invoke(ctx, VMService_PingAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ExecuteScript(ctx context.Context, in *ExecuteScriptRequest, opts ...grpc.CallOption) (*ExecuteScriptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteScriptResponse)
	err := c.cc.Invoke(ctx, VMService_ExecuteScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ReadGuestFile(ctx context.Context, in *ReadGuestFileRequest, opts ...grpc.CallOption) (*ReadGuestFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadGuestFileResponse)
	err := c.cc.Invoke(ctx, VMService_ReadGuestFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) WriteGuestFile(ctx context.Context, in *WriteGuestFileRequest, opts ...grpc.CallOption) (*WriteGuestFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteGuestFileResponse)
	err := c.cc.Invoke(ctx, VMService_WriteGuestFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GuestShutdown(ctx context.Context, in *GuestShutdownRequest, opts ...grpc.CallOption) (*GuestShutdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuestShutdownResponse)
	err := c.cc.Invoke(ctx, VMService_GuestShutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VMServiceServer is the server API for VMService service.
// All implementations should embed UnimplementedVMServiceServer
// for forward compatibility.
//
// VMService provides CRUD operations and lifecycle management for Virtual Machines.
type VMServiceServer interface {
	// CreateVM creates a new virtual machine.
	// The VM will be in STOPPED state after creation unless start_on_create is true.
	CreateVM(context.Context, *CreateVMRequest) (*VirtualMachine, error)
	// GetVM retrieves a virtual machine by ID.
	GetVM(context.Context, *GetVMRequest) (*VirtualMachine, error)
	// ListVMs returns a paginated list of virtual machines.
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	// UpdateVM updates a virtual machine's specification.
	// Some changes require the VM to be stopped (e.g., CPU/memory changes).
	UpdateVM(context.Context, *UpdateVMRequest) (*VirtualMachine, error)
	// DeleteVM permanently deletes a virtual machine.
	// The VM must be stopped first. Use force=true to stop and delete.
	DeleteVM(context.Context, *DeleteVMRequest) (*emptypb.Empty, error)
	// StartVM powers on a virtual machine.
	StartVM(context.Context, *StartVMRequest) (*VirtualMachine, error)
	// StopVM powers off a virtual machine.
	// Use force=true for hard power off (like pulling the power cord).
	StopVM(context.Context, *StopVMRequest) (*VirtualMachine, error)
	// RebootVM restarts a virtual machine.
	RebootVM(context.Context, *RebootVMRequest) (*VirtualMachine, error)
	// PauseVM suspends VM execution (freezes in place).
	PauseVM(context.Context, *PauseVMRequest) (*VirtualMachine, error)
	// ResumeVM resumes a paused virtual machine.
	ResumeVM(context.Context, *ResumeVMRequest) (*VirtualMachine, error)
	// SuspendVM saves VM state to disk and stops (hibernate).
	SuspendVM(context.Context, *SuspendVMRequest) (*VirtualMachine, error)
	// CreateSnapshot creates a point-in-time snapshot.
	CreateSnapshot(context.Context, *CreateSnapshotRequest) (*Snapshot, error)
	// ListSnapshots returns all snapshots for a VM.
	ListSnapshots(context.Context, *ListSnapshotsRequest) (*ListSnapshotsResponse, error)
	// RevertToSnapshot reverts the VM to a previous snapshot.
	RevertToSnapshot(context.Context, *RevertToSnapshotRequest) (*VirtualMachine, error)
	// DeleteSnapshot removes a snapshot.
	DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error)
	// MigrateVM live-migrates a VM to another node.
	MigrateVM(context.Context, *MigrateVMRequest) (*MigrateVMResponse, error)
	// GetConsole returns connection info for VNC/SPICE console.
	GetConsole(context.Context, *GetConsoleRequest) (*ConsoleInfo, error)
	// CloneVM creates a copy of a virtual machine.
	CloneVM(context.Context, *CloneVMRequest) (*VirtualMachine, error)
	// ConvertToTemplate marks a VM as a template.
	ConvertToTemplate(context.Context, *ConvertToTemplateRequest) (*VirtualMachine, error)
	// AttachDisk attaches a new disk to a VM (hot-plug if running).
	AttachDisk(context.Context, *AttachDiskRequest) (*VirtualMachine, error)
	// DetachDisk removes a disk from a VM (hot-unplug if running).
	DetachDisk(context.Context, *DetachDiskRequest) (*VirtualMachine, error)
	// ResizeDisk expands a disk attached to a VM.
	ResizeDisk(context.Context, *ResizeDiskRequest) (*VirtualMachine, error)
	// AttachNIC attaches a new network interface to a VM (hot-plug if running).
	AttachNIC(context.Context, *AttachNICRequest) (*VirtualMachine, error)
	// DetachNIC removes a network interface from a VM (hot-unplug if running).
	DetachNIC(context.Context, *DetachNICRequest) (*VirtualMachine, error)
	// ListVMEvents returns events for a VM.
	ListVMEvents(context.Context, *ListVMEventsRequest) (*ListVMEventsResponse, error)
	// WatchVM streams real-time updates for a VM.
	WatchVM(*WatchVMRequest, grpc.ServerStreamingServer[VirtualMachine]) error
	// StreamMetrics streams real-time performance metrics.
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[ResourceUsage]) error
	// WatchVMs streams updates for all VMs (for Host UI dashboard).
	WatchVMs(*WatchVMsRequest, grpc.ServerStreamingServer[VMUpdate]) error
	// PingAgent checks if the guest agent is available and responding.
	PingAgent(context.Context, *PingAgentRequest) (*PingAgentResponse, error)
	// ExecuteScript runs a command inside the VM via the guest agent.
	ExecuteScript(context.Context, *ExecuteScriptRequest) (*ExecuteScriptResponse, error)
	// ReadGuestFile reads a file from inside the VM.
	ReadGuestFile(context.Context, *ReadGuestFileRequest) (*ReadGuestFileResponse, error)
	// WriteGuestFile writes a file to the VM.
	WriteGuestFile(context.Context, *WriteGuestFileRequest) (*WriteGuestFileResponse, error)
	// GuestShutdown requests the guest agent to gracefully shutdown/reboot.
	GuestShutdown(context.Context, *GuestShutdownRequest) (*GuestShutdownResponse, error)
}

// UnimplementedVMServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVMServiceServer struct{}

func (UnimplementedVMServiceServer) CreateVM(context.Context, *CreateVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVM not implemented")
}
func (UnimplementedVMServiceServer) GetVM(context.Context, *GetVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVMServiceServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVMServiceServer) UpdateVM(context.Context, *UpdateVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVM not implemented")
}
func (UnimplementedVMServiceServer) DeleteVM(context.Context, *DeleteVMRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVM not implemented")
}
func (UnimplementedVMServiceServer) StartVM(context.Context, *StartVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVM not implemented")
}
func (UnimplementedVMServiceServer) StopVM(context.Context, *StopVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method StopVM not implemented")
}
func (UnimplementedVMServiceServer) RebootVM(context.Context, *RebootVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method RebootVM not implemented")
}
func (UnimplementedVMServiceServer) PauseVM(context.Context, *PauseVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseVM not implemented")
}
func (UnimplementedVMServiceServer) ResumeVM(context.Context, *ResumeVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeVM not implemented")
}
func (UnimplementedVMServiceServer) SuspendVM(context.Context, *SuspendVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method SuspendVM not implemented")
}
func (UnimplementedVMServiceServer) CreateSnapshot(context.Context, *CreateSnapshotRequest) (*Snapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedVMServiceServer) ListSnapshots(context.Context, *ListSnapshotsRequest) (*ListSnapshotsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSnapshots not implemented")
}
func (UnimplementedVMServiceServer) RevertToSnapshot(context.Context, *RevertToSnapshotRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method RevertToSnapshot not implemented")
}
func (UnimplementedVMServiceServer) DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSnapshot not implemented")
}
func (UnimplementedVMServiceServer) MigrateVM(context.Context, *MigrateVMRequest) (*MigrateVMResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MigrateVM not implemented")
}
func (UnimplementedVMServiceServer) GetConsole(context.Context, *GetConsoleRequest) (*ConsoleInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConsole not implemented")
}
func (UnimplementedVMServiceServer) CloneVM(context.Context, *CloneVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method CloneVM not implemented")
}
func (UnimplementedVMServiceServer) ConvertToTemplate(context.Context, *ConvertToTemplateRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method ConvertToTemplate not implemented")
}
func (UnimplementedVMServiceServer) AttachDisk(context.Context, *AttachDiskRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachDisk not implemented")
}
func (UnimplementedVMServiceServer) DetachDisk(context.Context, *DetachDiskRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachDisk not implemented")
}
func (UnimplementedVMServiceServer) ResizeDisk(context.Context, *ResizeDiskRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method ResizeDisk not implemented")
}
func (UnimplementedVMServiceServer) AttachNIC(context.Context, *AttachNICRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachNIC not implemented")
}
func (UnimplementedVMServiceServer) DetachNIC(context.Context, *DetachNICRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachNIC not implemented")
}
func (UnimplementedVMServiceServer) ListVMEvents(context.Context, *ListVMEventsRequest) (*ListVMEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMEvents not implemented")
}
func (UnimplementedVMServiceServer) WatchVM(*WatchVMRequest, grpc.ServerStreamingServer[VirtualMachine]) error {
	return status.Error(codes.Unimplemented, "method WatchVM not implemented")
}
func (UnimplementedVMServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[ResourceUsage]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedVMServiceServer) WatchVMs(*WatchVMsRequest, grpc.ServerStreamingServer[VMUpdate]) error {
	return status.Error(codes.Unimplemented, "method WatchVMs not implemented")
}
func (UnimplementedVMServiceServer) PingAgent(context.Context, *PingAgentRequest) (*PingAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PingAgent not implemented")
}
func (UnimplementedVMServiceServer) ExecuteScript(context.Context, *ExecuteScriptRequest) (*ExecuteScriptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteScript not implemented")
}
func (UnimplementedVMServiceServer) ReadGuestFile(context.Context, *ReadGuestFileRequest) (*ReadGuestFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadGuestFile not implemented")
}
func (UnimplementedVMServiceServer) WriteGuestFile(context.Context, *WriteGuestFileRequest) (*WriteGuestFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteGuestFile not implemented")
}
func (UnimplementedVMServiceServer) GuestShutdown(context.Context, *GuestShutdownRequest) (*GuestShutdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GuestShutdown not implemented")
}
func (UnimplementedVMServiceServer) testEmbeddedByValue() {}

// UnsafeVMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VMServiceServer will
// result in compilation errors.
type UnsafeVMServiceServer interface {
	mustEmbedUnimplementedVMServiceServer()
}

func RegisterVMServiceServer(s grpc.ServiceRegistrar, srv VMServiceServer) {
	// If the following call panics, it indicates UnimplementedVMServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VMService_ServiceDesc, srv)
}

func _VMService_CreateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateVM(ctx, req.(*CreateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVM(ctx, req.(*UpdateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeleteVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteVM(ctx, req.(*DeleteVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StartVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StartVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StartVM(ctx, req.(*StartVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StopVM(ctx, req.(*StopVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_RebootVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).RebootVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_RebootVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).RebootVM(ctx, req.(*RebootVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_PauseVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).PauseVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_PauseVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).PauseVM(ctx, req.(*PauseVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResumeVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResumeVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResumeVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResumeVM(ctx, req.(*ResumeVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_SuspendVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).SuspendVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_SuspendVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).SuspendVM(ctx, req.(*SuspendVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListSnapshots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListSnapshots(ctx, req.(*ListSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_RevertToSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevertToSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).RevertToSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_RevertToSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).RevertToSnapshot(ctx, req.(*RevertToSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeleteSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteSnapshot(ctx, req.(*DeleteSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_MigrateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).MigrateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_MigrateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).MigrateVM(ctx, req.(*MigrateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetConsole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetConsole(ctx, req.(*GetConsoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CloneVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CloneVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CloneVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CloneVM(ctx, req.(*CloneVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ConvertToTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertToTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ConvertToTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ConvertToTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ConvertToTemplate(ctx, req.(*ConvertToTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachDisk(ctx, req.(*AttachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachDisk(ctx, req.(*DetachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResizeDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResizeDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResizeDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResizeDisk(ctx, req.(*ResizeDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNICRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachNIC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachNIC(ctx, req.(*AttachNICRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNICRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachNIC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachNIC(ctx, req.(*DetachNICRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMEvents(ctx, req.(*ListVMEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_WatchVM_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchVMRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).WatchVM(m, &grpc.GenericServerStream[WatchVMRequest, VirtualMachine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMServer = grpc.ServerStreamingServer[VirtualMachine]

func _VMService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, ResourceUsage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_StreamMetricsServer = grpc.ServerStreamingServer[ResourceUsage]

func _VMService_WatchVMs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchVMsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).WatchVMs(m, &grpc.GenericServerStream[WatchVMsRequest, VMUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMsServer = grpc.ServerStreamingServer[VMUpdate]

func _VMService_PingAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).PingAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_PingAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).PingAgent(ctx, req.(*PingAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ExecuteScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ExecuteScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ExecuteScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ExecuteScript(ctx, req.(*ExecuteScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ReadGuestFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadGuestFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ReadGuestFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ReadGuestFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ReadGuestFile(ctx, req.(*ReadGuestFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_WriteGuestFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteGuestFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).WriteGuestFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_WriteGuestFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).WriteGuestFile(ctx, req.(*WriteGuestFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GuestShutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GuestShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GuestShutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GuestShutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GuestShutdown(ctx, req.(*GuestShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VMService_ServiceDesc is the grpc.ServiceDesc for VMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.compute.v1.VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVM",
			Handler:    _VMService_CreateVM_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VMService_GetVM_Handler,
		},
		{
			MethodName: "ListVMs",
			Handler:    _VMService_ListVMs_Handler,
		},
		{
			MethodName: "UpdateVM",
			Handler:    _VMService_UpdateVM_Handler,
		},
		{
			MethodName: "DeleteVM",
			Handler:    _VMService_DeleteVM_Handler,
		},
		{
			MethodName: "StartVM",
			Handler:    _VMService_StartVM_Handler,
		},
		{
			MethodName: "StopVM",
			Handler:    _VMService_StopVM_Handler,
		},
		{
			MethodName: "RebootVM",
			Handler:    _VMService_RebootVM_Handler,
		},
		{
			MethodName: "PauseVM",
			Handler:    _VMService_PauseVM_Handler,
		},
		{
			MethodName: "ResumeVM",
			Handler:    _VMService_ResumeVM_Handler,
		},
		{
			MethodName: "SuspendVM",
			Handler:    _VMService_SuspendVM_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _VMService_CreateSnapshot_Handler,
		},
		{
			MethodName: "ListSnapshots",
			Handler:    _VMService_ListSnapshots_Handler,
		},
		{
			MethodName: "RevertToSnapshot",
			Handler:    _VMService_RevertToSnapshot_Handler,
		},
		{
			MethodName: "DeleteSnapshot",
			Handler:    _VMService_DeleteSnapshot_Handler,
		},
		{
			MethodName: "MigrateVM",
			Handler:    _VMService_MigrateVM_Handler,
		},
		{
			MethodName: "GetConsole",
			Handler:    _VMService_GetConsole_Handler,
		},
		{
			MethodName: "CloneVM",
			Handler:    _VMService_CloneVM_Handler,
		},
		{
			MethodName: "ConvertToTemplate",
			Handler:    _VMService_ConvertToTemplate_Handler,
		},
		{
			MethodName: "AttachDisk",
			Handler:    _VMService_AttachDisk_Handler,
		},
		{
			MethodName: "DetachDisk",
			Handler:    _VMService_DetachDisk_Handler,
		},
		{
			MethodName: "ResizeDisk",
			Handler:    _VMService_ResizeDisk_Handler,
		},
		{
			MethodName: "AttachNIC",
			Handler:    _VMService_AttachNIC_Handler,
		},
		{
			MethodName: "DetachNIC",
			Handler:    _VMService_DetachNIC_Handler,
		},
		{
			MethodName: "ListVMEvents",
			Handler:    _VMService_ListVMEvents_Handler,
		},
		{
			MethodName: "PingAgent",
			Handler:    _VMService_PingAgent_Handler,
		},
		{
			MethodName: "ExecuteScript",
			Handler:    _VMService_ExecuteScript_Handler,
		},
		{
			MethodName: "ReadGuestFile",
			Handler:    _VMService_ReadGuestFile_Handler,
		},
		{
			MethodName: "WriteGuestFile",
			Handler:    _VMService_WriteGuestFile_Handler,
		},
		{
			MethodName: "GuestShutdown",
			Handler:    _VMService_GuestShutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchVM",
			Handler:       _VMService_WatchVM_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMetrics",
			Handler:       _VMService_StreamMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchVMs",
			Handler:       _VMService_WatchVMs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "limiquantix/compute/v1/vm_service.proto",
}
