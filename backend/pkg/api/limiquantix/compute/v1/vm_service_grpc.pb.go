// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: Quantixkvm/compute/v1/vm_service.proto

package computev1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VMService_CreateVM_FullMethodName          = "/Quantixkvm.compute.v1.VMService/CreateVM"
	VMService_GetVM_FullMethodName             = "/Quantixkvm.compute.v1.VMService/GetVM"
	VMService_ListVMs_FullMethodName           = "/Quantixkvm.compute.v1.VMService/ListVMs"
	VMService_UpdateVM_FullMethodName          = "/Quantixkvm.compute.v1.VMService/UpdateVM"
	VMService_DeleteVM_FullMethodName          = "/Quantixkvm.compute.v1.VMService/DeleteVM"
	VMService_StartVM_FullMethodName           = "/Quantixkvm.compute.v1.VMService/StartVM"
	VMService_StopVM_FullMethodName            = "/Quantixkvm.compute.v1.VMService/StopVM"
	VMService_RebootVM_FullMethodName          = "/Quantixkvm.compute.v1.VMService/RebootVM"
	VMService_PauseVM_FullMethodName           = "/Quantixkvm.compute.v1.VMService/PauseVM"
	VMService_ResumeVM_FullMethodName          = "/Quantixkvm.compute.v1.VMService/ResumeVM"
	VMService_SuspendVM_FullMethodName         = "/Quantixkvm.compute.v1.VMService/SuspendVM"
	VMService_CreateSnapshot_FullMethodName    = "/Quantixkvm.compute.v1.VMService/CreateSnapshot"
	VMService_ListSnapshots_FullMethodName     = "/Quantixkvm.compute.v1.VMService/ListSnapshots"
	VMService_RevertToSnapshot_FullMethodName  = "/Quantixkvm.compute.v1.VMService/RevertToSnapshot"
	VMService_DeleteSnapshot_FullMethodName    = "/Quantixkvm.compute.v1.VMService/DeleteSnapshot"
	VMService_MigrateVM_FullMethodName         = "/Quantixkvm.compute.v1.VMService/MigrateVM"
	VMService_GetConsole_FullMethodName        = "/Quantixkvm.compute.v1.VMService/GetConsole"
	VMService_CloneVM_FullMethodName           = "/Quantixkvm.compute.v1.VMService/CloneVM"
	VMService_ConvertToTemplate_FullMethodName = "/Quantixkvm.compute.v1.VMService/ConvertToTemplate"
	VMService_WatchVM_FullMethodName           = "/Quantixkvm.compute.v1.VMService/WatchVM"
	VMService_StreamMetrics_FullMethodName     = "/Quantixkvm.compute.v1.VMService/StreamMetrics"
)

// VMServiceClient is the client API for VMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VMService provides CRUD operations and lifecycle management for Virtual Machines.
type VMServiceClient interface {
	// CreateVM creates a new virtual machine.
	// The VM will be in STOPPED state after creation unless start_on_create is true.
	CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// GetVM retrieves a virtual machine by ID.
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ListVMs returns a paginated list of virtual machines.
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	// UpdateVM updates a virtual machine's specification.
	// Some changes require the VM to be stopped (e.g., CPU/memory changes).
	UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DeleteVM permanently deletes a virtual machine.
	// The VM must be stopped first. Use force=true to stop and delete.
	DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// StartVM powers on a virtual machine.
	StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// StopVM powers off a virtual machine.
	// Use force=true for hard power off (like pulling the power cord).
	StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// RebootVM restarts a virtual machine.
	RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// PauseVM suspends VM execution (freezes in place).
	PauseVM(ctx context.Context, in *PauseVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ResumeVM resumes a paused virtual machine.
	ResumeVM(ctx context.Context, in *ResumeVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// SuspendVM saves VM state to disk and stops (hibernate).
	SuspendVM(ctx context.Context, in *SuspendVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// CreateSnapshot creates a point-in-time snapshot.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error)
	// ListSnapshots returns all snapshots for a VM.
	ListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error)
	// RevertToSnapshot reverts the VM to a previous snapshot.
	RevertToSnapshot(ctx context.Context, in *RevertToSnapshotRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// DeleteSnapshot removes a snapshot.
	DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// MigrateVM live-migrates a VM to another node.
	MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (*MigrateVMResponse, error)
	// GetConsole returns connection info for VNC/SPICE console.
	GetConsole(ctx context.Context, in *GetConsoleRequest, opts ...grpc.CallOption) (*ConsoleInfo, error)
	// CloneVM creates a copy of a virtual machine.
	CloneVM(ctx context.Context, in *CloneVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// ConvertToTemplate marks a VM as a template.
	ConvertToTemplate(ctx context.Context, in *ConvertToTemplateRequest, opts ...grpc.CallOption) (*VirtualMachine, error)
	// WatchVM streams real-time updates for a VM.
	WatchVM(ctx context.Context, in *WatchVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VirtualMachine], error)
	// StreamMetrics streams real-time performance metrics.
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResourceUsage], error)
}

type vMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVMServiceClient(cc grpc.ClientConnInterface) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_CreateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_GetVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVM(ctx context.Context, in *UpdateVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_UpdateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeleteVM(ctx context.Context, in *DeleteVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeleteVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_StartVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_StopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_RebootVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) PauseVM(ctx context.Context, in *PauseVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_PauseVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResumeVM(ctx context.Context, in *ResumeVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_ResumeVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) SuspendVM(ctx context.Context, in *SuspendVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_SuspendVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Snapshot)
	err := c.cc.Invoke(ctx, VMService_CreateSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListSnapshots(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*ListSnapshotsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSnapshotsResponse)
	err := c.cc.Invoke(ctx, VMService_ListSnapshots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) RevertToSnapshot(ctx context.Context, in *RevertToSnapshotRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_RevertToSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeleteSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) MigrateVM(ctx context.Context, in *MigrateVMRequest, opts ...grpc.CallOption) (*MigrateVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateVMResponse)
	err := c.cc.Invoke(ctx, VMService_MigrateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetConsole(ctx context.Context, in *GetConsoleRequest, opts ...grpc.CallOption) (*ConsoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsoleInfo)
	err := c.cc.Invoke(ctx, VMService_GetConsole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CloneVM(ctx context.Context, in *CloneVMRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_CloneVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ConvertToTemplate(ctx context.Context, in *ConvertToTemplateRequest, opts ...grpc.CallOption) (*VirtualMachine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualMachine)
	err := c.cc.Invoke(ctx, VMService_ConvertToTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) WatchVM(ctx context.Context, in *WatchVMRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VirtualMachine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[0], VMService_WatchVM_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchVMRequest, VirtualMachine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMClient = grpc.ServerStreamingClient[VirtualMachine]

func (c *vMServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResourceUsage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[1], VMService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, ResourceUsage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_StreamMetricsClient = grpc.ServerStreamingClient[ResourceUsage]

// VMServiceServer is the server API for VMService service.
// All implementations should embed UnimplementedVMServiceServer
// for forward compatibility.
//
// VMService provides CRUD operations and lifecycle management for Virtual Machines.
type VMServiceServer interface {
	// CreateVM creates a new virtual machine.
	// The VM will be in STOPPED state after creation unless start_on_create is true.
	CreateVM(context.Context, *CreateVMRequest) (*VirtualMachine, error)
	// GetVM retrieves a virtual machine by ID.
	GetVM(context.Context, *GetVMRequest) (*VirtualMachine, error)
	// ListVMs returns a paginated list of virtual machines.
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	// UpdateVM updates a virtual machine's specification.
	// Some changes require the VM to be stopped (e.g., CPU/memory changes).
	UpdateVM(context.Context, *UpdateVMRequest) (*VirtualMachine, error)
	// DeleteVM permanently deletes a virtual machine.
	// The VM must be stopped first. Use force=true to stop and delete.
	DeleteVM(context.Context, *DeleteVMRequest) (*emptypb.Empty, error)
	// StartVM powers on a virtual machine.
	StartVM(context.Context, *StartVMRequest) (*VirtualMachine, error)
	// StopVM powers off a virtual machine.
	// Use force=true for hard power off (like pulling the power cord).
	StopVM(context.Context, *StopVMRequest) (*VirtualMachine, error)
	// RebootVM restarts a virtual machine.
	RebootVM(context.Context, *RebootVMRequest) (*VirtualMachine, error)
	// PauseVM suspends VM execution (freezes in place).
	PauseVM(context.Context, *PauseVMRequest) (*VirtualMachine, error)
	// ResumeVM resumes a paused virtual machine.
	ResumeVM(context.Context, *ResumeVMRequest) (*VirtualMachine, error)
	// SuspendVM saves VM state to disk and stops (hibernate).
	SuspendVM(context.Context, *SuspendVMRequest) (*VirtualMachine, error)
	// CreateSnapshot creates a point-in-time snapshot.
	CreateSnapshot(context.Context, *CreateSnapshotRequest) (*Snapshot, error)
	// ListSnapshots returns all snapshots for a VM.
	ListSnapshots(context.Context, *ListSnapshotsRequest) (*ListSnapshotsResponse, error)
	// RevertToSnapshot reverts the VM to a previous snapshot.
	RevertToSnapshot(context.Context, *RevertToSnapshotRequest) (*VirtualMachine, error)
	// DeleteSnapshot removes a snapshot.
	DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error)
	// MigrateVM live-migrates a VM to another node.
	MigrateVM(context.Context, *MigrateVMRequest) (*MigrateVMResponse, error)
	// GetConsole returns connection info for VNC/SPICE console.
	GetConsole(context.Context, *GetConsoleRequest) (*ConsoleInfo, error)
	// CloneVM creates a copy of a virtual machine.
	CloneVM(context.Context, *CloneVMRequest) (*VirtualMachine, error)
	// ConvertToTemplate marks a VM as a template.
	ConvertToTemplate(context.Context, *ConvertToTemplateRequest) (*VirtualMachine, error)
	// WatchVM streams real-time updates for a VM.
	WatchVM(*WatchVMRequest, grpc.ServerStreamingServer[VirtualMachine]) error
	// StreamMetrics streams real-time performance metrics.
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[ResourceUsage]) error
}

// UnimplementedVMServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVMServiceServer struct{}

func (UnimplementedVMServiceServer) CreateVM(context.Context, *CreateVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVM not implemented")
}
func (UnimplementedVMServiceServer) GetVM(context.Context, *GetVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVMServiceServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVMServiceServer) UpdateVM(context.Context, *UpdateVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVM not implemented")
}
func (UnimplementedVMServiceServer) DeleteVM(context.Context, *DeleteVMRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVM not implemented")
}
func (UnimplementedVMServiceServer) StartVM(context.Context, *StartVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVM not implemented")
}
func (UnimplementedVMServiceServer) StopVM(context.Context, *StopVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method StopVM not implemented")
}
func (UnimplementedVMServiceServer) RebootVM(context.Context, *RebootVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method RebootVM not implemented")
}
func (UnimplementedVMServiceServer) PauseVM(context.Context, *PauseVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseVM not implemented")
}
func (UnimplementedVMServiceServer) ResumeVM(context.Context, *ResumeVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeVM not implemented")
}
func (UnimplementedVMServiceServer) SuspendVM(context.Context, *SuspendVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method SuspendVM not implemented")
}
func (UnimplementedVMServiceServer) CreateSnapshot(context.Context, *CreateSnapshotRequest) (*Snapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedVMServiceServer) ListSnapshots(context.Context, *ListSnapshotsRequest) (*ListSnapshotsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSnapshots not implemented")
}
func (UnimplementedVMServiceServer) RevertToSnapshot(context.Context, *RevertToSnapshotRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method RevertToSnapshot not implemented")
}
func (UnimplementedVMServiceServer) DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSnapshot not implemented")
}
func (UnimplementedVMServiceServer) MigrateVM(context.Context, *MigrateVMRequest) (*MigrateVMResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MigrateVM not implemented")
}
func (UnimplementedVMServiceServer) GetConsole(context.Context, *GetConsoleRequest) (*ConsoleInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConsole not implemented")
}
func (UnimplementedVMServiceServer) CloneVM(context.Context, *CloneVMRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method CloneVM not implemented")
}
func (UnimplementedVMServiceServer) ConvertToTemplate(context.Context, *ConvertToTemplateRequest) (*VirtualMachine, error) {
	return nil, status.Error(codes.Unimplemented, "method ConvertToTemplate not implemented")
}
func (UnimplementedVMServiceServer) WatchVM(*WatchVMRequest, grpc.ServerStreamingServer[VirtualMachine]) error {
	return status.Error(codes.Unimplemented, "method WatchVM not implemented")
}
func (UnimplementedVMServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[ResourceUsage]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedVMServiceServer) testEmbeddedByValue() {}

// UnsafeVMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VMServiceServer will
// result in compilation errors.
type UnsafeVMServiceServer interface {
	mustEmbedUnimplementedVMServiceServer()
}

func RegisterVMServiceServer(s grpc.ServiceRegistrar, srv VMServiceServer) {
	// If the following call panics, it indicates UnimplementedVMServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VMService_ServiceDesc, srv)
}

func _VMService_CreateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateVM(ctx, req.(*CreateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVM(ctx, req.(*UpdateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeleteVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteVM(ctx, req.(*DeleteVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StartVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StartVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StartVM(ctx, req.(*StartVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StopVM(ctx, req.(*StopVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_RebootVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).RebootVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_RebootVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).RebootVM(ctx, req.(*RebootVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_PauseVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).PauseVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_PauseVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).PauseVM(ctx, req.(*PauseVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResumeVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResumeVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResumeVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResumeVM(ctx, req.(*ResumeVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_SuspendVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).SuspendVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_SuspendVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).SuspendVM(ctx, req.(*SuspendVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListSnapshots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListSnapshots(ctx, req.(*ListSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_RevertToSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevertToSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).RevertToSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_RevertToSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).RevertToSnapshot(ctx, req.(*RevertToSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeleteSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteSnapshot(ctx, req.(*DeleteSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_MigrateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).MigrateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_MigrateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).MigrateVM(ctx, req.(*MigrateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetConsole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetConsole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetConsole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetConsole(ctx, req.(*GetConsoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CloneVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CloneVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CloneVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CloneVM(ctx, req.(*CloneVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ConvertToTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertToTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ConvertToTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ConvertToTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ConvertToTemplate(ctx, req.(*ConvertToTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_WatchVM_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchVMRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).WatchVM(m, &grpc.GenericServerStream[WatchVMRequest, VirtualMachine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_WatchVMServer = grpc.ServerStreamingServer[VirtualMachine]

func _VMService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, ResourceUsage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VMService_StreamMetricsServer = grpc.ServerStreamingServer[ResourceUsage]

// VMService_ServiceDesc is the grpc.ServiceDesc for VMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Quantixkvm.compute.v1.VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVM",
			Handler:    _VMService_CreateVM_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VMService_GetVM_Handler,
		},
		{
			MethodName: "ListVMs",
			Handler:    _VMService_ListVMs_Handler,
		},
		{
			MethodName: "UpdateVM",
			Handler:    _VMService_UpdateVM_Handler,
		},
		{
			MethodName: "DeleteVM",
			Handler:    _VMService_DeleteVM_Handler,
		},
		{
			MethodName: "StartVM",
			Handler:    _VMService_StartVM_Handler,
		},
		{
			MethodName: "StopVM",
			Handler:    _VMService_StopVM_Handler,
		},
		{
			MethodName: "RebootVM",
			Handler:    _VMService_RebootVM_Handler,
		},
		{
			MethodName: "PauseVM",
			Handler:    _VMService_PauseVM_Handler,
		},
		{
			MethodName: "ResumeVM",
			Handler:    _VMService_ResumeVM_Handler,
		},
		{
			MethodName: "SuspendVM",
			Handler:    _VMService_SuspendVM_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _VMService_CreateSnapshot_Handler,
		},
		{
			MethodName: "ListSnapshots",
			Handler:    _VMService_ListSnapshots_Handler,
		},
		{
			MethodName: "RevertToSnapshot",
			Handler:    _VMService_RevertToSnapshot_Handler,
		},
		{
			MethodName: "DeleteSnapshot",
			Handler:    _VMService_DeleteSnapshot_Handler,
		},
		{
			MethodName: "MigrateVM",
			Handler:    _VMService_MigrateVM_Handler,
		},
		{
			MethodName: "GetConsole",
			Handler:    _VMService_GetConsole_Handler,
		},
		{
			MethodName: "CloneVM",
			Handler:    _VMService_CloneVM_Handler,
		},
		{
			MethodName: "ConvertToTemplate",
			Handler:    _VMService_ConvertToTemplate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchVM",
			Handler:       _VMService_WatchVM_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMetrics",
			Handler:       _VMService_StreamMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "Quantixkvm/compute/v1/vm_service.proto",
}
