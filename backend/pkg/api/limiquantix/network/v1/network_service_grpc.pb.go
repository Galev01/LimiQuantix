// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: limiquantix/network/v1/network_service.proto

package networkv1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VirtualNetworkService_CreateNetwork_FullMethodName      = "/limiquantix.network.v1.VirtualNetworkService/CreateNetwork"
	VirtualNetworkService_GetNetwork_FullMethodName         = "/limiquantix.network.v1.VirtualNetworkService/GetNetwork"
	VirtualNetworkService_ListNetworks_FullMethodName       = "/limiquantix.network.v1.VirtualNetworkService/ListNetworks"
	VirtualNetworkService_UpdateNetwork_FullMethodName      = "/limiquantix.network.v1.VirtualNetworkService/UpdateNetwork"
	VirtualNetworkService_DeleteNetwork_FullMethodName      = "/limiquantix.network.v1.VirtualNetworkService/DeleteNetwork"
	VirtualNetworkService_GetNetworkTopology_FullMethodName = "/limiquantix.network.v1.VirtualNetworkService/GetNetworkTopology"
)

// VirtualNetworkServiceClient is the client API for VirtualNetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VirtualNetworkService manages software-defined networks.
type VirtualNetworkServiceClient interface {
	// CreateNetwork creates a new virtual network.
	CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error)
	// GetNetwork retrieves a network by ID.
	GetNetwork(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error)
	// ListNetworks returns all networks.
	ListNetworks(ctx context.Context, in *ListNetworksRequest, opts ...grpc.CallOption) (*ListNetworksResponse, error)
	// UpdateNetwork updates network configuration.
	UpdateNetwork(ctx context.Context, in *UpdateNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error)
	// DeleteNetwork removes a network.
	// Network must have no ports unless force=true.
	DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetNetworkTopology returns network connectivity graph.
	GetNetworkTopology(ctx context.Context, in *GetNetworkTopologyRequest, opts ...grpc.CallOption) (*NetworkTopology, error)
}

type virtualNetworkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVirtualNetworkServiceClient(cc grpc.ClientConnInterface) VirtualNetworkServiceClient {
	return &virtualNetworkServiceClient{cc}
}

func (c *virtualNetworkServiceClient) CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualNetwork)
	err := c.cc.Invoke(ctx, VirtualNetworkService_CreateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualNetworkServiceClient) GetNetwork(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualNetwork)
	err := c.cc.Invoke(ctx, VirtualNetworkService_GetNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualNetworkServiceClient) ListNetworks(ctx context.Context, in *ListNetworksRequest, opts ...grpc.CallOption) (*ListNetworksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNetworksResponse)
	err := c.cc.Invoke(ctx, VirtualNetworkService_ListNetworks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualNetworkServiceClient) UpdateNetwork(ctx context.Context, in *UpdateNetworkRequest, opts ...grpc.CallOption) (*VirtualNetwork, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VirtualNetwork)
	err := c.cc.Invoke(ctx, VirtualNetworkService_UpdateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualNetworkServiceClient) DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VirtualNetworkService_DeleteNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualNetworkServiceClient) GetNetworkTopology(ctx context.Context, in *GetNetworkTopologyRequest, opts ...grpc.CallOption) (*NetworkTopology, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkTopology)
	err := c.cc.Invoke(ctx, VirtualNetworkService_GetNetworkTopology_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualNetworkServiceServer is the server API for VirtualNetworkService service.
// All implementations should embed UnimplementedVirtualNetworkServiceServer
// for forward compatibility.
//
// VirtualNetworkService manages software-defined networks.
type VirtualNetworkServiceServer interface {
	// CreateNetwork creates a new virtual network.
	CreateNetwork(context.Context, *CreateNetworkRequest) (*VirtualNetwork, error)
	// GetNetwork retrieves a network by ID.
	GetNetwork(context.Context, *GetNetworkRequest) (*VirtualNetwork, error)
	// ListNetworks returns all networks.
	ListNetworks(context.Context, *ListNetworksRequest) (*ListNetworksResponse, error)
	// UpdateNetwork updates network configuration.
	UpdateNetwork(context.Context, *UpdateNetworkRequest) (*VirtualNetwork, error)
	// DeleteNetwork removes a network.
	// Network must have no ports unless force=true.
	DeleteNetwork(context.Context, *DeleteNetworkRequest) (*emptypb.Empty, error)
	// GetNetworkTopology returns network connectivity graph.
	GetNetworkTopology(context.Context, *GetNetworkTopologyRequest) (*NetworkTopology, error)
}

// UnimplementedVirtualNetworkServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVirtualNetworkServiceServer struct{}

func (UnimplementedVirtualNetworkServiceServer) CreateNetwork(context.Context, *CreateNetworkRequest) (*VirtualNetwork, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) GetNetwork(context.Context, *GetNetworkRequest) (*VirtualNetwork, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNetwork not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) ListNetworks(context.Context, *ListNetworksRequest) (*ListNetworksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) UpdateNetwork(context.Context, *UpdateNetworkRequest) (*VirtualNetwork, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNetwork not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) DeleteNetwork(context.Context, *DeleteNetworkRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteNetwork not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) GetNetworkTopology(context.Context, *GetNetworkTopologyRequest) (*NetworkTopology, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNetworkTopology not implemented")
}
func (UnimplementedVirtualNetworkServiceServer) testEmbeddedByValue() {}

// UnsafeVirtualNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VirtualNetworkServiceServer will
// result in compilation errors.
type UnsafeVirtualNetworkServiceServer interface {
	mustEmbedUnimplementedVirtualNetworkServiceServer()
}

func RegisterVirtualNetworkServiceServer(s grpc.ServiceRegistrar, srv VirtualNetworkServiceServer) {
	// If the following call panics, it indicates UnimplementedVirtualNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VirtualNetworkService_ServiceDesc, srv)
}

func _VirtualNetworkService_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_CreateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).CreateNetwork(ctx, req.(*CreateNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualNetworkService_GetNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).GetNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_GetNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).GetNetwork(ctx, req.(*GetNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualNetworkService_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_ListNetworks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).ListNetworks(ctx, req.(*ListNetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualNetworkService_UpdateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).UpdateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_UpdateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).UpdateNetwork(ctx, req.(*UpdateNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualNetworkService_DeleteNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).DeleteNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_DeleteNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).DeleteNetwork(ctx, req.(*DeleteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualNetworkService_GetNetworkTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualNetworkServiceServer).GetNetworkTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VirtualNetworkService_GetNetworkTopology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualNetworkServiceServer).GetNetworkTopology(ctx, req.(*GetNetworkTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VirtualNetworkService_ServiceDesc is the grpc.ServiceDesc for VirtualNetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VirtualNetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.VirtualNetworkService",
	HandlerType: (*VirtualNetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _VirtualNetworkService_CreateNetwork_Handler,
		},
		{
			MethodName: "GetNetwork",
			Handler:    _VirtualNetworkService_GetNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _VirtualNetworkService_ListNetworks_Handler,
		},
		{
			MethodName: "UpdateNetwork",
			Handler:    _VirtualNetworkService_UpdateNetwork_Handler,
		},
		{
			MethodName: "DeleteNetwork",
			Handler:    _VirtualNetworkService_DeleteNetwork_Handler,
		},
		{
			MethodName: "GetNetworkTopology",
			Handler:    _VirtualNetworkService_GetNetworkTopology_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}

const (
	PortService_CreatePort_FullMethodName = "/limiquantix.network.v1.PortService/CreatePort"
	PortService_GetPort_FullMethodName    = "/limiquantix.network.v1.PortService/GetPort"
	PortService_ListPorts_FullMethodName  = "/limiquantix.network.v1.PortService/ListPorts"
	PortService_UpdatePort_FullMethodName = "/limiquantix.network.v1.PortService/UpdatePort"
	PortService_DeletePort_FullMethodName = "/limiquantix.network.v1.PortService/DeletePort"
	PortService_BindPort_FullMethodName   = "/limiquantix.network.v1.PortService/BindPort"
	PortService_UnbindPort_FullMethodName = "/limiquantix.network.v1.PortService/UnbindPort"
)

// PortServiceClient is the client API for PortService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PortService manages network port connections.
type PortServiceClient interface {
	// CreatePort creates a new network port.
	CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*Port, error)
	// GetPort retrieves a port by ID.
	GetPort(ctx context.Context, in *GetPortRequest, opts ...grpc.CallOption) (*Port, error)
	// ListPorts returns ports with filtering.
	ListPorts(ctx context.Context, in *ListPortsRequest, opts ...grpc.CallOption) (*ListPortsResponse, error)
	// UpdatePort updates port configuration.
	UpdatePort(ctx context.Context, in *UpdatePortRequest, opts ...grpc.CallOption) (*Port, error)
	// DeletePort removes a port.
	DeletePort(ctx context.Context, in *DeletePortRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// BindPort assigns a port to a VM.
	BindPort(ctx context.Context, in *BindPortRequest, opts ...grpc.CallOption) (*Port, error)
	// UnbindPort removes port assignment.
	UnbindPort(ctx context.Context, in *UnbindPortRequest, opts ...grpc.CallOption) (*Port, error)
}

type portServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPortServiceClient(cc grpc.ClientConnInterface) PortServiceClient {
	return &portServiceClient{cc}
}

func (c *portServiceClient) CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*Port, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Port)
	err := c.cc.Invoke(ctx, PortService_CreatePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) GetPort(ctx context.Context, in *GetPortRequest, opts ...grpc.CallOption) (*Port, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Port)
	err := c.cc.Invoke(ctx, PortService_GetPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) ListPorts(ctx context.Context, in *ListPortsRequest, opts ...grpc.CallOption) (*ListPortsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPortsResponse)
	err := c.cc.Invoke(ctx, PortService_ListPorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) UpdatePort(ctx context.Context, in *UpdatePortRequest, opts ...grpc.CallOption) (*Port, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Port)
	err := c.cc.Invoke(ctx, PortService_UpdatePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) DeletePort(ctx context.Context, in *DeletePortRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PortService_DeletePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) BindPort(ctx context.Context, in *BindPortRequest, opts ...grpc.CallOption) (*Port, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Port)
	err := c.cc.Invoke(ctx, PortService_BindPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portServiceClient) UnbindPort(ctx context.Context, in *UnbindPortRequest, opts ...grpc.CallOption) (*Port, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Port)
	err := c.cc.Invoke(ctx, PortService_UnbindPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PortServiceServer is the server API for PortService service.
// All implementations should embed UnimplementedPortServiceServer
// for forward compatibility.
//
// PortService manages network port connections.
type PortServiceServer interface {
	// CreatePort creates a new network port.
	CreatePort(context.Context, *CreatePortRequest) (*Port, error)
	// GetPort retrieves a port by ID.
	GetPort(context.Context, *GetPortRequest) (*Port, error)
	// ListPorts returns ports with filtering.
	ListPorts(context.Context, *ListPortsRequest) (*ListPortsResponse, error)
	// UpdatePort updates port configuration.
	UpdatePort(context.Context, *UpdatePortRequest) (*Port, error)
	// DeletePort removes a port.
	DeletePort(context.Context, *DeletePortRequest) (*emptypb.Empty, error)
	// BindPort assigns a port to a VM.
	BindPort(context.Context, *BindPortRequest) (*Port, error)
	// UnbindPort removes port assignment.
	UnbindPort(context.Context, *UnbindPortRequest) (*Port, error)
}

// UnimplementedPortServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPortServiceServer struct{}

func (UnimplementedPortServiceServer) CreatePort(context.Context, *CreatePortRequest) (*Port, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePort not implemented")
}
func (UnimplementedPortServiceServer) GetPort(context.Context, *GetPortRequest) (*Port, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPort not implemented")
}
func (UnimplementedPortServiceServer) ListPorts(context.Context, *ListPortsRequest) (*ListPortsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPorts not implemented")
}
func (UnimplementedPortServiceServer) UpdatePort(context.Context, *UpdatePortRequest) (*Port, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePort not implemented")
}
func (UnimplementedPortServiceServer) DeletePort(context.Context, *DeletePortRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePort not implemented")
}
func (UnimplementedPortServiceServer) BindPort(context.Context, *BindPortRequest) (*Port, error) {
	return nil, status.Error(codes.Unimplemented, "method BindPort not implemented")
}
func (UnimplementedPortServiceServer) UnbindPort(context.Context, *UnbindPortRequest) (*Port, error) {
	return nil, status.Error(codes.Unimplemented, "method UnbindPort not implemented")
}
func (UnimplementedPortServiceServer) testEmbeddedByValue() {}

// UnsafePortServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PortServiceServer will
// result in compilation errors.
type UnsafePortServiceServer interface {
	mustEmbedUnimplementedPortServiceServer()
}

func RegisterPortServiceServer(s grpc.ServiceRegistrar, srv PortServiceServer) {
	// If the following call panics, it indicates UnimplementedPortServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PortService_ServiceDesc, srv)
}

func _PortService_CreatePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).CreatePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_CreatePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).CreatePort(ctx, req.(*CreatePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_GetPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).GetPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_GetPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).GetPort(ctx, req.(*GetPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_ListPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).ListPorts(ctx, req.(*ListPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_UpdatePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).UpdatePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_UpdatePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).UpdatePort(ctx, req.(*UpdatePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_DeletePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).DeletePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_DeletePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).DeletePort(ctx, req.(*DeletePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_BindPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).BindPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_BindPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).BindPort(ctx, req.(*BindPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortService_UnbindPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbindPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortServiceServer).UnbindPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PortService_UnbindPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortServiceServer).UnbindPort(ctx, req.(*UnbindPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PortService_ServiceDesc is the grpc.ServiceDesc for PortService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PortService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.PortService",
	HandlerType: (*PortServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePort",
			Handler:    _PortService_CreatePort_Handler,
		},
		{
			MethodName: "GetPort",
			Handler:    _PortService_GetPort_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _PortService_ListPorts_Handler,
		},
		{
			MethodName: "UpdatePort",
			Handler:    _PortService_UpdatePort_Handler,
		},
		{
			MethodName: "DeletePort",
			Handler:    _PortService_DeletePort_Handler,
		},
		{
			MethodName: "BindPort",
			Handler:    _PortService_BindPort_Handler,
		},
		{
			MethodName: "UnbindPort",
			Handler:    _PortService_UnbindPort_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}

const (
	SecurityGroupService_CreateSecurityGroup_FullMethodName = "/limiquantix.network.v1.SecurityGroupService/CreateSecurityGroup"
	SecurityGroupService_GetSecurityGroup_FullMethodName    = "/limiquantix.network.v1.SecurityGroupService/GetSecurityGroup"
	SecurityGroupService_ListSecurityGroups_FullMethodName  = "/limiquantix.network.v1.SecurityGroupService/ListSecurityGroups"
	SecurityGroupService_UpdateSecurityGroup_FullMethodName = "/limiquantix.network.v1.SecurityGroupService/UpdateSecurityGroup"
	SecurityGroupService_DeleteSecurityGroup_FullMethodName = "/limiquantix.network.v1.SecurityGroupService/DeleteSecurityGroup"
	SecurityGroupService_AddRule_FullMethodName             = "/limiquantix.network.v1.SecurityGroupService/AddRule"
	SecurityGroupService_RemoveRule_FullMethodName          = "/limiquantix.network.v1.SecurityGroupService/RemoveRule"
)

// SecurityGroupServiceClient is the client API for SecurityGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SecurityGroupService manages firewall rules.
type SecurityGroupServiceClient interface {
	// CreateSecurityGroup creates a new security group.
	CreateSecurityGroup(ctx context.Context, in *CreateSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error)
	// GetSecurityGroup retrieves a security group by ID.
	GetSecurityGroup(ctx context.Context, in *GetSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error)
	// ListSecurityGroups returns all security groups.
	ListSecurityGroups(ctx context.Context, in *ListSecurityGroupsRequest, opts ...grpc.CallOption) (*ListSecurityGroupsResponse, error)
	// UpdateSecurityGroup updates rules.
	UpdateSecurityGroup(ctx context.Context, in *UpdateSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error)
	// DeleteSecurityGroup removes a security group.
	// Group must not be in use unless force=true.
	DeleteSecurityGroup(ctx context.Context, in *DeleteSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AddRule adds a firewall rule.
	AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*SecurityGroup, error)
	// RemoveRule removes a firewall rule.
	RemoveRule(ctx context.Context, in *RemoveRuleRequest, opts ...grpc.CallOption) (*SecurityGroup, error)
}

type securityGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSecurityGroupServiceClient(cc grpc.ClientConnInterface) SecurityGroupServiceClient {
	return &securityGroupServiceClient{cc}
}

func (c *securityGroupServiceClient) CreateSecurityGroup(ctx context.Context, in *CreateSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityGroup)
	err := c.cc.Invoke(ctx, SecurityGroupService_CreateSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) GetSecurityGroup(ctx context.Context, in *GetSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityGroup)
	err := c.cc.Invoke(ctx, SecurityGroupService_GetSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) ListSecurityGroups(ctx context.Context, in *ListSecurityGroupsRequest, opts ...grpc.CallOption) (*ListSecurityGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSecurityGroupsResponse)
	err := c.cc.Invoke(ctx, SecurityGroupService_ListSecurityGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) UpdateSecurityGroup(ctx context.Context, in *UpdateSecurityGroupRequest, opts ...grpc.CallOption) (*SecurityGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityGroup)
	err := c.cc.Invoke(ctx, SecurityGroupService_UpdateSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) DeleteSecurityGroup(ctx context.Context, in *DeleteSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SecurityGroupService_DeleteSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*SecurityGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityGroup)
	err := c.cc.Invoke(ctx, SecurityGroupService_AddRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityGroupServiceClient) RemoveRule(ctx context.Context, in *RemoveRuleRequest, opts ...grpc.CallOption) (*SecurityGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityGroup)
	err := c.cc.Invoke(ctx, SecurityGroupService_RemoveRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SecurityGroupServiceServer is the server API for SecurityGroupService service.
// All implementations should embed UnimplementedSecurityGroupServiceServer
// for forward compatibility.
//
// SecurityGroupService manages firewall rules.
type SecurityGroupServiceServer interface {
	// CreateSecurityGroup creates a new security group.
	CreateSecurityGroup(context.Context, *CreateSecurityGroupRequest) (*SecurityGroup, error)
	// GetSecurityGroup retrieves a security group by ID.
	GetSecurityGroup(context.Context, *GetSecurityGroupRequest) (*SecurityGroup, error)
	// ListSecurityGroups returns all security groups.
	ListSecurityGroups(context.Context, *ListSecurityGroupsRequest) (*ListSecurityGroupsResponse, error)
	// UpdateSecurityGroup updates rules.
	UpdateSecurityGroup(context.Context, *UpdateSecurityGroupRequest) (*SecurityGroup, error)
	// DeleteSecurityGroup removes a security group.
	// Group must not be in use unless force=true.
	DeleteSecurityGroup(context.Context, *DeleteSecurityGroupRequest) (*emptypb.Empty, error)
	// AddRule adds a firewall rule.
	AddRule(context.Context, *AddRuleRequest) (*SecurityGroup, error)
	// RemoveRule removes a firewall rule.
	RemoveRule(context.Context, *RemoveRuleRequest) (*SecurityGroup, error)
}

// UnimplementedSecurityGroupServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSecurityGroupServiceServer struct{}

func (UnimplementedSecurityGroupServiceServer) CreateSecurityGroup(context.Context, *CreateSecurityGroupRequest) (*SecurityGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSecurityGroup not implemented")
}
func (UnimplementedSecurityGroupServiceServer) GetSecurityGroup(context.Context, *GetSecurityGroupRequest) (*SecurityGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSecurityGroup not implemented")
}
func (UnimplementedSecurityGroupServiceServer) ListSecurityGroups(context.Context, *ListSecurityGroupsRequest) (*ListSecurityGroupsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSecurityGroups not implemented")
}
func (UnimplementedSecurityGroupServiceServer) UpdateSecurityGroup(context.Context, *UpdateSecurityGroupRequest) (*SecurityGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSecurityGroup not implemented")
}
func (UnimplementedSecurityGroupServiceServer) DeleteSecurityGroup(context.Context, *DeleteSecurityGroupRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSecurityGroup not implemented")
}
func (UnimplementedSecurityGroupServiceServer) AddRule(context.Context, *AddRuleRequest) (*SecurityGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedSecurityGroupServiceServer) RemoveRule(context.Context, *RemoveRuleRequest) (*SecurityGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedSecurityGroupServiceServer) testEmbeddedByValue() {}

// UnsafeSecurityGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SecurityGroupServiceServer will
// result in compilation errors.
type UnsafeSecurityGroupServiceServer interface {
	mustEmbedUnimplementedSecurityGroupServiceServer()
}

func RegisterSecurityGroupServiceServer(s grpc.ServiceRegistrar, srv SecurityGroupServiceServer) {
	// If the following call panics, it indicates UnimplementedSecurityGroupServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SecurityGroupService_ServiceDesc, srv)
}

func _SecurityGroupService_CreateSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).CreateSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_CreateSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).CreateSecurityGroup(ctx, req.(*CreateSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_GetSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).GetSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_GetSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).GetSecurityGroup(ctx, req.(*GetSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_ListSecurityGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSecurityGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).ListSecurityGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_ListSecurityGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).ListSecurityGroups(ctx, req.(*ListSecurityGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_UpdateSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).UpdateSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_UpdateSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).UpdateSecurityGroup(ctx, req.(*UpdateSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_DeleteSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).DeleteSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_DeleteSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).DeleteSecurityGroup(ctx, req.(*DeleteSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).AddRule(ctx, req.(*AddRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityGroupService_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityGroupServiceServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityGroupService_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityGroupServiceServer).RemoveRule(ctx, req.(*RemoveRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SecurityGroupService_ServiceDesc is the grpc.ServiceDesc for SecurityGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SecurityGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.SecurityGroupService",
	HandlerType: (*SecurityGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSecurityGroup",
			Handler:    _SecurityGroupService_CreateSecurityGroup_Handler,
		},
		{
			MethodName: "GetSecurityGroup",
			Handler:    _SecurityGroupService_GetSecurityGroup_Handler,
		},
		{
			MethodName: "ListSecurityGroups",
			Handler:    _SecurityGroupService_ListSecurityGroups_Handler,
		},
		{
			MethodName: "UpdateSecurityGroup",
			Handler:    _SecurityGroupService_UpdateSecurityGroup_Handler,
		},
		{
			MethodName: "DeleteSecurityGroup",
			Handler:    _SecurityGroupService_DeleteSecurityGroup_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _SecurityGroupService_AddRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _SecurityGroupService_RemoveRule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}

const (
	FloatingIpService_AllocateFloatingIp_FullMethodName     = "/limiquantix.network.v1.FloatingIpService/AllocateFloatingIp"
	FloatingIpService_GetFloatingIp_FullMethodName          = "/limiquantix.network.v1.FloatingIpService/GetFloatingIp"
	FloatingIpService_ListFloatingIps_FullMethodName        = "/limiquantix.network.v1.FloatingIpService/ListFloatingIps"
	FloatingIpService_ReleaseFloatingIp_FullMethodName      = "/limiquantix.network.v1.FloatingIpService/ReleaseFloatingIp"
	FloatingIpService_AssociateFloatingIp_FullMethodName    = "/limiquantix.network.v1.FloatingIpService/AssociateFloatingIp"
	FloatingIpService_DisassociateFloatingIp_FullMethodName = "/limiquantix.network.v1.FloatingIpService/DisassociateFloatingIp"
)

// FloatingIpServiceClient is the client API for FloatingIpService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FloatingIpService manages public IP assignments.
type FloatingIpServiceClient interface {
	// AllocateFloatingIp reserves a public IP.
	AllocateFloatingIp(ctx context.Context, in *AllocateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error)
	// GetFloatingIp retrieves a floating IP by ID.
	GetFloatingIp(ctx context.Context, in *GetFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error)
	// ListFloatingIps returns all floating IPs.
	ListFloatingIps(ctx context.Context, in *ListFloatingIpsRequest, opts ...grpc.CallOption) (*ListFloatingIpsResponse, error)
	// ReleaseFloatingIp releases a public IP.
	ReleaseFloatingIp(ctx context.Context, in *ReleaseFloatingIpRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AssociateFloatingIp assigns a floating IP to a port.
	AssociateFloatingIp(ctx context.Context, in *AssociateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error)
	// DisassociateFloatingIp removes a floating IP assignment.
	DisassociateFloatingIp(ctx context.Context, in *DisassociateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error)
}

type floatingIpServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFloatingIpServiceClient(cc grpc.ClientConnInterface) FloatingIpServiceClient {
	return &floatingIpServiceClient{cc}
}

func (c *floatingIpServiceClient) AllocateFloatingIp(ctx context.Context, in *AllocateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FloatingIp)
	err := c.cc.Invoke(ctx, FloatingIpService_AllocateFloatingIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *floatingIpServiceClient) GetFloatingIp(ctx context.Context, in *GetFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FloatingIp)
	err := c.cc.Invoke(ctx, FloatingIpService_GetFloatingIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *floatingIpServiceClient) ListFloatingIps(ctx context.Context, in *ListFloatingIpsRequest, opts ...grpc.CallOption) (*ListFloatingIpsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFloatingIpsResponse)
	err := c.cc.Invoke(ctx, FloatingIpService_ListFloatingIps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *floatingIpServiceClient) ReleaseFloatingIp(ctx context.Context, in *ReleaseFloatingIpRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FloatingIpService_ReleaseFloatingIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *floatingIpServiceClient) AssociateFloatingIp(ctx context.Context, in *AssociateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FloatingIp)
	err := c.cc.Invoke(ctx, FloatingIpService_AssociateFloatingIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *floatingIpServiceClient) DisassociateFloatingIp(ctx context.Context, in *DisassociateFloatingIpRequest, opts ...grpc.CallOption) (*FloatingIp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FloatingIp)
	err := c.cc.Invoke(ctx, FloatingIpService_DisassociateFloatingIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FloatingIpServiceServer is the server API for FloatingIpService service.
// All implementations should embed UnimplementedFloatingIpServiceServer
// for forward compatibility.
//
// FloatingIpService manages public IP assignments.
type FloatingIpServiceServer interface {
	// AllocateFloatingIp reserves a public IP.
	AllocateFloatingIp(context.Context, *AllocateFloatingIpRequest) (*FloatingIp, error)
	// GetFloatingIp retrieves a floating IP by ID.
	GetFloatingIp(context.Context, *GetFloatingIpRequest) (*FloatingIp, error)
	// ListFloatingIps returns all floating IPs.
	ListFloatingIps(context.Context, *ListFloatingIpsRequest) (*ListFloatingIpsResponse, error)
	// ReleaseFloatingIp releases a public IP.
	ReleaseFloatingIp(context.Context, *ReleaseFloatingIpRequest) (*emptypb.Empty, error)
	// AssociateFloatingIp assigns a floating IP to a port.
	AssociateFloatingIp(context.Context, *AssociateFloatingIpRequest) (*FloatingIp, error)
	// DisassociateFloatingIp removes a floating IP assignment.
	DisassociateFloatingIp(context.Context, *DisassociateFloatingIpRequest) (*FloatingIp, error)
}

// UnimplementedFloatingIpServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFloatingIpServiceServer struct{}

func (UnimplementedFloatingIpServiceServer) AllocateFloatingIp(context.Context, *AllocateFloatingIpRequest) (*FloatingIp, error) {
	return nil, status.Error(codes.Unimplemented, "method AllocateFloatingIp not implemented")
}
func (UnimplementedFloatingIpServiceServer) GetFloatingIp(context.Context, *GetFloatingIpRequest) (*FloatingIp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFloatingIp not implemented")
}
func (UnimplementedFloatingIpServiceServer) ListFloatingIps(context.Context, *ListFloatingIpsRequest) (*ListFloatingIpsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFloatingIps not implemented")
}
func (UnimplementedFloatingIpServiceServer) ReleaseFloatingIp(context.Context, *ReleaseFloatingIpRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReleaseFloatingIp not implemented")
}
func (UnimplementedFloatingIpServiceServer) AssociateFloatingIp(context.Context, *AssociateFloatingIpRequest) (*FloatingIp, error) {
	return nil, status.Error(codes.Unimplemented, "method AssociateFloatingIp not implemented")
}
func (UnimplementedFloatingIpServiceServer) DisassociateFloatingIp(context.Context, *DisassociateFloatingIpRequest) (*FloatingIp, error) {
	return nil, status.Error(codes.Unimplemented, "method DisassociateFloatingIp not implemented")
}
func (UnimplementedFloatingIpServiceServer) testEmbeddedByValue() {}

// UnsafeFloatingIpServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FloatingIpServiceServer will
// result in compilation errors.
type UnsafeFloatingIpServiceServer interface {
	mustEmbedUnimplementedFloatingIpServiceServer()
}

func RegisterFloatingIpServiceServer(s grpc.ServiceRegistrar, srv FloatingIpServiceServer) {
	// If the following call panics, it indicates UnimplementedFloatingIpServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FloatingIpService_ServiceDesc, srv)
}

func _FloatingIpService_AllocateFloatingIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateFloatingIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).AllocateFloatingIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_AllocateFloatingIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).AllocateFloatingIp(ctx, req.(*AllocateFloatingIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FloatingIpService_GetFloatingIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFloatingIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).GetFloatingIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_GetFloatingIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).GetFloatingIp(ctx, req.(*GetFloatingIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FloatingIpService_ListFloatingIps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFloatingIpsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).ListFloatingIps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_ListFloatingIps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).ListFloatingIps(ctx, req.(*ListFloatingIpsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FloatingIpService_ReleaseFloatingIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseFloatingIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).ReleaseFloatingIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_ReleaseFloatingIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).ReleaseFloatingIp(ctx, req.(*ReleaseFloatingIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FloatingIpService_AssociateFloatingIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateFloatingIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).AssociateFloatingIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_AssociateFloatingIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).AssociateFloatingIp(ctx, req.(*AssociateFloatingIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FloatingIpService_DisassociateFloatingIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisassociateFloatingIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatingIpServiceServer).DisassociateFloatingIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatingIpService_DisassociateFloatingIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatingIpServiceServer).DisassociateFloatingIp(ctx, req.(*DisassociateFloatingIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FloatingIpService_ServiceDesc is the grpc.ServiceDesc for FloatingIpService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FloatingIpService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.FloatingIpService",
	HandlerType: (*FloatingIpServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllocateFloatingIp",
			Handler:    _FloatingIpService_AllocateFloatingIp_Handler,
		},
		{
			MethodName: "GetFloatingIp",
			Handler:    _FloatingIpService_GetFloatingIp_Handler,
		},
		{
			MethodName: "ListFloatingIps",
			Handler:    _FloatingIpService_ListFloatingIps_Handler,
		},
		{
			MethodName: "ReleaseFloatingIp",
			Handler:    _FloatingIpService_ReleaseFloatingIp_Handler,
		},
		{
			MethodName: "AssociateFloatingIp",
			Handler:    _FloatingIpService_AssociateFloatingIp_Handler,
		},
		{
			MethodName: "DisassociateFloatingIp",
			Handler:    _FloatingIpService_DisassociateFloatingIp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}

const (
	LoadBalancerService_CreateLoadBalancer_FullMethodName   = "/limiquantix.network.v1.LoadBalancerService/CreateLoadBalancer"
	LoadBalancerService_GetLoadBalancer_FullMethodName      = "/limiquantix.network.v1.LoadBalancerService/GetLoadBalancer"
	LoadBalancerService_ListLoadBalancers_FullMethodName    = "/limiquantix.network.v1.LoadBalancerService/ListLoadBalancers"
	LoadBalancerService_UpdateLoadBalancer_FullMethodName   = "/limiquantix.network.v1.LoadBalancerService/UpdateLoadBalancer"
	LoadBalancerService_DeleteLoadBalancer_FullMethodName   = "/limiquantix.network.v1.LoadBalancerService/DeleteLoadBalancer"
	LoadBalancerService_AddListener_FullMethodName          = "/limiquantix.network.v1.LoadBalancerService/AddListener"
	LoadBalancerService_RemoveListener_FullMethodName       = "/limiquantix.network.v1.LoadBalancerService/RemoveListener"
	LoadBalancerService_AddPoolMember_FullMethodName        = "/limiquantix.network.v1.LoadBalancerService/AddPoolMember"
	LoadBalancerService_RemovePoolMember_FullMethodName     = "/limiquantix.network.v1.LoadBalancerService/RemovePoolMember"
	LoadBalancerService_GetLoadBalancerStats_FullMethodName = "/limiquantix.network.v1.LoadBalancerService/GetLoadBalancerStats"
)

// LoadBalancerServiceClient is the client API for LoadBalancerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LoadBalancerService manages load balancers.
type LoadBalancerServiceClient interface {
	// CreateLoadBalancer creates a new load balancer.
	CreateLoadBalancer(ctx context.Context, in *CreateLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// GetLoadBalancer retrieves a load balancer by ID.
	GetLoadBalancer(ctx context.Context, in *GetLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// ListLoadBalancers returns all load balancers.
	ListLoadBalancers(ctx context.Context, in *ListLoadBalancersRequest, opts ...grpc.CallOption) (*ListLoadBalancersResponse, error)
	// UpdateLoadBalancer updates configuration.
	UpdateLoadBalancer(ctx context.Context, in *UpdateLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// DeleteLoadBalancer removes a load balancer.
	DeleteLoadBalancer(ctx context.Context, in *DeleteLoadBalancerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AddListener adds a frontend listener.
	AddListener(ctx context.Context, in *AddListenerRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// RemoveListener removes a listener.
	RemoveListener(ctx context.Context, in *RemoveListenerRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// AddPoolMember adds a backend member.
	AddPoolMember(ctx context.Context, in *AddPoolMemberRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// RemovePoolMember removes a backend member.
	RemovePoolMember(ctx context.Context, in *RemovePoolMemberRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// GetLoadBalancerStats returns traffic statistics.
	GetLoadBalancerStats(ctx context.Context, in *GetLoadBalancerStatsRequest, opts ...grpc.CallOption) (*LoadBalancerStats, error)
}

type loadBalancerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadBalancerServiceClient(cc grpc.ClientConnInterface) LoadBalancerServiceClient {
	return &loadBalancerServiceClient{cc}
}

func (c *loadBalancerServiceClient) CreateLoadBalancer(ctx context.Context, in *CreateLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_CreateLoadBalancer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) GetLoadBalancer(ctx context.Context, in *GetLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_GetLoadBalancer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) ListLoadBalancers(ctx context.Context, in *ListLoadBalancersRequest, opts ...grpc.CallOption) (*ListLoadBalancersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLoadBalancersResponse)
	err := c.cc.Invoke(ctx, LoadBalancerService_ListLoadBalancers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) UpdateLoadBalancer(ctx context.Context, in *UpdateLoadBalancerRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_UpdateLoadBalancer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) DeleteLoadBalancer(ctx context.Context, in *DeleteLoadBalancerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LoadBalancerService_DeleteLoadBalancer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) AddListener(ctx context.Context, in *AddListenerRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_AddListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) RemoveListener(ctx context.Context, in *RemoveListenerRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_RemoveListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) AddPoolMember(ctx context.Context, in *AddPoolMemberRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_AddPoolMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) RemovePoolMember(ctx context.Context, in *RemovePoolMemberRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, LoadBalancerService_RemovePoolMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) GetLoadBalancerStats(ctx context.Context, in *GetLoadBalancerStatsRequest, opts ...grpc.CallOption) (*LoadBalancerStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadBalancerStats)
	err := c.cc.Invoke(ctx, LoadBalancerService_GetLoadBalancerStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadBalancerServiceServer is the server API for LoadBalancerService service.
// All implementations should embed UnimplementedLoadBalancerServiceServer
// for forward compatibility.
//
// LoadBalancerService manages load balancers.
type LoadBalancerServiceServer interface {
	// CreateLoadBalancer creates a new load balancer.
	CreateLoadBalancer(context.Context, *CreateLoadBalancerRequest) (*LoadBalancer, error)
	// GetLoadBalancer retrieves a load balancer by ID.
	GetLoadBalancer(context.Context, *GetLoadBalancerRequest) (*LoadBalancer, error)
	// ListLoadBalancers returns all load balancers.
	ListLoadBalancers(context.Context, *ListLoadBalancersRequest) (*ListLoadBalancersResponse, error)
	// UpdateLoadBalancer updates configuration.
	UpdateLoadBalancer(context.Context, *UpdateLoadBalancerRequest) (*LoadBalancer, error)
	// DeleteLoadBalancer removes a load balancer.
	DeleteLoadBalancer(context.Context, *DeleteLoadBalancerRequest) (*emptypb.Empty, error)
	// AddListener adds a frontend listener.
	AddListener(context.Context, *AddListenerRequest) (*LoadBalancer, error)
	// RemoveListener removes a listener.
	RemoveListener(context.Context, *RemoveListenerRequest) (*LoadBalancer, error)
	// AddPoolMember adds a backend member.
	AddPoolMember(context.Context, *AddPoolMemberRequest) (*LoadBalancer, error)
	// RemovePoolMember removes a backend member.
	RemovePoolMember(context.Context, *RemovePoolMemberRequest) (*LoadBalancer, error)
	// GetLoadBalancerStats returns traffic statistics.
	GetLoadBalancerStats(context.Context, *GetLoadBalancerStatsRequest) (*LoadBalancerStats, error)
}

// UnimplementedLoadBalancerServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoadBalancerServiceServer struct{}

func (UnimplementedLoadBalancerServiceServer) CreateLoadBalancer(context.Context, *CreateLoadBalancerRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateLoadBalancer not implemented")
}
func (UnimplementedLoadBalancerServiceServer) GetLoadBalancer(context.Context, *GetLoadBalancerRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLoadBalancer not implemented")
}
func (UnimplementedLoadBalancerServiceServer) ListLoadBalancers(context.Context, *ListLoadBalancersRequest) (*ListLoadBalancersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLoadBalancers not implemented")
}
func (UnimplementedLoadBalancerServiceServer) UpdateLoadBalancer(context.Context, *UpdateLoadBalancerRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateLoadBalancer not implemented")
}
func (UnimplementedLoadBalancerServiceServer) DeleteLoadBalancer(context.Context, *DeleteLoadBalancerRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteLoadBalancer not implemented")
}
func (UnimplementedLoadBalancerServiceServer) AddListener(context.Context, *AddListenerRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method AddListener not implemented")
}
func (UnimplementedLoadBalancerServiceServer) RemoveListener(context.Context, *RemoveListenerRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveListener not implemented")
}
func (UnimplementedLoadBalancerServiceServer) AddPoolMember(context.Context, *AddPoolMemberRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method AddPoolMember not implemented")
}
func (UnimplementedLoadBalancerServiceServer) RemovePoolMember(context.Context, *RemovePoolMemberRequest) (*LoadBalancer, error) {
	return nil, status.Error(codes.Unimplemented, "method RemovePoolMember not implemented")
}
func (UnimplementedLoadBalancerServiceServer) GetLoadBalancerStats(context.Context, *GetLoadBalancerStatsRequest) (*LoadBalancerStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLoadBalancerStats not implemented")
}
func (UnimplementedLoadBalancerServiceServer) testEmbeddedByValue() {}

// UnsafeLoadBalancerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadBalancerServiceServer will
// result in compilation errors.
type UnsafeLoadBalancerServiceServer interface {
	mustEmbedUnimplementedLoadBalancerServiceServer()
}

func RegisterLoadBalancerServiceServer(s grpc.ServiceRegistrar, srv LoadBalancerServiceServer) {
	// If the following call panics, it indicates UnimplementedLoadBalancerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoadBalancerService_ServiceDesc, srv)
}

func _LoadBalancerService_CreateLoadBalancer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLoadBalancerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).CreateLoadBalancer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_CreateLoadBalancer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).CreateLoadBalancer(ctx, req.(*CreateLoadBalancerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_GetLoadBalancer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLoadBalancerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).GetLoadBalancer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_GetLoadBalancer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).GetLoadBalancer(ctx, req.(*GetLoadBalancerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_ListLoadBalancers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLoadBalancersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).ListLoadBalancers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_ListLoadBalancers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).ListLoadBalancers(ctx, req.(*ListLoadBalancersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_UpdateLoadBalancer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLoadBalancerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).UpdateLoadBalancer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_UpdateLoadBalancer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).UpdateLoadBalancer(ctx, req.(*UpdateLoadBalancerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_DeleteLoadBalancer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLoadBalancerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).DeleteLoadBalancer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_DeleteLoadBalancer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).DeleteLoadBalancer(ctx, req.(*DeleteLoadBalancerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_AddListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddListenerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).AddListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_AddListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).AddListener(ctx, req.(*AddListenerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_RemoveListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveListenerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).RemoveListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_RemoveListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).RemoveListener(ctx, req.(*RemoveListenerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_AddPoolMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPoolMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).AddPoolMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_AddPoolMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).AddPoolMember(ctx, req.(*AddPoolMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_RemovePoolMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePoolMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).RemovePoolMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_RemovePoolMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).RemovePoolMember(ctx, req.(*RemovePoolMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_GetLoadBalancerStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLoadBalancerStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).GetLoadBalancerStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadBalancerService_GetLoadBalancerStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).GetLoadBalancerStats(ctx, req.(*GetLoadBalancerStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadBalancerService_ServiceDesc is the grpc.ServiceDesc for LoadBalancerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadBalancerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.LoadBalancerService",
	HandlerType: (*LoadBalancerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLoadBalancer",
			Handler:    _LoadBalancerService_CreateLoadBalancer_Handler,
		},
		{
			MethodName: "GetLoadBalancer",
			Handler:    _LoadBalancerService_GetLoadBalancer_Handler,
		},
		{
			MethodName: "ListLoadBalancers",
			Handler:    _LoadBalancerService_ListLoadBalancers_Handler,
		},
		{
			MethodName: "UpdateLoadBalancer",
			Handler:    _LoadBalancerService_UpdateLoadBalancer_Handler,
		},
		{
			MethodName: "DeleteLoadBalancer",
			Handler:    _LoadBalancerService_DeleteLoadBalancer_Handler,
		},
		{
			MethodName: "AddListener",
			Handler:    _LoadBalancerService_AddListener_Handler,
		},
		{
			MethodName: "RemoveListener",
			Handler:    _LoadBalancerService_RemoveListener_Handler,
		},
		{
			MethodName: "AddPoolMember",
			Handler:    _LoadBalancerService_AddPoolMember_Handler,
		},
		{
			MethodName: "RemovePoolMember",
			Handler:    _LoadBalancerService_RemovePoolMember_Handler,
		},
		{
			MethodName: "GetLoadBalancerStats",
			Handler:    _LoadBalancerService_GetLoadBalancerStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}

const (
	VpnServiceManager_CreateVpn_FullMethodName        = "/limiquantix.network.v1.VpnServiceManager/CreateVpn"
	VpnServiceManager_GetVpn_FullMethodName           = "/limiquantix.network.v1.VpnServiceManager/GetVpn"
	VpnServiceManager_ListVpns_FullMethodName         = "/limiquantix.network.v1.VpnServiceManager/ListVpns"
	VpnServiceManager_DeleteVpn_FullMethodName        = "/limiquantix.network.v1.VpnServiceManager/DeleteVpn"
	VpnServiceManager_AddConnection_FullMethodName    = "/limiquantix.network.v1.VpnServiceManager/AddConnection"
	VpnServiceManager_RemoveConnection_FullMethodName = "/limiquantix.network.v1.VpnServiceManager/RemoveConnection"
	VpnServiceManager_GetVpnStatus_FullMethodName     = "/limiquantix.network.v1.VpnServiceManager/GetVpnStatus"
)

// VpnServiceManagerClient is the client API for VpnServiceManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VpnServiceManager manages site-to-site VPNs.
type VpnServiceManagerClient interface {
	// CreateVpn creates a new VPN service.
	CreateVpn(ctx context.Context, in *CreateVpnRequest, opts ...grpc.CallOption) (*VpnService, error)
	// GetVpn retrieves a VPN service by ID.
	GetVpn(ctx context.Context, in *GetVpnRequest, opts ...grpc.CallOption) (*VpnService, error)
	// ListVpns returns all VPN services.
	ListVpns(ctx context.Context, in *ListVpnsRequest, opts ...grpc.CallOption) (*ListVpnsResponse, error)
	// DeleteVpn removes a VPN service.
	DeleteVpn(ctx context.Context, in *DeleteVpnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AddConnection adds a VPN connection.
	AddConnection(ctx context.Context, in *AddConnectionRequest, opts ...grpc.CallOption) (*VpnService, error)
	// RemoveConnection removes a VPN connection.
	RemoveConnection(ctx context.Context, in *RemoveConnectionRequest, opts ...grpc.CallOption) (*VpnService, error)
	// GetVpnStatus returns VPN tunnel status.
	GetVpnStatus(ctx context.Context, in *GetVpnStatusRequest, opts ...grpc.CallOption) (*VpnTunnelStatus, error)
}

type vpnServiceManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewVpnServiceManagerClient(cc grpc.ClientConnInterface) VpnServiceManagerClient {
	return &vpnServiceManagerClient{cc}
}

func (c *vpnServiceManagerClient) CreateVpn(ctx context.Context, in *CreateVpnRequest, opts ...grpc.CallOption) (*VpnService, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VpnService)
	err := c.cc.Invoke(ctx, VpnServiceManager_CreateVpn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) GetVpn(ctx context.Context, in *GetVpnRequest, opts ...grpc.CallOption) (*VpnService, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VpnService)
	err := c.cc.Invoke(ctx, VpnServiceManager_GetVpn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) ListVpns(ctx context.Context, in *ListVpnsRequest, opts ...grpc.CallOption) (*ListVpnsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVpnsResponse)
	err := c.cc.Invoke(ctx, VpnServiceManager_ListVpns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) DeleteVpn(ctx context.Context, in *DeleteVpnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VpnServiceManager_DeleteVpn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) AddConnection(ctx context.Context, in *AddConnectionRequest, opts ...grpc.CallOption) (*VpnService, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VpnService)
	err := c.cc.Invoke(ctx, VpnServiceManager_AddConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) RemoveConnection(ctx context.Context, in *RemoveConnectionRequest, opts ...grpc.CallOption) (*VpnService, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VpnService)
	err := c.cc.Invoke(ctx, VpnServiceManager_RemoveConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnServiceManagerClient) GetVpnStatus(ctx context.Context, in *GetVpnStatusRequest, opts ...grpc.CallOption) (*VpnTunnelStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VpnTunnelStatus)
	err := c.cc.Invoke(ctx, VpnServiceManager_GetVpnStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VpnServiceManagerServer is the server API for VpnServiceManager service.
// All implementations should embed UnimplementedVpnServiceManagerServer
// for forward compatibility.
//
// VpnServiceManager manages site-to-site VPNs.
type VpnServiceManagerServer interface {
	// CreateVpn creates a new VPN service.
	CreateVpn(context.Context, *CreateVpnRequest) (*VpnService, error)
	// GetVpn retrieves a VPN service by ID.
	GetVpn(context.Context, *GetVpnRequest) (*VpnService, error)
	// ListVpns returns all VPN services.
	ListVpns(context.Context, *ListVpnsRequest) (*ListVpnsResponse, error)
	// DeleteVpn removes a VPN service.
	DeleteVpn(context.Context, *DeleteVpnRequest) (*emptypb.Empty, error)
	// AddConnection adds a VPN connection.
	AddConnection(context.Context, *AddConnectionRequest) (*VpnService, error)
	// RemoveConnection removes a VPN connection.
	RemoveConnection(context.Context, *RemoveConnectionRequest) (*VpnService, error)
	// GetVpnStatus returns VPN tunnel status.
	GetVpnStatus(context.Context, *GetVpnStatusRequest) (*VpnTunnelStatus, error)
}

// UnimplementedVpnServiceManagerServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVpnServiceManagerServer struct{}

func (UnimplementedVpnServiceManagerServer) CreateVpn(context.Context, *CreateVpnRequest) (*VpnService, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVpn not implemented")
}
func (UnimplementedVpnServiceManagerServer) GetVpn(context.Context, *GetVpnRequest) (*VpnService, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVpn not implemented")
}
func (UnimplementedVpnServiceManagerServer) ListVpns(context.Context, *ListVpnsRequest) (*ListVpnsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVpns not implemented")
}
func (UnimplementedVpnServiceManagerServer) DeleteVpn(context.Context, *DeleteVpnRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVpn not implemented")
}
func (UnimplementedVpnServiceManagerServer) AddConnection(context.Context, *AddConnectionRequest) (*VpnService, error) {
	return nil, status.Error(codes.Unimplemented, "method AddConnection not implemented")
}
func (UnimplementedVpnServiceManagerServer) RemoveConnection(context.Context, *RemoveConnectionRequest) (*VpnService, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveConnection not implemented")
}
func (UnimplementedVpnServiceManagerServer) GetVpnStatus(context.Context, *GetVpnStatusRequest) (*VpnTunnelStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVpnStatus not implemented")
}
func (UnimplementedVpnServiceManagerServer) testEmbeddedByValue() {}

// UnsafeVpnServiceManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VpnServiceManagerServer will
// result in compilation errors.
type UnsafeVpnServiceManagerServer interface {
	mustEmbedUnimplementedVpnServiceManagerServer()
}

func RegisterVpnServiceManagerServer(s grpc.ServiceRegistrar, srv VpnServiceManagerServer) {
	// If the following call panics, it indicates UnimplementedVpnServiceManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VpnServiceManager_ServiceDesc, srv)
}

func _VpnServiceManager_CreateVpn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVpnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).CreateVpn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_CreateVpn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).CreateVpn(ctx, req.(*CreateVpnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_GetVpn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVpnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).GetVpn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_GetVpn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).GetVpn(ctx, req.(*GetVpnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_ListVpns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVpnsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).ListVpns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_ListVpns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).ListVpns(ctx, req.(*ListVpnsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_DeleteVpn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVpnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).DeleteVpn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_DeleteVpn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).DeleteVpn(ctx, req.(*DeleteVpnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_AddConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).AddConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_AddConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).AddConnection(ctx, req.(*AddConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_RemoveConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).RemoveConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_RemoveConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).RemoveConnection(ctx, req.(*RemoveConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnServiceManager_GetVpnStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVpnStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnServiceManagerServer).GetVpnStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnServiceManager_GetVpnStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnServiceManagerServer).GetVpnStatus(ctx, req.(*GetVpnStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VpnServiceManager_ServiceDesc is the grpc.ServiceDesc for VpnServiceManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VpnServiceManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "limiquantix.network.v1.VpnServiceManager",
	HandlerType: (*VpnServiceManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVpn",
			Handler:    _VpnServiceManager_CreateVpn_Handler,
		},
		{
			MethodName: "GetVpn",
			Handler:    _VpnServiceManager_GetVpn_Handler,
		},
		{
			MethodName: "ListVpns",
			Handler:    _VpnServiceManager_ListVpns_Handler,
		},
		{
			MethodName: "DeleteVpn",
			Handler:    _VpnServiceManager_DeleteVpn_Handler,
		},
		{
			MethodName: "AddConnection",
			Handler:    _VpnServiceManager_AddConnection_Handler,
		},
		{
			MethodName: "RemoveConnection",
			Handler:    _VpnServiceManager_RemoveConnection_Handler,
		},
		{
			MethodName: "GetVpnStatus",
			Handler:    _VpnServiceManager_GetVpnStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "limiquantix/network/v1/network_service.proto",
}
