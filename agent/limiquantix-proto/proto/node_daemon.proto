syntax = "proto3";

package limiquantix.node.v1;

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// =============================================================================
// NODE DAEMON SERVICE
// =============================================================================
// This service runs on each hypervisor node and is called by the control plane
// to manage VMs directly on the physical host.

service NodeDaemonService {
  // =========================================================================
  // Health & Status
  // =========================================================================
  
  // Health check endpoint
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  
  // Get node information and capabilities
  rpc GetNodeInfo(google.protobuf.Empty) returns (NodeInfoResponse);
  
  // =========================================================================
  // VM Lifecycle Operations
  // =========================================================================
  
  // Create a new VM (does not start it)
  rpc CreateVM(CreateVMOnNodeRequest) returns (CreateVMOnNodeResponse);
  
  // Start a VM
  rpc StartVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // Stop a VM gracefully (with timeout)
  rpc StopVM(StopVMRequest) returns (google.protobuf.Empty);
  
  // Force stop a VM (power off)
  rpc ForceStopVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // Reboot a VM
  rpc RebootVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // Pause a VM (freeze execution)
  rpc PauseVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // Resume a paused VM
  rpc ResumeVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // Delete a VM (must be stopped first)
  rpc DeleteVM(VMIdRequest) returns (google.protobuf.Empty);
  
  // =========================================================================
  // VM Status
  // =========================================================================
  
  // Get status of a specific VM
  rpc GetVMStatus(VMIdRequest) returns (VMStatusResponse);
  
  // List all VMs on this node
  rpc ListVMs(google.protobuf.Empty) returns (ListVMsOnNodeResponse);
  
  // =========================================================================
  // Console Access
  // =========================================================================
  
  // Get console connection information (VNC/SPICE)
  rpc GetConsole(VMIdRequest) returns (ConsoleInfoResponse);
  
  // Get VM QEMU logs for troubleshooting
  rpc GetVMLogs(GetVMLogsRequest) returns (GetVMLogsResponse);
  
  // =========================================================================
  // Snapshots
  // =========================================================================
  
  // Create a snapshot
  rpc CreateSnapshot(CreateSnapshotRequest) returns (SnapshotResponse);
  
  // Revert to a snapshot
  rpc RevertSnapshot(RevertSnapshotRequest) returns (google.protobuf.Empty);
  
  // Delete a snapshot
  rpc DeleteSnapshot(DeleteSnapshotRequest) returns (google.protobuf.Empty);
  
  // List all snapshots for a VM
  rpc ListSnapshots(VMIdRequest) returns (ListSnapshotsResponse);
  
  // =========================================================================
  // Hot-plug Operations
  // =========================================================================
  
  // Attach a network interface to a running VM (hot-plug)
  rpc AttachNIC(AttachNICRequest) returns (google.protobuf.Empty);
  
  // Detach a network interface from a running VM (hot-unplug)
  rpc DetachNIC(DetachNICRequest) returns (google.protobuf.Empty);
  
  // =========================================================================
  // Metrics & Events (Streaming)
  // =========================================================================
  
  // Stream node and VM metrics
  rpc StreamMetrics(StreamMetricsRequest) returns (stream NodeMetrics);
  
  // Stream node events (VM started, stopped, crashed, etc.)
  rpc StreamEvents(google.protobuf.Empty) returns (stream NodeEvent);
  
  // =========================================================================
  // Guest Agent Operations
  // =========================================================================
  
  // Check if guest agent is available and responding
  rpc PingAgent(VMIdRequest) returns (AgentPingResponse);
  
  // Execute a command inside the VM via guest agent
  rpc ExecuteInGuest(ExecuteInGuestRequest) returns (ExecuteInGuestResponse);
  
  // Read a file from inside the VM
  rpc ReadGuestFile(ReadGuestFileRequest) returns (ReadGuestFileResponse);
  
  // Write a file inside the VM
  rpc WriteGuestFile(WriteGuestFileRequest) returns (WriteGuestFileResponse);
  
  // Request guest agent to shutdown/reboot the VM gracefully
  rpc GuestShutdown(GuestShutdownRequest) returns (GuestShutdownResponse);
  
  // Quiesce filesystems for safe snapshots (fsfreeze/VSS)
  rpc QuiesceFilesystems(QuiesceFilesystemsRequest) returns (QuiesceFilesystemsResponse);
  
  // Thaw filesystems after snapshot
  rpc ThawFilesystems(ThawFilesystemsRequest) returns (ThawFilesystemsResponse);
  
  // Sync time after VM resume
  rpc SyncTime(SyncTimeRequest) returns (SyncTimeResponse);
  
  // =========================================================================
  // Storage Pool Operations
  // =========================================================================
  
  // Initialize/mount a storage pool on this node
  rpc InitStoragePool(InitStoragePoolRequest) returns (StoragePoolInfoResponse);
  
  // Destroy/unmount a storage pool
  rpc DestroyStoragePool(StoragePoolIdRequest) returns (google.protobuf.Empty);
  
  // Get storage pool information
  rpc GetStoragePoolInfo(StoragePoolIdRequest) returns (StoragePoolInfoResponse);
  
  // List all storage pools on this node
  rpc ListStoragePools(google.protobuf.Empty) returns (ListStoragePoolsResponse);

  // List files in a storage pool
  rpc ListStoragePoolFiles(ListStoragePoolFilesRequest) returns (ListStoragePoolFilesResponse);
  
  // =========================================================================
  // Storage Volume Operations
  // =========================================================================
  
  // List volumes in a storage pool
  rpc ListVolumes(ListVolumesRequest) returns (ListVolumesResponse);
  
  // Create a volume in a storage pool
  rpc CreateVolume(CreateVolumeRequest) returns (VolumeInfoResponse);
  
  // Delete a volume
  rpc DeleteVolume(VolumeIdRequest) returns (google.protobuf.Empty);
  
  // List ISO images
  rpc ListImages(google.protobuf.Empty) returns (ListImagesResponse);
  
  // Resize a volume
  rpc ResizeVolume(ResizeVolumeRequest) returns (google.protobuf.Empty);
  
  // Clone a volume
  rpc CloneVolume(CloneVolumeRequest) returns (google.protobuf.Empty);
  
  // Get volume attach information (libvirt disk XML)
  rpc GetVolumeAttachInfo(VolumeIdRequest) returns (VolumeAttachInfoResponse);
  
  // Create a volume snapshot
  rpc CreateVolumeSnapshot(CreateVolumeSnapshotRequest) returns (google.protobuf.Empty);
  
  // =========================================================================
  // CD-ROM/Media Operations
  // =========================================================================
  
  // Change CD-ROM media (mount/eject ISO)
  rpc ChangeMedia(ChangeMediaRequest) returns (google.protobuf.Empty);
}

// =============================================================================
// REQUEST/RESPONSE MESSAGES
// =============================================================================

// Health Check
message HealthCheckRequest {}

message HealthCheckResponse {
  bool healthy = 1;
  string version = 2;
  string hypervisor = 3;       // "libvirt", "cloud-hypervisor"
  string hypervisor_version = 4;
  uint64 uptime_seconds = 5;
}

// Node Info
message NodeInfoResponse {
  string node_id = 1;
  string hostname = 2;
  string management_ip = 3;
  
  // Hardware info
  string cpu_model = 4;
  uint32 cpu_cores = 5;
  uint64 memory_total_bytes = 6;
  uint64 memory_available_bytes = 7;
  
  // OS info
  string os_name = 8;
  string os_version = 9;
  string kernel_version = 10;
  uint64 uptime_seconds = 11;
  
  // Hypervisor capabilities
  string hypervisor_name = 12;
  string hypervisor_version = 13;
  bool supports_live_migration = 14;
  bool supports_snapshots = 15;
  bool supports_hotplug = 16;
  uint32 max_vcpus = 17;
  uint64 max_memory_bytes = 18;
}

// VM Identification
message VMIdRequest {
  string vm_id = 1;
}

// Create VM - matches backend proto exactly
message CreateVMOnNodeRequest {
  string vm_id = 1;
  string name = 2;
  VMSpec spec = 3;
  map<string, string> labels = 4;
}

message VMSpec {
  // CPU configuration
  uint32 cpu_cores = 1;
  uint32 cpu_sockets = 2;
  uint32 cpu_threads_per_core = 3;
  
  // Memory configuration (in MiB)
  uint64 memory_mib = 4;
  bool memory_hugepages = 5;
  
  // Boot configuration
  Firmware firmware = 6;
  repeated BootDevice boot_order = 7;
  
  // Devices
  repeated DiskSpec disks = 8;
  repeated NicSpec nics = 9;
  repeated CdromSpec cdroms = 10;
  
  // Console
  ConsoleSpec console = 11;
  
  // Cloud-init / provisioning configuration
  CloudInitConfig cloud_init = 12;
  
  // Guest OS family - determines hardware configuration (timers, video, CPU mode).
  // This is similar to VMware's Guest OS selection - affects virtual hardware behavior.
  // Values: "rhel", "debian", "fedora", "windows_server", "windows_desktop", "generic_linux", etc.
  string guest_os = 13;
}

// Cloud-init configuration for automated VM provisioning
message CloudInitConfig {
  // User-data (YAML format, typically #cloud-config)
  // Contains: users, packages, runcmd, write_files, etc.
  string user_data = 1;
  
  // Meta-data (JSON format)
  // Contains: instance-id, local-hostname, etc.
  string meta_data = 2;
  
  // Network configuration (Netplan v2 format, optional)
  string network_config = 3;
  
  // Vendor-data (optional, for provider-specific config)
  string vendor_data = 4;
}

enum Firmware {
  FIRMWARE_BIOS = 0;
  FIRMWARE_UEFI = 1;
}

enum BootDevice {
  BOOT_DEVICE_DISK = 0;
  BOOT_DEVICE_CDROM = 1;
  BOOT_DEVICE_NETWORK = 2;
}

message DiskSpec {
  string id = 1;
  string path = 2;              // Path to disk image (empty = auto-create)
  uint64 size_gib = 3;
  DiskBus bus = 4;
  DiskFormat format = 5;
  bool readonly = 6;
  bool bootable = 7;
  
  // QoS settings
  uint64 iops_limit = 8;
  uint64 throughput_mbps = 9;
  
  // Cloud image support
  string backing_file = 10;     // Path to backing image (e.g., cloud image)
                                // If set, creates a copy-on-write overlay
  
  // Storage pool to create disk in (required when path is empty)
  // This should be a pool_id from ListStoragePools (e.g., "SSD-local01", "nfs-xxx")
  string pool_id = 11;
}

enum DiskBus {
  DISK_BUS_VIRTIO = 0;
  DISK_BUS_SCSI = 1;
  DISK_BUS_SATA = 2;
  DISK_BUS_IDE = 3;
}

enum DiskFormat {
  DISK_FORMAT_QCOW2 = 0;
  DISK_FORMAT_RAW = 1;
}

message NicSpec {
  string id = 1;
  string mac_address = 2;       // Optional, auto-generated if empty
  string bridge = 3;            // Bridge to connect to
  string network = 4;           // Virtual network name
  NicModel model = 5;
  
  // QoS settings
  uint64 bandwidth_mbps = 6;
}

enum NicModel {
  NIC_MODEL_VIRTIO = 0;
  NIC_MODEL_E1000 = 1;
  NIC_MODEL_RTL8139 = 2;
}

message CdromSpec {
  string id = 1;
  string iso_path = 2;          // Path to ISO file
  bool bootable = 3;
}

message ConsoleSpec {
  bool vnc_enabled = 1;
  uint32 vnc_port = 2;          // 0 = auto-assign
  string vnc_password = 3;      // Optional
  bool spice_enabled = 4;
  uint32 spice_port = 5;
}

message CreateVMOnNodeResponse {
  string vm_id = 1;
  bool created = 2;
  string message = 3;
}

// Stop VM
message StopVMRequest {
  string vm_id = 1;
  uint32 timeout_seconds = 2;   // Graceful shutdown timeout
}

// VM Status
message VMStatusResponse {
  string vm_id = 1;
  string name = 2;
  PowerState state = 3;
  double cpu_usage_percent = 4;
  uint64 memory_used_bytes = 5;
  uint64 memory_total_bytes = 6;
  google.protobuf.Timestamp started_at = 7;
  
  // Guest agent information (populated when agent is running)
  GuestAgentInfo guest_agent = 8;
  
  // Storage information
  repeated DiskSpec disks = 9;
}

// Information reported by the guest agent
message GuestAgentInfo {
  // Whether the guest agent is connected
  bool connected = 1;
  
  // Agent version
  string version = 2;
  
  // Guest OS information
  string os_name = 3;
  string os_version = 4;
  string kernel_version = 5;
  string hostname = 6;
  
  // IP addresses reported by the agent
  repeated string ip_addresses = 7;
  
  // Network interfaces with detailed info
  repeated GuestNetworkInterface interfaces = 8;
  
  // Real resource usage from inside the VM
  GuestResourceUsage resource_usage = 9;
  
  // Agent capabilities
  repeated string capabilities = 10;
  
  // Last update timestamp
  google.protobuf.Timestamp last_seen = 11;
}

// Network interface information from guest agent
message GuestNetworkInterface {
  string name = 1;
  string mac_address = 2;
  repeated string ipv4_addresses = 3;
  repeated string ipv6_addresses = 4;
  bool is_up = 5;
}

// Resource usage as reported by the guest agent (actual in-use, not allocated)
message GuestResourceUsage {
  // CPU usage percentage (0-100)
  double cpu_usage_percent = 1;
  
  // Memory usage
  uint64 memory_total_bytes = 2;
  uint64 memory_used_bytes = 3;
  uint64 memory_available_bytes = 4;
  
  // Swap usage
  uint64 swap_total_bytes = 5;
  uint64 swap_used_bytes = 6;
  
  // Load averages
  double load_avg_1 = 7;
  double load_avg_5 = 8;
  double load_avg_15 = 9;
  
  // Disk usage per mount point
  repeated GuestDiskUsage disks = 10;
  
  // Process count
  uint32 process_count = 11;
  
  // System uptime
  uint64 uptime_seconds = 12;
}

// Disk usage from guest agent
message GuestDiskUsage {
  string mount_point = 1;
  string device = 2;
  string filesystem = 3;
  uint64 total_bytes = 4;
  uint64 used_bytes = 5;
  uint64 available_bytes = 6;
  double usage_percent = 7;
}

enum PowerState {
  POWER_STATE_UNKNOWN = 0;
  POWER_STATE_RUNNING = 1;
  POWER_STATE_STOPPED = 2;
  POWER_STATE_PAUSED = 3;
  POWER_STATE_SUSPENDED = 4;
  POWER_STATE_CRASHED = 5;
}

message ListVMsOnNodeResponse {
  repeated VMStatusResponse vms = 1;
}

// Console
message ConsoleInfoResponse {
  string console_type = 1;      // "vnc" or "spice"
  string host = 2;
  uint32 port = 3;
  string password = 4;          // VNC password if set
  string websocket_path = 5;    // For noVNC
}

// VM Logs - for troubleshooting QEMU/libvirt issues
message GetVMLogsRequest {
  string vm_id = 1;
  // Number of lines to return (default: 100, max: 1000)
  uint32 lines = 2;
}

message GetVMLogsResponse {
  string vm_id = 1;
  string vm_name = 2;
  // QEMU log content (last N lines from /var/log/libvirt/qemu/{vm_name}.log)
  string qemu_log = 3;
  // Log file path
  string log_path = 4;
  // Total log file size in bytes
  uint64 log_size_bytes = 5;
  // Number of lines returned
  uint32 lines_returned = 6;
  // Whether the log was truncated
  bool truncated = 7;
  // Timestamp of last modification (ISO 8601)
  string last_modified = 8;
}

// Snapshots
message CreateSnapshotRequest {
  string vm_id = 1;
  string name = 2;
  string description = 3;
  bool quiesce = 4;             // Request guest agent to freeze filesystems
  bool disk_only = 5;           // If true, only snapshot disks (no memory state) - required for VMs with invtsc/host-passthrough CPU
}

message SnapshotResponse {
  string snapshot_id = 1;
  string name = 2;
  string description = 3;
  google.protobuf.Timestamp created_at = 4;
  PowerState vm_state = 5;      // State of VM when snapshot was taken
  string parent_id = 6;         // Parent snapshot ID (for tree)
}

message RevertSnapshotRequest {
  string vm_id = 1;
  string snapshot_id = 2;
}

message DeleteSnapshotRequest {
  string vm_id = 1;
  string snapshot_id = 2;
}

message ListSnapshotsResponse {
  repeated SnapshotResponse snapshots = 1;
}

// Hot-plug Operations
message AttachNICRequest {
  string vm_id = 1;
  NicSpec nic = 2;
}

message DetachNICRequest {
  string vm_id = 1;
  string nic_id = 2;
}

// Metrics
message StreamMetricsRequest {
  uint32 interval_seconds = 1;  // Reporting interval
}

message NodeMetrics {
  google.protobuf.Timestamp timestamp = 1;
  
  // Node-level metrics
  double cpu_usage_percent = 2;
  uint64 memory_used_bytes = 3;
  uint64 memory_total_bytes = 4;
  
  // Per-VM metrics
  repeated VMMetrics vms = 5;
}

message VMMetrics {
  string vm_id = 1;
  string name = 2;
  double cpu_usage_percent = 3;
  uint64 memory_used_bytes = 4;
  uint64 disk_read_bytes = 5;
  uint64 disk_write_bytes = 6;
  uint64 network_rx_bytes = 7;
  uint64 network_tx_bytes = 8;
}

// Events
message NodeEvent {
  string id = 1;
  google.protobuf.Timestamp timestamp = 2;
  EventType type = 3;
  string vm_id = 4;             // If event is VM-related
  string message = 5;
  map<string, string> metadata = 6;
}

enum EventType {
  EVENT_TYPE_UNKNOWN = 0;
  EVENT_TYPE_VM_STARTED = 1;
  EVENT_TYPE_VM_STOPPED = 2;
  EVENT_TYPE_VM_PAUSED = 3;
  EVENT_TYPE_VM_RESUMED = 4;
  EVENT_TYPE_VM_CRASHED = 5;
  EVENT_TYPE_VM_REBOOTED = 6;
  EVENT_TYPE_SNAPSHOT_CREATED = 7;
  EVENT_TYPE_SNAPSHOT_REVERTED = 8;
  EVENT_TYPE_SNAPSHOT_DELETED = 9;
  EVENT_TYPE_NODE_OVERLOADED = 10;
  EVENT_TYPE_NODE_RECOVERED = 11;
  EVENT_TYPE_AGENT_CONNECTED = 12;
  EVENT_TYPE_AGENT_DISCONNECTED = 13;
}

// =============================================================================
// GUEST AGENT OPERATIONS
// =============================================================================

// Ping the guest agent
message AgentPingResponse {
  bool connected = 1;
  string version = 2;
  uint64 uptime_seconds = 3;
  string error = 4;
}

// Execute command in guest
message ExecuteInGuestRequest {
  string vm_id = 1;
  string command = 2;
  repeated string args = 3;
  uint32 timeout_seconds = 4;
  bool wait_for_exit = 5;
  string working_directory = 6;
  map<string, string> environment = 7;
}

message ExecuteInGuestResponse {
  bool success = 1;
  int32 exit_code = 2;
  string stdout = 3;
  string stderr = 4;
  bool timed_out = 5;
  uint64 duration_ms = 6;
  string error = 7;
}

// Read file from guest
message ReadGuestFileRequest {
  string vm_id = 1;
  string path = 2;
  uint64 offset = 3;
  uint64 max_size = 4;  // Maximum bytes to read (0 = all)
}

message ReadGuestFileResponse {
  bool success = 1;
  bytes data = 2;
  uint64 total_size = 3;
  bool eof = 4;
  string error = 5;
}

// Write file to guest
message WriteGuestFileRequest {
  string vm_id = 1;
  string path = 2;
  bytes data = 3;
  uint32 mode = 4;      // File permissions (e.g., 0644)
  bool create_parents = 5;
}

message WriteGuestFileResponse {
  bool success = 1;
  uint64 bytes_written = 2;
  string error = 3;
}

// Guest shutdown request
message GuestShutdownRequest {
  string vm_id = 1;
  bool reboot = 2;      // true = reboot, false = poweroff
  uint32 delay_seconds = 3;
  string message = 4;   // Broadcast message
}

message GuestShutdownResponse {
  bool accepted = 1;
  string error = 2;
}

// =============================================================================
// FILESYSTEM QUIESCING (for safe snapshots)
// =============================================================================

message QuiesceFilesystemsRequest {
  string vm_id = 1;
  // Mount points to freeze (empty = all writable filesystems)
  repeated string mount_points = 2;
  // Timeout in seconds (default: 60, auto-thaw after this)
  uint32 timeout_seconds = 3;
  // Run pre-freeze scripts (e.g., database flush hooks)
  bool run_pre_freeze_scripts = 4;
}

message QuiesceFilesystemsResponse {
  bool success = 1;
  // List of frozen filesystems
  repeated FrozenFilesystem frozen = 2;
  string error = 3;
  // Token for thaw correlation
  string quiesce_token = 4;
}

message FrozenFilesystem {
  string mount_point = 1;
  string device = 2;
  string filesystem = 3;
  bool frozen = 4;
  string error = 5;
}

message ThawFilesystemsRequest {
  string vm_id = 1;
  // Token from QuiesceFilesystemsResponse
  string quiesce_token = 2;
  // Mount points to thaw (empty = all frozen)
  repeated string mount_points = 3;
  // Run post-thaw scripts
  bool run_post_thaw_scripts = 4;
}

message ThawFilesystemsResponse {
  bool success = 1;
  repeated string thawed_mount_points = 2;
  string error = 3;
  // Duration filesystems were frozen (ms)
  uint64 frozen_duration_ms = 4;
}

message SyncTimeRequest {
  string vm_id = 1;
  // Force immediate sync vs gradual drift correction
  bool force = 2;
}

message SyncTimeResponse {
  bool success = 1;
  // Time offset corrected (seconds, can be negative)
  double offset_seconds = 2;
  // Time source used (ntp, chrony, manual)
  string time_source = 3;
  string error = 4;
}

// =============================================================================
// STORAGE POOL OPERATIONS
// =============================================================================

// Storage pool type
enum StoragePoolType {
  STORAGE_POOL_TYPE_UNSPECIFIED = 0;
  STORAGE_POOL_TYPE_LOCAL_DIR = 1;
  STORAGE_POOL_TYPE_LOCAL_LVM = 2;
  STORAGE_POOL_TYPE_NFS = 3;
  STORAGE_POOL_TYPE_CEPH_RBD = 4;
  STORAGE_POOL_TYPE_CEPH_FS = 5;
  STORAGE_POOL_TYPE_ISCSI = 6;
}

// Initialize storage pool request
message InitStoragePoolRequest {
  string pool_id = 1;
  StoragePoolType type = 2;
  StoragePoolConfig config = 3;
}

// Storage pool configuration (matches Rust types)
message StoragePoolConfig {
  // Local directory configuration
  LocalDirPoolConfig local = 1;
  
  // NFS configuration
  NfsPoolConfig nfs = 2;
  
  // Ceph RBD configuration
  CephPoolConfig ceph = 3;
  
  // iSCSI configuration
  IscsiPoolConfig iscsi = 4;
}

message LocalDirPoolConfig {
  string path = 1;
  // Optional capacity limit in GiB (0 = unlimited, uses filesystem capacity)
  optional uint64 capacity_gib = 2;
}

message NfsPoolConfig {
  string server = 1;        // e.g., "192.168.1.50"
  string export_path = 2;   // e.g., "/mnt/ssd-pool"
  string version = 3;       // "3", "4", "4.1", "4.2"
  string options = 4;       // Mount options
  string mount_point = 5;   // Custom mount point (optional)
}

message CephPoolConfig {
  string cluster_id = 1;
  string pool_name = 2;           // Ceph RBD pool name
  repeated string monitors = 3;   // ["10.0.0.1:6789"]
  string user = 4;                // e.g., "libvirt"
  string keyring_path = 5;        // e.g., "/etc/ceph/ceph.client.libvirt.keyring"
  string namespace = 6;           // For multi-tenancy
  string secret_uuid = 7;         // Libvirt secret UUID (auto-created if empty)
}

message IscsiPoolConfig {
  string portal = 1;        // e.g., "192.168.1.50:3260"
  string target = 2;        // e.g., "iqn.2023-01.com.storage:ssd-pool"
  bool chap_enabled = 3;
  string chap_user = 4;
  string chap_password = 5;
  uint32 lun = 6;
  string volume_group = 7;  // LVM VG name
}

// Storage pool ID request
message StoragePoolIdRequest {
  string pool_id = 1;
}

// Storage pool info response
message StoragePoolInfoResponse {
  string pool_id = 1;
  StoragePoolType type = 2;
  
  // Path or identifier
  string mount_path = 3;     // For NFS, local
  string device_path = 4;    // For iSCSI, LVM
  string rbd_pool = 5;       // For Ceph
  
  // Capacity
  uint64 total_bytes = 6;
  uint64 available_bytes = 7;
  uint64 used_bytes = 8;
  
  // Volume count
  uint32 volume_count = 9;
}

// List storage pools response
message ListStoragePoolsResponse {
  repeated StoragePoolInfoResponse pools = 1;
}

// List files in a storage pool
message ListStoragePoolFilesRequest {
  string pool_id = 1;
  string path = 2;  // Relative path within the pool (empty for root)
}

message ListStoragePoolFilesResponse {
  repeated StoragePoolFileEntry entries = 1;
  string current_path = 2;
}

message StoragePoolFileEntry {
  string name = 1;
  string path = 2;  // Full path relative to pool root
  bool is_directory = 3;
  uint64 size_bytes = 4;
  string modified_at = 5;  // ISO 8601 timestamp
  string file_type = 6;    // "qcow2", "iso", "vmdk", "directory", etc.
  string permissions = 7;  // Unix-style permissions string
}

// =============================================================================
// STORAGE VOLUME OPERATIONS
// =============================================================================

// Volume ID request
message VolumeIdRequest {
  string pool_id = 1;
  string volume_id = 2;
}

// Create volume request
message CreateVolumeRequest {
  string pool_id = 1;
  string volume_id = 2;
  uint64 size_bytes = 3;
  
  // Optional source for the volume
  VolumeSourceType source_type = 4;
  string source_id = 5;   // Clone source ID, image path, or snapshot ID
}

enum VolumeSourceType {
  VOLUME_SOURCE_EMPTY = 0;      // Create empty volume
  VOLUME_SOURCE_CLONE = 1;      // Clone from existing volume
  VOLUME_SOURCE_IMAGE = 2;      // Create from backing image
  VOLUME_SOURCE_SNAPSHOT = 3;   // Restore from snapshot
}

// Resize volume request
message ResizeVolumeRequest {
  string pool_id = 1;
  string volume_id = 2;
  uint64 new_size_bytes = 3;
}

// Clone volume request
message CloneVolumeRequest {
  string pool_id = 1;
  string source_volume_id = 2;
  string dest_volume_id = 3;
}

// Volume attach info response
message VolumeAttachInfoResponse {
  string volume_id = 1;
  string path = 2;           // Path or RBD spec
  string disk_xml = 3;       // Libvirt disk XML snippet
}

// Create volume snapshot request
message CreateVolumeSnapshotRequest {
  string pool_id = 1;
  string volume_id = 2;
  string snapshot_id = 3;
}

// List volumes request
message ListVolumesRequest {
  string pool_id = 1;
}

// Volume info response
message VolumeInfoResponse {
  string volume_id = 1;
  string pool_id = 2;
  uint64 size_bytes = 3;
  string format = 4;       // "qcow2", "raw"
  string path = 5;
  string attached_to = 6;  // VM ID if attached
}

// List volumes response
message ListVolumesResponse {
  repeated VolumeInfoResponse volumes = 1;
}

// Image info (ISO files)
message ImageInfo {
  string image_id = 1;
  string name = 2;
  string path = 3;
  uint64 size_bytes = 4;
  string format = 5;       // "iso", "qcow2", etc.
}

// List images response
message ListImagesResponse {
  repeated ImageInfo images = 1;
}

// CD-ROM Media Change
message ChangeMediaRequest {
  string vm_id = 1;
  // Device name (e.g., "sda", "hda", or the cdrom device id)
  string device = 2;
  // ISO path to mount (empty string to eject)
  string iso_path = 3;
}
