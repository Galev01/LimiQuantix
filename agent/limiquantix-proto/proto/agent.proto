// =============================================================================
// GUEST AGENT PROTOCOL
// =============================================================================
// This protocol defines the communication between the Node Daemon (host) and
// the Guest Agent (inside VM) over a virtio-serial channel.
//
// Transport: Length-prefixed protobuf over virtio-serial
// Framing: 4 bytes (big-endian length) + N bytes (protobuf payload)

syntax = "proto3";

package limiquantix.agent.v1;

import "google/protobuf/timestamp.proto";

// =============================================================================
// ENVELOPE MESSAGE
// =============================================================================
// All messages are wrapped in AgentMessage for correlation and routing.

message AgentMessage {
  // Unique message ID for request/response correlation
  string message_id = 1;
  
  // Timestamp of when the message was created
  google.protobuf.Timestamp timestamp = 2;
  
  oneof payload {
    // =========================================================================
    // Host -> Guest (Requests)
    // =========================================================================
    
    // Health check
    PingRequest ping = 10;
    
    // Command execution
    ExecuteRequest execute = 11;
    
    // File operations
    FileWriteRequest file_write = 12;
    FileReadRequest file_read = 13;
    
    // Lifecycle operations
    ShutdownRequest shutdown = 14;
    ResetPasswordRequest reset_password = 15;
    
    // Network configuration
    ConfigureNetworkRequest configure_network = 16;
    
    // Filesystem quiescing (for safe snapshots)
    QuiesceFilesystemsRequest quiesce = 17;
    ThawFilesystemsRequest thaw = 18;
    
    // Time synchronization (after resume from suspend)
    SyncTimeRequest sync_time = 19;
    
    // Directory operations
    ListDirectoryRequest list_directory = 20;
    CreateDirectoryRequest create_directory = 21;
    FileDeleteRequest file_delete = 22;
    FileStatRequest file_stat = 23;
    
    // Display operations (desktop integration)
    DisplayResizeRequest display_resize = 24;
    
    // Clipboard operations
    ClipboardUpdateRequest clipboard_update = 25;
    ClipboardGetRequest clipboard_get = 26;
    
    // Process management
    ListProcessesRequest list_processes = 27;
    KillProcessRequest kill_process = 28;
    
    // Service management
    ListServicesRequest list_services = 29;
    ServiceControlRequest service_control = 30;
    
    // System inventory
    GetHardwareInfoRequest get_hardware_info = 31;
    ListInstalledSoftwareRequest list_installed_software = 32;
    
    // Agent self-update
    AgentUpdateRequest agent_update = 33;
    GetCapabilitiesRequest get_capabilities = 34;
    
    // =========================================================================
    // Guest -> Host (Responses)
    // =========================================================================
    
    // Health check response
    PongResponse pong = 50;
    
    // Command execution result
    ExecuteResponse execute_response = 51;
    
    // File operation results
    FileWriteResponse file_write_response = 52;
    FileReadResponse file_read_response = 53;
    
    // Lifecycle responses
    ShutdownResponse shutdown_response = 54;
    ResetPasswordResponse reset_password_response = 55;
    
    // Network configuration result
    ConfigureNetworkResponse configure_network_response = 56;
    
    // Filesystem quiescing responses
    QuiesceFilesystemsResponse quiesce_response = 57;
    ThawFilesystemsResponse thaw_response = 58;
    
    // Time sync response
    SyncTimeResponse sync_time_response = 59;
    
    // Directory operation responses
    ListDirectoryResponse list_directory_response = 60;
    CreateDirectoryResponse create_directory_response = 61;
    FileDeleteResponse file_delete_response = 62;
    FileStatResponse file_stat_response = 63;
    
    // Display operation responses
    DisplayResizeResponse display_resize_response = 64;
    
    // Clipboard operation responses
    ClipboardUpdateResponse clipboard_update_response = 65;
    ClipboardGetResponse clipboard_get_response = 66;
    
    // Process management responses
    ListProcessesResponse list_processes_response = 67;
    KillProcessResponse kill_process_response = 68;
    
    // Service management responses
    ListServicesResponse list_services_response = 69;
    ServiceControlResponse service_control_response = 70;
    
    // System inventory responses
    GetHardwareInfoResponse hardware_info_response = 71;
    ListInstalledSoftwareResponse list_installed_software_response = 72;
    
    // Agent self-update responses
    AgentUpdateResponse agent_update_response = 73;
    GetCapabilitiesResponse get_capabilities_response = 74;
    
    // =========================================================================
    // Guest -> Host (Unsolicited Events)
    // =========================================================================
    
    // Periodic telemetry report
    TelemetryReport telemetry = 100;
    
    // Agent startup notification
    AgentReadyEvent agent_ready = 101;
    
    // Error notification
    ErrorEvent error = 102;
    
    // Clipboard changed event (unsolicited, guest -> host)
    ClipboardChangedEvent clipboard_changed = 103;
  }
}

// =============================================================================
// HEALTH CHECK
// =============================================================================

message PingRequest {
  // Optional sequence number for RTT measurement
  uint64 sequence = 1;
}

message PongResponse {
  // Echo back the sequence number
  uint64 sequence = 1;
  
  // Agent version
  string version = 2;
  
  // Agent uptime in seconds
  uint64 uptime_seconds = 3;
}

// =============================================================================
// TELEMETRY
// =============================================================================

message TelemetryReport {
  // CPU usage percentage (0.0 - 100.0)
  double cpu_usage_percent = 1;
  
  // Memory statistics
  uint64 memory_total_bytes = 2;
  uint64 memory_used_bytes = 3;
  uint64 memory_available_bytes = 4;
  
  // Swap statistics
  uint64 swap_total_bytes = 5;
  uint64 swap_used_bytes = 6;
  
  // Disk usage per mount point
  repeated DiskUsage disks = 7;
  
  // Network interfaces with IPs
  repeated InterfaceInfo interfaces = 8;
  
  // System load averages (1, 5, 15 minutes)
  double load_avg_1 = 9;
  double load_avg_5 = 10;
  double load_avg_15 = 11;
  
  // Number of running processes
  uint32 process_count = 12;
  
  // System uptime in seconds
  uint64 uptime_seconds = 13;
  
  // Hostname (may change after cloud-init)
  string hostname = 14;
}

message DiskUsage {
  // Mount point (e.g., "/", "/home")
  string mount_point = 1;
  
  // Filesystem type (e.g., "ext4", "xfs")
  string filesystem = 2;
  
  // Device path (e.g., "/dev/vda1")
  string device = 3;
  
  // Size in bytes
  uint64 total_bytes = 4;
  uint64 used_bytes = 5;
  uint64 available_bytes = 6;
  
  // Usage percentage
  double usage_percent = 7;
}

message InterfaceInfo {
  // Interface name (e.g., "eth0", "ens3")
  string name = 1;
  
  // MAC address
  string mac_address = 2;
  
  // IPv4 addresses (CIDR notation)
  repeated string ipv4_addresses = 3;
  
  // IPv6 addresses (CIDR notation)
  repeated string ipv6_addresses = 4;
  
  // Interface state
  InterfaceState state = 5;
  
  // MTU
  uint32 mtu = 6;
  
  // Traffic statistics
  uint64 rx_bytes = 7;
  uint64 tx_bytes = 8;
  uint64 rx_packets = 9;
  uint64 tx_packets = 10;
}

enum InterfaceState {
  INTERFACE_STATE_UNKNOWN = 0;
  INTERFACE_STATE_UP = 1;
  INTERFACE_STATE_DOWN = 2;
}

// =============================================================================
// COMMAND EXECUTION
// =============================================================================

message ExecuteRequest {
  // Command to execute (passed to shell)
  string command = 1;
  
  // Arguments (optional, for direct execution without shell)
  repeated string args = 2;
  
  // Working directory (optional)
  string working_directory = 3;
  
  // Environment variables to set
  map<string, string> environment = 4;
  
  // Timeout in seconds (0 = no timeout)
  uint32 timeout_seconds = 5;
  
  // Whether to wait for the command to complete
  bool wait_for_exit = 6;
  
  // Run as a specific user (optional, requires root)
  string run_as_user = 7;
  
  // Maximum stdout/stderr size to capture (0 = unlimited, default 1MB)
  uint32 max_output_bytes = 8;
  
  // Run as a specific group (optional, requires root)
  // If empty but run_as_user is set, uses the user's primary group
  string run_as_group = 9;
  
  // Include supplementary groups when running as user
  // Default: true (uses user's supplementary groups from /etc/group)
  bool include_supplementary_groups = 10;
}

message ExecuteResponse {
  // Exit code (-1 if execution failed)
  int32 exit_code = 1;
  
  // Standard output
  string stdout = 2;
  
  // Standard error
  string stderr = 3;
  
  // Whether the output was truncated
  bool truncated = 4;
  
  // Whether the command timed out
  bool timed_out = 5;
  
  // Execution duration in milliseconds
  uint64 duration_ms = 6;
  
  // Error message if execution failed to start
  string error = 7;
}

// =============================================================================
// FILE OPERATIONS
// =============================================================================

message FileWriteRequest {
  // Absolute path to the file
  string path = 1;
  
  // File data (chunked for large files)
  bytes data = 2;
  
  // Offset to write at (for random access)
  uint64 offset = 3;
  
  // Whether to append (ignores offset)
  bool append = 4;
  
  // End-of-file marker (true for last chunk)
  bool eof = 5;
  
  // File permissions (octal, e.g., 0644)
  uint32 mode = 6;
  
  // Create parent directories if they don't exist
  bool create_parents = 7;
  
  // Chunk sequence number (for reassembly verification)
  uint32 chunk_number = 8;
  
  // Total number of chunks (set in first chunk)
  uint32 total_chunks = 9;
}

message FileWriteResponse {
  // Whether the write succeeded
  bool success = 1;
  
  // Number of bytes written
  uint64 bytes_written = 2;
  
  // Error message if failed
  string error = 3;
  
  // Acknowledged chunk number
  uint32 chunk_number = 4;
}

message FileReadRequest {
  // Absolute path to the file
  string path = 1;
  
  // Offset to read from
  uint64 offset = 2;
  
  // Maximum bytes to read (0 = entire file)
  uint64 length = 3;
  
  // Chunk size for streaming (default 64KB)
  uint32 chunk_size = 4;
}

message FileReadResponse {
  // Whether the read succeeded
  bool success = 1;
  
  // File data
  bytes data = 2;
  
  // End-of-file marker
  bool eof = 3;
  
  // Total file size
  uint64 total_size = 4;
  
  // Current offset
  uint64 offset = 5;
  
  // Chunk number
  uint32 chunk_number = 6;
  
  // Error message if failed
  string error = 7;
  
  // File permissions
  uint32 mode = 8;
  
  // Last modified timestamp
  google.protobuf.Timestamp modified_at = 9;
}

// =============================================================================
// LIFECYCLE OPERATIONS
// =============================================================================

message ShutdownRequest {
  // Shutdown type
  ShutdownType type = 1;
  
  // Delay in seconds before shutdown
  uint32 delay_seconds = 2;
  
  // Message to broadcast to users
  string message = 3;
}

enum ShutdownType {
  SHUTDOWN_TYPE_POWEROFF = 0;
  SHUTDOWN_TYPE_REBOOT = 1;
  SHUTDOWN_TYPE_HALT = 2;
}

message ShutdownResponse {
  // Whether the shutdown was initiated
  bool accepted = 1;
  
  // Error message if rejected
  string error = 2;
}

message ResetPasswordRequest {
  // Username to reset password for
  string username = 1;
  
  // New password (will be hashed by agent)
  string new_password = 2;
  
  // Whether to expire the password (force change on next login)
  bool expire = 3;
}

message ResetPasswordResponse {
  // Whether the password was reset
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

// =============================================================================
// NETWORK CONFIGURATION
// =============================================================================

message ConfigureNetworkRequest {
  // Network configuration in Netplan YAML format
  string netplan_config = 1;
  
  // Whether to apply immediately
  bool apply_now = 2;
}

message ConfigureNetworkResponse {
  // Whether the configuration was applied
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

// =============================================================================
// EVENTS
// =============================================================================

message AgentReadyEvent {
  // Agent version
  string version = 1;
  
  // Operating system info
  string os_name = 2;
  string os_version = 3;
  string kernel_version = 4;
  string architecture = 5;
  
  // Hostname
  string hostname = 6;
  
  // Initial IP addresses
  repeated string ip_addresses = 7;
  
  // Capabilities supported by this agent
  repeated string capabilities = 8;
}

message ErrorEvent {
  // Error severity
  ErrorSeverity severity = 1;
  
  // Error code
  string code = 2;
  
  // Human-readable message
  string message = 3;
  
  // Additional context
  map<string, string> details = 4;
}

enum ErrorSeverity {
  ERROR_SEVERITY_WARNING = 0;
  ERROR_SEVERITY_ERROR = 1;
  ERROR_SEVERITY_CRITICAL = 2;
}

// =============================================================================
// FILESYSTEM QUIESCING (for safe snapshots)
// =============================================================================
// These operations use fsfreeze (Linux) or VSS (Windows) to ensure filesystem
// consistency during snapshot operations. This is critical for databases.

message QuiesceFilesystemsRequest {
  // List of mount points to freeze (empty = all writable filesystems)
  repeated string mount_points = 1;
  
  // Timeout in seconds for the quiesce operation (default: 60)
  // After this timeout, filesystems will be auto-thawed
  uint32 timeout_seconds = 2;
  
  // Whether to run pre-freeze scripts (e.g., database flush hooks)
  bool run_pre_freeze_scripts = 3;
  
  // Directory containing pre-freeze scripts (default: /etc/limiquantix/pre-freeze.d/)
  string pre_freeze_script_dir = 4;
}

message QuiesceFilesystemsResponse {
  // Whether quiescing succeeded
  bool success = 1;
  
  // List of mount points that were frozen
  repeated FrozenFilesystem frozen = 2;
  
  // Error message if quiescing failed
  string error = 3;
  
  // Token for thaw operation (for correlation)
  string quiesce_token = 4;
  
  // Timestamp when auto-thaw will trigger
  google.protobuf.Timestamp auto_thaw_at = 5;
}

message FrozenFilesystem {
  // Mount point that was frozen
  string mount_point = 1;
  
  // Device path
  string device = 2;
  
  // Filesystem type
  string filesystem = 3;
  
  // Whether it was successfully frozen
  bool frozen = 4;
  
  // Error if freezing this specific filesystem failed
  string error = 5;
}

message ThawFilesystemsRequest {
  // Token from QuiesceFilesystemsResponse (optional, for verification)
  string quiesce_token = 1;
  
  // List of mount points to thaw (empty = all frozen filesystems)
  repeated string mount_points = 2;
  
  // Whether to run post-thaw scripts
  bool run_post_thaw_scripts = 3;
  
  // Directory containing post-thaw scripts (default: /etc/limiquantix/post-thaw.d/)
  string post_thaw_script_dir = 4;
}

message ThawFilesystemsResponse {
  // Whether thawing succeeded
  bool success = 1;
  
  // List of mount points that were thawed
  repeated string thawed_mount_points = 2;
  
  // Error message if thawing failed
  string error = 3;
  
  // Duration the filesystems were frozen (milliseconds)
  uint64 frozen_duration_ms = 4;
}

// =============================================================================
// TIME SYNCHRONIZATION
// =============================================================================
// Used after VM resume from suspend/pause to ensure system clock is correct.

message SyncTimeRequest {
  // Force immediate sync (vs. gradual drift correction)
  bool force = 1;
  
  // Optional: Set time to this value (NTP sync if not provided)
  google.protobuf.Timestamp set_time = 2;
}

message SyncTimeResponse {
  // Whether sync succeeded
  bool success = 1;
  
  // Time offset that was corrected (seconds, can be negative)
  double offset_seconds = 2;
  
  // Current system time after sync
  google.protobuf.Timestamp current_time = 3;
  
  // Time source used (e.g., "ntp", "chrony", "manual")
  string time_source = 4;
  
  // Error message if sync failed
  string error = 5;
}

// =============================================================================
// DIRECTORY OPERATIONS (Phase 2)
// =============================================================================

message ListDirectoryRequest {
  // Absolute path to the directory
  string path = 1;
  
  // Include hidden files (starting with .)
  bool include_hidden = 2;
  
  // Maximum entries to return (0 = unlimited)
  uint32 max_entries = 3;
  
  // Continuation token for pagination
  string continuation_token = 4;
}

message ListDirectoryResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Directory entries
  repeated DirectoryEntry entries = 2;
  
  // Continuation token for next page (empty if no more)
  string continuation_token = 3;
  
  // Error message if failed
  string error = 4;
  
  // Total number of entries (if known)
  uint32 total_entries = 5;
}

message DirectoryEntry {
  // File/directory name
  string name = 1;
  
  // Full absolute path
  string path = 2;
  
  // Whether this is a directory
  bool is_directory = 3;
  
  // Whether this is a symbolic link
  bool is_symlink = 4;
  
  // Size in bytes (0 for directories)
  uint64 size_bytes = 5;
  
  // Unix file mode (permissions)
  uint32 mode = 6;
  
  // Last modified timestamp
  google.protobuf.Timestamp modified_at = 7;
  
  // Creation timestamp (if available)
  google.protobuf.Timestamp created_at = 8;
  
  // Owner username (Unix)
  string owner = 9;
  
  // Group name (Unix)
  string group = 10;
  
  // Symlink target (if is_symlink)
  string symlink_target = 11;
}

message CreateDirectoryRequest {
  // Absolute path to create
  string path = 1;
  
  // Create parent directories if needed
  bool create_parents = 2;
  
  // Unix file mode (permissions), default 0755
  uint32 mode = 3;
}

message CreateDirectoryResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

message FileDeleteRequest {
  // Absolute path to delete
  string path = 1;
  
  // Recursively delete directories
  bool recursive = 2;
}

message FileDeleteResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

message FileStatRequest {
  // Absolute path to stat
  string path = 1;
}

message FileStatResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // File/directory information
  DirectoryEntry entry = 2;
  
  // Error message if failed
  string error = 3;
}

// =============================================================================
// DISPLAY OPERATIONS (Phase 3 - Desktop Integration)
// =============================================================================

message DisplayResizeRequest {
  // Target width in pixels
  uint32 width = 1;
  
  // Target height in pixels
  uint32 height = 2;
  
  // DPI setting (0 = auto)
  uint32 dpi = 3;
  
  // Display identifier (for multi-monitor, empty = primary)
  string display_id = 4;
}

message DisplayResizeResponse {
  // Whether the resize succeeded
  bool success = 1;
  
  // Actual width after resize
  uint32 actual_width = 2;
  
  // Actual height after resize
  uint32 actual_height = 3;
  
  // Error message if failed
  string error = 4;
}

// =============================================================================
// CLIPBOARD OPERATIONS (Phase 3 - Desktop Integration)
// =============================================================================

message ClipboardUpdateRequest {
  // Clipboard content type
  ClipboardType type = 1;
  
  // Clipboard data
  bytes data = 2;
  
  // MIME type (e.g., "text/plain", "image/png")
  string mime_type = 3;
}

enum ClipboardType {
  CLIPBOARD_TYPE_TEXT = 0;
  CLIPBOARD_TYPE_IMAGE = 1;
  CLIPBOARD_TYPE_FILES = 2;
  CLIPBOARD_TYPE_HTML = 3;
}

message ClipboardUpdateResponse {
  // Whether the update succeeded
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

message ClipboardGetRequest {
  // Preferred type (empty = any)
  ClipboardType preferred_type = 1;
}

message ClipboardGetResponse {
  // Whether the get succeeded
  bool success = 1;
  
  // Clipboard content type
  ClipboardType type = 2;
  
  // Clipboard data
  bytes data = 3;
  
  // MIME type
  string mime_type = 4;
  
  // Error message if failed
  string error = 5;
}

// Unsolicited event when guest clipboard changes
message ClipboardChangedEvent {
  // Clipboard content type
  ClipboardType type = 1;
  
  // Clipboard data
  bytes data = 2;
  
  // MIME type
  string mime_type = 3;
}

// =============================================================================
// PROCESS MANAGEMENT (Phase 4)
// =============================================================================

message ListProcessesRequest {
  // Filter by process name (empty = all)
  string filter = 1;
  
  // Include thread information
  bool include_threads = 2;
  
  // Maximum processes to return (0 = unlimited)
  uint32 max_entries = 3;
}

message ListProcessesResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Process list
  repeated ProcessInfo processes = 2;
  
  // Error message if failed
  string error = 3;
}

message ProcessInfo {
  // Process ID
  uint32 pid = 1;
  
  // Parent process ID
  uint32 ppid = 2;
  
  // Process name
  string name = 3;
  
  // Full command line
  string command_line = 4;
  
  // User running the process
  string user = 5;
  
  // CPU usage percentage
  double cpu_percent = 6;
  
  // Memory usage in bytes
  uint64 memory_bytes = 7;
  
  // Process state (running, sleeping, zombie, etc.)
  string state = 8;
  
  // Process start time
  google.protobuf.Timestamp started_at = 9;
  
  // Number of threads
  uint32 thread_count = 10;
  
  // Working directory
  string working_directory = 11;
}

message KillProcessRequest {
  // Process ID to kill
  uint32 pid = 1;
  
  // Signal to send (default: SIGTERM=15, SIGKILL=9)
  int32 signal = 2;
}

message KillProcessResponse {
  // Whether the kill succeeded
  bool success = 1;
  
  // Error message if failed
  string error = 2;
}

// =============================================================================
// SERVICE MANAGEMENT (Phase 4)
// =============================================================================

message ListServicesRequest {
  // Filter by service name (empty = all)
  string filter = 1;
  
  // Only show running services
  bool running_only = 2;
}

message ListServicesResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Service list
  repeated ServiceInfo services = 2;
  
  // Error message if failed
  string error = 3;
}

message ServiceInfo {
  // Service name
  string name = 1;
  
  // Display name
  string display_name = 2;
  
  // Current state (running, stopped, starting, stopping)
  string state = 3;
  
  // Start type (auto, manual, disabled)
  string start_type = 4;
  
  // Service description
  string description = 5;
  
  // Process ID (if running)
  uint32 pid = 6;
  
  // Memory usage (if running)
  uint64 memory_bytes = 7;
}

message ServiceControlRequest {
  // Service name
  string name = 1;
  
  // Action to perform
  ServiceAction action = 2;
}

enum ServiceAction {
  SERVICE_ACTION_START = 0;
  SERVICE_ACTION_STOP = 1;
  SERVICE_ACTION_RESTART = 2;
  SERVICE_ACTION_ENABLE = 3;
  SERVICE_ACTION_DISABLE = 4;
  SERVICE_ACTION_STATUS = 5;
}

message ServiceControlResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // New service state after operation
  string new_state = 2;
  
  // Error message if failed
  string error = 3;
}

// =============================================================================
// SYSTEM INVENTORY (Phase 5)
// =============================================================================

message GetHardwareInfoRequest {
  // Include detailed CPU information
  bool include_cpu_details = 1;
  
  // Include detailed disk information
  bool include_disk_details = 2;
  
  // Include detailed network information
  bool include_network_details = 3;
}

message GetHardwareInfoResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Hardware information
  HardwareInfo hardware = 2;
  
  // Error message if failed
  string error = 3;
}

message HardwareInfo {
  // CPU information
  CpuInfo cpu = 1;
  
  // Memory information
  MemoryInfo memory = 2;
  
  // Disk information
  repeated DiskInfo disks = 3;
  
  // Network adapter information
  repeated NetworkAdapterInfo network_adapters = 4;
  
  // BIOS information
  BiosInfo bios = 5;
  
  // Operating system information
  OsInfo os = 6;
  
  // GPU information (if available)
  repeated GpuInfo gpus = 7;
}

message CpuInfo {
  // CPU model name
  string model = 1;
  
  // Number of physical cores
  uint32 cores = 2;
  
  // Number of logical threads
  uint32 threads = 3;
  
  // Base frequency in MHz
  double frequency_mhz = 4;
  
  // CPU architecture (x86_64, aarch64, etc.)
  string architecture = 5;
  
  // CPU feature flags
  repeated string flags = 6;
  
  // Vendor (Intel, AMD, ARM)
  string vendor = 7;
  
  // Number of sockets
  uint32 sockets = 8;
  
  // Cache sizes
  uint64 l1_cache_bytes = 9;
  uint64 l2_cache_bytes = 10;
  uint64 l3_cache_bytes = 11;
}

message MemoryInfo {
  // Total physical memory
  uint64 total_bytes = 1;
  
  // Available memory
  uint64 available_bytes = 2;
  
  // Memory type (DDR4, DDR5, etc.)
  string memory_type = 3;
  
  // Memory speed in MHz
  uint32 speed_mhz = 4;
  
  // Number of DIMMs
  uint32 dimm_count = 5;
}

message DiskInfo {
  // Device path (e.g., /dev/sda)
  string device = 1;
  
  // Disk model
  string model = 2;
  
  // Serial number
  string serial = 3;
  
  // Size in bytes
  uint64 size_bytes = 4;
  
  // Disk type (HDD, SSD, NVMe)
  string disk_type = 5;
  
  // Interface (SATA, NVMe, USB)
  string interface = 6;
  
  // Is this a virtual disk
  bool is_virtual = 7;
  
  // Partitions
  repeated PartitionInfo partitions = 8;
}

message PartitionInfo {
  // Partition device (e.g., /dev/sda1)
  string device = 1;
  
  // Mount point (if mounted)
  string mount_point = 2;
  
  // Filesystem type
  string filesystem = 3;
  
  // Size in bytes
  uint64 size_bytes = 4;
  
  // Used bytes
  uint64 used_bytes = 5;
  
  // Partition label
  string label = 6;
}

message NetworkAdapterInfo {
  // Interface name
  string name = 1;
  
  // MAC address
  string mac_address = 2;
  
  // Adapter type (ethernet, wifi, virtual)
  string adapter_type = 3;
  
  // Link speed in Mbps
  uint32 speed_mbps = 4;
  
  // Is virtual adapter
  bool is_virtual = 5;
  
  // Driver name
  string driver = 6;
  
  // PCI address (if applicable)
  string pci_address = 7;
}

message BiosInfo {
  // BIOS vendor
  string vendor = 1;
  
  // BIOS version
  string version = 2;
  
  // Release date
  string release_date = 3;
  
  // System manufacturer
  string system_manufacturer = 4;
  
  // System product name
  string system_product = 5;
  
  // System serial number
  string system_serial = 6;
  
  // System UUID
  string system_uuid = 7;
}

message OsInfo {
  // OS name (e.g., "Ubuntu", "Windows")
  string name = 1;
  
  // OS version
  string version = 2;
  
  // Build number
  string build = 3;
  
  // Kernel version
  string kernel = 4;
  
  // Architecture
  string architecture = 5;
  
  // Installation date
  google.protobuf.Timestamp install_date = 6;
  
  // Last boot time
  google.protobuf.Timestamp last_boot = 7;
  
  // Hostname
  string hostname = 8;
  
  // Domain (if joined)
  string domain = 9;
}

message GpuInfo {
  // GPU name
  string name = 1;
  
  // Vendor (NVIDIA, AMD, Intel)
  string vendor = 2;
  
  // Driver version
  string driver_version = 3;
  
  // VRAM in bytes
  uint64 vram_bytes = 4;
  
  // PCI address
  string pci_address = 5;
}

message ListInstalledSoftwareRequest {
  // Filter by software name (empty = all)
  string filter = 1;
  
  // Maximum entries to return (0 = unlimited)
  uint32 max_entries = 2;
}

message ListInstalledSoftwareResponse {
  // Whether the operation succeeded
  bool success = 1;
  
  // Installed software list
  repeated InstalledSoftware software = 2;
  
  // Error message if failed
  string error = 3;
  
  // Total count (if known)
  uint32 total_count = 4;
}

message InstalledSoftware {
  // Software name
  string name = 1;
  
  // Version
  string version = 2;
  
  // Publisher/vendor
  string publisher = 3;
  
  // Installation date
  google.protobuf.Timestamp install_date = 4;
  
  // Installed size in bytes
  uint64 size_bytes = 5;
  
  // Package type (deb, rpm, msi, etc.)
  string package_type = 6;
  
  // Architecture
  string architecture = 7;
}

// =============================================================================
// AGENT SELF-MANAGEMENT (Phase 6)
// =============================================================================

message AgentUpdateRequest {
  // Target version to update to
  string target_version = 1;
  
  // Binary data (chunked)
  bytes binary_data = 2;
  
  // Chunk number (0-based)
  uint32 chunk_number = 3;
  
  // Whether this is the last chunk
  bool is_last_chunk = 4;
  
  // SHA256 checksum of complete binary
  string checksum_sha256 = 5;
  
  // Total size of the binary
  uint64 total_size = 6;
}

message AgentUpdateResponse {
  // Whether the update step succeeded
  bool success = 1;
  
  // Current agent version
  string current_version = 2;
  
  // Error message if failed
  string error = 3;
  
  // Whether restart is required
  bool restart_required = 4;
  
  // Update progress (0-100)
  uint32 progress_percent = 5;
  
  // Update state
  UpdateState state = 6;
}

enum UpdateState {
  UPDATE_STATE_IDLE = 0;
  UPDATE_STATE_DOWNLOADING = 1;
  UPDATE_STATE_VERIFYING = 2;
  UPDATE_STATE_APPLYING = 3;
  UPDATE_STATE_COMPLETE = 4;
  UPDATE_STATE_FAILED = 5;
  UPDATE_STATE_ROLLING_BACK = 6;
}

message GetCapabilitiesRequest {}

message GetCapabilitiesResponse {
  // Agent version
  string version = 1;
  
  // Operating system
  string os = 2;
  
  // Architecture
  string architecture = 3;
  
  // List of supported capabilities
  repeated string capabilities = 4;
  
  // Feature flags
  map<string, string> features = 5;
  
  // Build information
  string build_time = 6;
  string build_commit = 7;
}
