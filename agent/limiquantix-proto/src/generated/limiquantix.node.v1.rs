// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub hypervisor: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub hypervisor_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub uptime_seconds: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeInfoResponse {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub management_ip: ::prost::alloc::string::String,
    /// Hardware info
    #[prost(string, tag = "4")]
    pub cpu_model: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub cpu_cores: u32,
    #[prost(uint64, tag = "6")]
    pub memory_total_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub memory_available_bytes: u64,
    /// OS info
    #[prost(string, tag = "8")]
    pub os_name: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub os_version: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub kernel_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "11")]
    pub uptime_seconds: u64,
    /// Hypervisor capabilities
    #[prost(string, tag = "12")]
    pub hypervisor_name: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub hypervisor_version: ::prost::alloc::string::String,
    #[prost(bool, tag = "14")]
    pub supports_live_migration: bool,
    #[prost(bool, tag = "15")]
    pub supports_snapshots: bool,
    #[prost(bool, tag = "16")]
    pub supports_hotplug: bool,
    #[prost(uint32, tag = "17")]
    pub max_vcpus: u32,
    #[prost(uint64, tag = "18")]
    pub max_memory_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmIdRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVmRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// CPU configuration
    #[prost(uint32, tag = "3")]
    pub cpu_cores: u32,
    #[prost(uint32, tag = "4")]
    pub cpu_sockets: u32,
    #[prost(uint32, tag = "5")]
    pub cpu_threads: u32,
    /// Memory configuration (in MiB)
    #[prost(uint64, tag = "6")]
    pub memory_mib: u64,
    /// Disks
    #[prost(message, repeated, tag = "7")]
    pub disks: ::prost::alloc::vec::Vec<DiskSpec>,
    /// Network interfaces
    #[prost(message, repeated, tag = "8")]
    pub nics: ::prost::alloc::vec::Vec<NicSpec>,
    /// Boot configuration
    #[prost(enumeration = "Firmware", tag = "9")]
    pub firmware: i32,
    /// Console
    #[prost(bool, tag = "10")]
    pub vnc_enabled: bool,
    /// Labels
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskSpec {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub size_gib: u64,
    #[prost(enumeration = "DiskBus", tag = "4")]
    pub bus: i32,
    #[prost(enumeration = "DiskFormat", tag = "5")]
    pub format: i32,
    #[prost(bool, tag = "6")]
    pub readonly: bool,
    #[prost(bool, tag = "7")]
    pub bootable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NicSpec {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mac_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub bridge: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub network: ::prost::alloc::string::String,
    #[prost(enumeration = "NicModel", tag = "5")]
    pub model: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVmResponse {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub created: bool,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopVmRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub timeout_seconds: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmStatusResponse {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "PowerState", tag = "3")]
    pub state: i32,
    #[prost(double, tag = "4")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag = "5")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub memory_total_bytes: u64,
    #[prost(message, optional, tag = "7")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub guest_agent: ::core::option::Option<GuestAgentInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVMsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vms: ::prost::alloc::vec::Vec<VmStatusResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsoleInfoResponse {
    /// "vnc" or "spice"
    #[prost(string, tag = "1")]
    pub console_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub websocket_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnapshotRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub quiesce: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotResponse {
    #[prost(string, tag = "1")]
    pub snapshot_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "PowerState", tag = "5")]
    pub vm_state: i32,
    #[prost(string, tag = "6")]
    pub parent_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevertSnapshotRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub snapshot_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSnapshotRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub snapshot_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsResponse {
    #[prost(message, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<SnapshotResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamMetricsRequest {
    #[prost(uint32, tag = "1")]
    pub interval_seconds: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMetrics {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(double, tag = "2")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag = "3")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub memory_total_bytes: u64,
    #[prost(message, repeated, tag = "5")]
    pub vms: ::prost::alloc::vec::Vec<VmMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmMetrics {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag = "4")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag = "5")]
    pub disk_read_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub disk_write_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub network_rx_bytes: u64,
    #[prost(uint64, tag = "8")]
    pub network_tx_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "EventType", tag = "3")]
    pub r#type: i32,
    #[prost(string, tag = "4")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiskBus {
    Virtio = 0,
    Scsi = 1,
    Sata = 2,
    Ide = 3,
}
impl DiskBus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DiskBus::Virtio => "DISK_BUS_VIRTIO",
            DiskBus::Scsi => "DISK_BUS_SCSI",
            DiskBus::Sata => "DISK_BUS_SATA",
            DiskBus::Ide => "DISK_BUS_IDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISK_BUS_VIRTIO" => Some(Self::Virtio),
            "DISK_BUS_SCSI" => Some(Self::Scsi),
            "DISK_BUS_SATA" => Some(Self::Sata),
            "DISK_BUS_IDE" => Some(Self::Ide),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiskFormat {
    Qcow2 = 0,
    Raw = 1,
}
impl DiskFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DiskFormat::Qcow2 => "DISK_FORMAT_QCOW2",
            DiskFormat::Raw => "DISK_FORMAT_RAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISK_FORMAT_QCOW2" => Some(Self::Qcow2),
            "DISK_FORMAT_RAW" => Some(Self::Raw),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NicModel {
    Virtio = 0,
    E1000 = 1,
    Rtl8139 = 2,
}
impl NicModel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NicModel::Virtio => "NIC_MODEL_VIRTIO",
            NicModel::E1000 => "NIC_MODEL_E1000",
            NicModel::Rtl8139 => "NIC_MODEL_RTL8139",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NIC_MODEL_VIRTIO" => Some(Self::Virtio),
            "NIC_MODEL_E1000" => Some(Self::E1000),
            "NIC_MODEL_RTL8139" => Some(Self::Rtl8139),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Firmware {
    Bios = 0,
    Uefi = 1,
}
impl Firmware {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Firmware::Bios => "FIRMWARE_BIOS",
            Firmware::Uefi => "FIRMWARE_UEFI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIRMWARE_BIOS" => Some(Self::Bios),
            "FIRMWARE_UEFI" => Some(Self::Uefi),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PowerState {
    Unknown = 0,
    Running = 1,
    Stopped = 2,
    Paused = 3,
    Suspended = 4,
    Crashed = 5,
}
impl PowerState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PowerState::Unknown => "POWER_STATE_UNKNOWN",
            PowerState::Running => "POWER_STATE_RUNNING",
            PowerState::Stopped => "POWER_STATE_STOPPED",
            PowerState::Paused => "POWER_STATE_PAUSED",
            PowerState::Suspended => "POWER_STATE_SUSPENDED",
            PowerState::Crashed => "POWER_STATE_CRASHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POWER_STATE_UNKNOWN" => Some(Self::Unknown),
            "POWER_STATE_RUNNING" => Some(Self::Running),
            "POWER_STATE_STOPPED" => Some(Self::Stopped),
            "POWER_STATE_PAUSED" => Some(Self::Paused),
            "POWER_STATE_SUSPENDED" => Some(Self::Suspended),
            "POWER_STATE_CRASHED" => Some(Self::Crashed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Unknown = 0,
    VmStarted = 1,
    VmStopped = 2,
    VmPaused = 3,
    VmResumed = 4,
    VmCrashed = 5,
    VmRebooted = 6,
    SnapshotCreated = 7,
    SnapshotReverted = 8,
    SnapshotDeleted = 9,
    NodeOverloaded = 10,
    NodeRecovered = 11,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EventType::Unknown => "EVENT_TYPE_UNKNOWN",
            EventType::VmStarted => "EVENT_TYPE_VM_STARTED",
            EventType::VmStopped => "EVENT_TYPE_VM_STOPPED",
            EventType::VmPaused => "EVENT_TYPE_VM_PAUSED",
            EventType::VmResumed => "EVENT_TYPE_VM_RESUMED",
            EventType::VmCrashed => "EVENT_TYPE_VM_CRASHED",
            EventType::VmRebooted => "EVENT_TYPE_VM_REBOOTED",
            EventType::SnapshotCreated => "EVENT_TYPE_SNAPSHOT_CREATED",
            EventType::SnapshotReverted => "EVENT_TYPE_SNAPSHOT_REVERTED",
            EventType::SnapshotDeleted => "EVENT_TYPE_SNAPSHOT_DELETED",
            EventType::NodeOverloaded => "EVENT_TYPE_NODE_OVERLOADED",
            EventType::NodeRecovered => "EVENT_TYPE_NODE_RECOVERED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNKNOWN" => Some(Self::Unknown),
            "EVENT_TYPE_VM_STARTED" => Some(Self::VmStarted),
            "EVENT_TYPE_VM_STOPPED" => Some(Self::VmStopped),
            "EVENT_TYPE_VM_PAUSED" => Some(Self::VmPaused),
            "EVENT_TYPE_VM_RESUMED" => Some(Self::VmResumed),
            "EVENT_TYPE_VM_CRASHED" => Some(Self::VmCrashed),
            "EVENT_TYPE_VM_REBOOTED" => Some(Self::VmRebooted),
            "EVENT_TYPE_SNAPSHOT_CREATED" => Some(Self::SnapshotCreated),
            "EVENT_TYPE_SNAPSHOT_REVERTED" => Some(Self::SnapshotReverted),
            "EVENT_TYPE_SNAPSHOT_DELETED" => Some(Self::SnapshotDeleted),
            "EVENT_TYPE_NODE_OVERLOADED" => Some(Self::NodeOverloaded),
            "EVENT_TYPE_NODE_RECOVERED" => Some(Self::NodeRecovered),
            _ => None,
        }
    }
}

// =============================================================================
// GUEST AGENT TYPES (manually added - regenerate with protoc when available)
// =============================================================================

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestAgentInfo {
    #[prost(bool, tag = "1")]
    pub connected: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub os_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub os_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub kernel_version: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub timezone: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub interfaces: ::prost::alloc::vec::Vec<GuestNetworkInterface>,
    #[prost(message, optional, tag = "9")]
    pub resource_usage: ::core::option::Option<GuestResourceUsage>,
    #[prost(string, repeated, tag = "10")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestNetworkInterface {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mac_address: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub ipv4_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub ipv6_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "5")]
    pub up: bool,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestResourceUsage {
    #[prost(double, tag = "1")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag = "2")]
    pub memory_total_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub memory_cached_bytes: u64,
    #[prost(uint64, tag = "5")]
    pub memory_buffers_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub swap_total_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub swap_used_bytes: u64,
    #[prost(uint64, tag = "8")]
    pub uptime_seconds: u64,
    #[prost(double, repeated, tag = "9")]
    pub load_average: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, repeated, tag = "10")]
    pub disks: ::prost::alloc::vec::Vec<GuestDiskUsage>,
    #[prost(uint32, tag = "11")]
    pub process_count: u32,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestDiskUsage {
    #[prost(string, tag = "1")]
    pub mount_point: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub device: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filesystem: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub total_bytes: u64,
    #[prost(uint64, tag = "5")]
    pub used_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub available_bytes: u64,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentPingResponse {
    #[prost(bool, tag = "1")]
    pub connected: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uptime_seconds: u64,
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteInGuestRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "4")]
    pub environment: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "5")]
    pub working_directory: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub stdin: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "7")]
    pub timeout_seconds: u32,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteInGuestResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
    #[prost(string, tag = "3")]
    pub stdout: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub stderr: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub timed_out: bool,
    #[prost(uint64, tag = "6")]
    pub duration_ms: u64,
    #[prost(string, tag = "7")]
    pub error: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadGuestFileRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub offset: u64,
    #[prost(uint64, tag = "4")]
    pub max_bytes: u64,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadGuestFileResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub total_size: u64,
    #[prost(bool, tag = "4")]
    pub eof: bool,
    #[prost(string, tag = "5")]
    pub error: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteGuestFileRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub append: bool,
    #[prost(uint32, tag = "5")]
    pub mode: u32,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteGuestFileResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, tag = "2")]
    pub bytes_written: u64,
    #[prost(string, tag = "3")]
    pub error: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestShutdownRequest {
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub reboot: bool,
    #[prost(uint32, tag = "3")]
    pub delay_seconds: u32,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestShutdownResponse {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}

// =============================================================================
// STORAGE POOL TYPES (manually added - regenerate with protoc when available)
// =============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoragePoolType {
    Unspecified = 0,
    LocalDir = 1,
    LocalLvm = 2,
    Nfs = 3,
    CephRbd = 4,
    CephFs = 5,
    Iscsi = 6,
}
impl StoragePoolType {
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StoragePoolType::Unspecified => "STORAGE_POOL_TYPE_UNSPECIFIED",
            StoragePoolType::LocalDir => "STORAGE_POOL_TYPE_LOCAL_DIR",
            StoragePoolType::LocalLvm => "STORAGE_POOL_TYPE_LOCAL_LVM",
            StoragePoolType::Nfs => "STORAGE_POOL_TYPE_NFS",
            StoragePoolType::CephRbd => "STORAGE_POOL_TYPE_CEPH_RBD",
            StoragePoolType::CephFs => "STORAGE_POOL_TYPE_CEPH_FS",
            StoragePoolType::Iscsi => "STORAGE_POOL_TYPE_ISCSI",
        }
    }
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_POOL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STORAGE_POOL_TYPE_LOCAL_DIR" => Some(Self::LocalDir),
            "STORAGE_POOL_TYPE_LOCAL_LVM" => Some(Self::LocalLvm),
            "STORAGE_POOL_TYPE_NFS" => Some(Self::Nfs),
            "STORAGE_POOL_TYPE_CEPH_RBD" => Some(Self::CephRbd),
            "STORAGE_POOL_TYPE_CEPH_FS" => Some(Self::CephFs),
            "STORAGE_POOL_TYPE_ISCSI" => Some(Self::Iscsi),
            _ => None,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolumeSourceType {
    Empty = 0,
    Clone = 1,
    Image = 2,
    Snapshot = 3,
}
impl VolumeSourceType {
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VolumeSourceType::Empty => "VOLUME_SOURCE_EMPTY",
            VolumeSourceType::Clone => "VOLUME_SOURCE_CLONE",
            VolumeSourceType::Image => "VOLUME_SOURCE_IMAGE",
            VolumeSourceType::Snapshot => "VOLUME_SOURCE_SNAPSHOT",
        }
    }
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOLUME_SOURCE_EMPTY" => Some(Self::Empty),
            "VOLUME_SOURCE_CLONE" => Some(Self::Clone),
            "VOLUME_SOURCE_IMAGE" => Some(Self::Image),
            "VOLUME_SOURCE_SNAPSHOT" => Some(Self::Snapshot),
            _ => None,
        }
    }
}

// Storage pool configuration messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalDirPoolConfig {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfsPoolConfig {
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub export_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub options: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub mount_point: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CephPoolConfig {
    #[prost(string, tag = "1")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pool_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub monitors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub keyring_path: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub secret_uuid: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IscsiPoolConfig {
    #[prost(string, tag = "1")]
    pub portal: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub chap_enabled: bool,
    #[prost(string, tag = "4")]
    pub chap_user: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub chap_password: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub lun: u32,
    #[prost(string, tag = "7")]
    pub volume_group: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolConfig {
    #[prost(message, optional, tag = "1")]
    pub local: ::core::option::Option<LocalDirPoolConfig>,
    #[prost(message, optional, tag = "2")]
    pub nfs: ::core::option::Option<NfsPoolConfig>,
    #[prost(message, optional, tag = "3")]
    pub ceph: ::core::option::Option<CephPoolConfig>,
    #[prost(message, optional, tag = "4")]
    pub iscsi: ::core::option::Option<IscsiPoolConfig>,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitStoragePoolRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(enumeration = "StoragePoolType", tag = "2")]
    pub r#type: i32,
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<StoragePoolConfig>,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolIdRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolInfoResponse {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(enumeration = "StoragePoolType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub mount_path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub device_path: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rbd_pool: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub total_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub available_bytes: u64,
    #[prost(uint64, tag = "8")]
    pub used_bytes: u64,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStoragePoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<StoragePoolInfoResponse>,
}

// Volume operation messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeIdRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub volume_id: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVolumeRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub volume_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub size_bytes: u64,
    #[prost(enumeration = "VolumeSourceType", tag = "4")]
    pub source_type: i32,
    #[prost(string, tag = "5")]
    pub source_id: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeVolumeRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub volume_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub new_size_bytes: u64,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneVolumeRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_volume_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dest_volume_id: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeAttachInfoResponse {
    #[prost(string, tag = "1")]
    pub volume_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub disk_xml: ::prost::alloc::string::String,
}

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVolumeSnapshotRequest {
    #[prost(string, tag = "1")]
    pub pool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub volume_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub snapshot_id: ::prost::alloc::string::String,
}

/// Generated client implementations.
pub mod node_daemon_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct NodeDaemonServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NodeDaemonServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NodeDaemonServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NodeDaemonServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NodeDaemonServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Health check endpoint
        pub async fn health_check(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/HealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "HealthCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get node information and capabilities
        pub async fn get_node_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NodeInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/GetNodeInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "GetNodeInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// VM Lifecycle Operations
        pub async fn create_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateVmResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/CreateVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "CreateVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/StartVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "StartVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::StopVmRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/StopVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "StopVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn force_stop_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/ForceStopVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "ForceStopVM",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn reboot_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/RebootVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "RebootVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn pause_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/PauseVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "PauseVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn resume_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/ResumeVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "ResumeVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_vm(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/DeleteVM",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "DeleteVM"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// VM Status
        pub async fn get_vm_status(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VmStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/GetVMStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "GetVMStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_v_ms(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListVMsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/ListVMs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("limiquantix.node.v1.NodeDaemonService", "ListVMs"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Console
        pub async fn get_console(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConsoleInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/GetConsole",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "GetConsole",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Snapshots
        pub async fn create_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SnapshotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/CreateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "CreateSnapshot",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn revert_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::RevertSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/RevertSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "RevertSnapshot",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/DeleteSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "DeleteSnapshot",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_snapshots(
            &mut self,
            request: impl tonic::IntoRequest<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSnapshotsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/ListSnapshots",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "ListSnapshots",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Metrics & Events (Streaming)
        pub async fn stream_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NodeMetrics>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/StreamMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "StreamMetrics",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_events(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NodeEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/limiquantix.node.v1.NodeDaemonService/StreamEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "limiquantix.node.v1.NodeDaemonService",
                        "StreamEvents",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod node_daemon_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with NodeDaemonServiceServer.
    #[async_trait]
    pub trait NodeDaemonService: Send + Sync + 'static {
        /// Health check endpoint
        async fn health_check(
            &self,
            request: tonic::Request<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        >;
        /// Get node information and capabilities
        async fn get_node_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::NodeInfoResponse>,
            tonic::Status,
        >;
        /// VM Lifecycle Operations
        async fn create_vm(
            &self,
            request: tonic::Request<super::CreateVmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateVmResponse>,
            tonic::Status,
        >;
        async fn start_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn stop_vm(
            &self,
            request: tonic::Request<super::StopVmRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn force_stop_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn reboot_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn pause_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn resume_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn delete_vm(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// VM Status
        async fn get_vm_status(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VmStatusResponse>,
            tonic::Status,
        >;
        async fn list_v_ms(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::ListVMsResponse>, tonic::Status>;
        /// Console
        async fn get_console(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConsoleInfoResponse>,
            tonic::Status,
        >;
        /// Snapshots
        async fn create_snapshot(
            &self,
            request: tonic::Request<super::CreateSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SnapshotResponse>,
            tonic::Status,
        >;
        async fn revert_snapshot(
            &self,
            request: tonic::Request<super::RevertSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn delete_snapshot(
            &self,
            request: tonic::Request<super::DeleteSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn list_snapshots(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSnapshotsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamMetrics method.
        type StreamMetricsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::NodeMetrics, tonic::Status>,
            >
            + Send
            + 'static;
        /// Metrics & Events (Streaming)
        async fn stream_metrics(
            &self,
            request: tonic::Request<super::StreamMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamMetricsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamEvents method.
        type StreamEventsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::NodeEvent, tonic::Status>,
            >
            + Send
            + 'static;
        async fn stream_events(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamEventsStream>,
            tonic::Status,
        >;
        
        // =========================================================================
        // Guest Agent Operations
        // =========================================================================
        
        /// Ping the guest agent
        async fn ping_agent(
            &self,
            request: tonic::Request<super::VmIdRequest>,
        ) -> std::result::Result<tonic::Response<super::AgentPingResponse>, tonic::Status>;
        
        /// Execute a command inside the VM
        async fn execute_in_guest(
            &self,
            request: tonic::Request<super::ExecuteInGuestRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteInGuestResponse>, tonic::Status>;
        
        /// Read a file from the VM
        async fn read_guest_file(
            &self,
            request: tonic::Request<super::ReadGuestFileRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadGuestFileResponse>, tonic::Status>;
        
        /// Write a file to the VM
        async fn write_guest_file(
            &self,
            request: tonic::Request<super::WriteGuestFileRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteGuestFileResponse>, tonic::Status>;
        
        /// Request guest shutdown/reboot
        async fn guest_shutdown(
            &self,
            request: tonic::Request<super::GuestShutdownRequest>,
        ) -> std::result::Result<tonic::Response<super::GuestShutdownResponse>, tonic::Status>;
        
        // =========================================================================
        // Storage Pool Operations
        // =========================================================================
        
        /// Initialize a storage pool
        async fn init_storage_pool(
            &self,
            request: tonic::Request<super::InitStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::StoragePoolInfoResponse>, tonic::Status>;
        
        /// Destroy a storage pool
        async fn destroy_storage_pool(
            &self,
            request: tonic::Request<super::StoragePoolIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        
        /// Get storage pool info
        async fn get_storage_pool_info(
            &self,
            request: tonic::Request<super::StoragePoolIdRequest>,
        ) -> std::result::Result<tonic::Response<super::StoragePoolInfoResponse>, tonic::Status>;
        
        /// List all storage pools
        async fn list_storage_pools(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::ListStoragePoolsResponse>, tonic::Status>;
        
        // =========================================================================
        // Storage Volume Operations
        // =========================================================================
        
        /// Create a volume
        async fn create_volume(
            &self,
            request: tonic::Request<super::CreateVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        
        /// Delete a volume
        async fn delete_volume(
            &self,
            request: tonic::Request<super::VolumeIdRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        
        /// Resize a volume
        async fn resize_volume(
            &self,
            request: tonic::Request<super::ResizeVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        
        /// Clone a volume
        async fn clone_volume(
            &self,
            request: tonic::Request<super::CloneVolumeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        
        /// Get volume attach info
        async fn get_volume_attach_info(
            &self,
            request: tonic::Request<super::VolumeIdRequest>,
        ) -> std::result::Result<tonic::Response<super::VolumeAttachInfoResponse>, tonic::Status>;
        
        /// Create a volume snapshot
        async fn create_volume_snapshot(
            &self,
            request: tonic::Request<super::CreateVolumeSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct NodeDaemonServiceServer<T: NodeDaemonService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: NodeDaemonService> NodeDaemonServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for NodeDaemonServiceServer<T>
    where
        T: NodeDaemonService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/limiquantix.node.v1.NodeDaemonService/HealthCheck" => {
                    #[allow(non_camel_case_types)]
                    struct HealthCheckSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::HealthCheckRequest>
                    for HealthCheckSvc<T> {
                        type Response = super::HealthCheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HealthCheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::health_check(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = HealthCheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/GetNodeInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetNodeInfoSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<T: NodeDaemonService> tonic::server::UnaryService<()>
                    for GetNodeInfoSvc<T> {
                        type Response = super::NodeInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::get_node_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetNodeInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/CreateVM" => {
                    #[allow(non_camel_case_types)]
                    struct CreateVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::CreateVmRequest>
                    for CreateVMSvc<T> {
                        type Response = super::CreateVmResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateVmRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::create_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/StartVM" => {
                    #[allow(non_camel_case_types)]
                    struct StartVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest> for StartVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::start_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StartVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/StopVM" => {
                    #[allow(non_camel_case_types)]
                    struct StopVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::StopVmRequest>
                    for StopVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopVmRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::stop_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StopVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/ForceStopVM" => {
                    #[allow(non_camel_case_types)]
                    struct ForceStopVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for ForceStopVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::force_stop_vm(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ForceStopVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/RebootVM" => {
                    #[allow(non_camel_case_types)]
                    struct RebootVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for RebootVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::reboot_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RebootVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/PauseVM" => {
                    #[allow(non_camel_case_types)]
                    struct PauseVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest> for PauseVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::pause_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PauseVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/ResumeVM" => {
                    #[allow(non_camel_case_types)]
                    struct ResumeVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for ResumeVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::resume_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ResumeVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/DeleteVM" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteVMSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for DeleteVMSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::delete_vm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteVMSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/GetVMStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetVMStatusSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for GetVMStatusSvc<T> {
                        type Response = super::VmStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::get_vm_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetVMStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/ListVMs" => {
                    #[allow(non_camel_case_types)]
                    struct ListVMsSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<T: NodeDaemonService> tonic::server::UnaryService<()>
                    for ListVMsSvc<T> {
                        type Response = super::ListVMsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::list_v_ms(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListVMsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/GetConsole" => {
                    #[allow(non_camel_case_types)]
                    struct GetConsoleSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for GetConsoleSvc<T> {
                        type Response = super::ConsoleInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::get_console(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetConsoleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/CreateSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSnapshotSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::CreateSnapshotRequest>
                    for CreateSnapshotSvc<T> {
                        type Response = super::SnapshotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::create_snapshot(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateSnapshotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/RevertSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct RevertSnapshotSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::RevertSnapshotRequest>
                    for RevertSnapshotSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RevertSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::revert_snapshot(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RevertSnapshotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/DeleteSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSnapshotSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::DeleteSnapshotRequest>
                    for DeleteSnapshotSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::delete_snapshot(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteSnapshotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/ListSnapshots" => {
                    #[allow(non_camel_case_types)]
                    struct ListSnapshotsSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::UnaryService<super::VmIdRequest>
                    for ListSnapshotsSvc<T> {
                        type Response = super::ListSnapshotsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VmIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::list_snapshots(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSnapshotsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/StreamMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct StreamMetricsSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<
                        T: NodeDaemonService,
                    > tonic::server::ServerStreamingService<super::StreamMetricsRequest>
                    for StreamMetricsSvc<T> {
                        type Response = super::NodeMetrics;
                        type ResponseStream = T::StreamMetricsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::stream_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StreamMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/limiquantix.node.v1.NodeDaemonService/StreamEvents" => {
                    #[allow(non_camel_case_types)]
                    struct StreamEventsSvc<T: NodeDaemonService>(pub Arc<T>);
                    impl<T: NodeDaemonService> tonic::server::ServerStreamingService<()>
                    for StreamEventsSvc<T> {
                        type Response = super::NodeEvent;
                        type ResponseStream = T::StreamEventsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeDaemonService>::stream_events(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StreamEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: NodeDaemonService> Clone for NodeDaemonServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: NodeDaemonService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: NodeDaemonService> tonic::server::NamedService
    for NodeDaemonServiceServer<T> {
        const NAME: &'static str = "limiquantix.node.v1.NodeDaemonService";
    }
}
